        opt     nol        lib     ./loopdrvr.h        lib     ../include/blktab.h        lib     ./gendrvr.h        opt     lis,exp        if      (LOOP=1)        sttl     loop Driver        pag        name    loopdrvr        global  loopopen,loopclos,loopio        global  lopopen,lopclos,lopread,lopwrit,lopspcl        global  loopdt* Device Tables** dtdfl rmb     2       device buffer fwd link* dtdbl rmb     2       device buffer bwd link* dtqfl rmb     2       device io queue fwd link* dtqbl rmb     2       device io queue bwd link* dtbusy        rmb     1       device busy flag* dtrtry        rmb     1       device error retry count* dtspr rmb     2       device spare byteloopdt   rzb     DVTSIZ          device table*LOOPtbl fdb     0               Block Device Table addressloopopt fcb     0,0             2 loop devicesloop1   rzb     LOPSIZ          pseudo fdn'sloop2   rzb     LOPSIZuiosav1 rzb     UCPSIZuiosav2 rzb     UCPSIZfdnsav  rzb     2       debug** open the loop disk drive - insure the device is online, etc.* B contains device minor*loopopen pshs    d        ldx     #loopopt        lda     b,x        beq     loopop2        inc     b,x        bra     loopop3*loopop2  jsr     lopopen          do character open stuffloopop3  puls    d,pc            retunr* loop closeloopclos        ldx     #loopopt*       dec     b,x             dec open counter*       bpl     loopcl1        clr     b,x             clear open statusloopcl1  rts                     return** fire up FLP operation to initiate transfer* Y = buf header*loopio   stx     LOOPtbl         save Block Device Table address        inc     loopdt+dtbusy    mark busy        ldu     #loop1        ldb     bfdvn+1,y       get device #        beq     70f        leau    LOPSIZ,u        point to the other*70      lda     #1              set func        sta     loopdt+dtrtry*        ldd     lpfdn,u         if zero no        bne     71f             file has been 'loop-ed'        ldb     #ENIO        bra     looperr*71      pshs    y               bfhdr        ldd     lpdev,u        ldy     lpfdn,u        jsr     asnfdn          get the full fdn info in X        pshs    x               the complete inode*        bsr     savuio          save uio info        ldy     2,s             restore bfhdr        bsr     setuio          set new values        ldy     0,s             Y has fdnptr        bne     72f        ldx     2,s        lda     bfflag,x        bita    #BFRWF        bne     72f* transfer data to special buffer        ldd     bfxfc,x        trfr    D,W        ldy     #loopbf        jsr     mapbpt        tfm1    X,Y*        ldy     0,s             restore fdn        jsr     filrd        bsr     resuio          restore uio info        puls    x,y        bra     loopdon*72      jsr     filwr        bsr     resuio        ldx     2,x        ldd     bfxfc,x        tfrf    D,W        ldy     #loopbuf        tfm1    Y,X        puls    x,y*loopdon clr     loopdt+dtbusy    set unbusy        clr     loopdt+dtrtry    clear funtion        ldx     LOOPtbl        jmp     BDioend**  character open*lopopen  equ     *        ldx     #loopopt        cmpb    #1        bhi     lopchop4        inc     b,x        bra     lopchop5*lopchop4 lda     #EBARG        sta     uerrorlopchop5 rts** character close*lopclos  jmp     loopclos** lopchrd*lopread  equ     *        pshs    d       save device number        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure buffer        tst     uerror  OK?        beq     fchrd4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchrd4  pshs    a       save task mode byte        orb     #BFRWF  set read        stb     bfflag,y save        bra     fchio** lopchwr*lopwrit  equ     *        pshs    d       save device info        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure        tst     uerror  OK        beq     fchwr4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchwr4  pshs    a       save task mode bytefchio   ldb     #FLmajor        jmp     blkcio** fchcn** Configure the buffer header pointed at by Y.* This routine sets up the character device info* from the user block and puts it in the buffer* header such that the device drivers can use* the informationfor the transfer* this routine is specific for the floppy driver*fchcn   std     bfdvn,y save device info        ldd     uicnt   xfr count        std     bfxfc,y        cmpd    #128    check valid numbers        beq     fcnch4        cmpd    #256        beq     fcnch4        cmpd    #512        bne     fcnch8fcnch4  jmp     blkcnf*fcnch8  lda     #EBARG  set error        sta     uerror        rts** lopspcl*lopspcl        tfr     x,y        ldx     #loopsts         side info table        abx                     correct entry        cmpy    #0        bne     01f*        ldd     usarg0        rts01        std     0,x        endif        end