  0000                         absSWTPc      Intelligent I/O Proce     08:51:45  Feb 29, 2020   Page    1Hardware   Definitions                                                                                                                  *       lib ../include/sysdefs.h                     *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100               0F3F  DEBUG_CONTROL set %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0001  DO_HISTORY set   1         Include transaction history mechanism               0000  DO_IXON   set    0         Include Input XON/XOFF Handshaking                                          * Character Constants                                    0003  INTRC     equ    $03       DEL character               0004  EOTCH     equ    $04       EOT character               007F  BSPCH     equ    $7f       back space character               0009  TABCH     equ    $09       tab character               000A  NL        equ    $0A       Line Feed               000D  CR        equ    $0D       Carriage Return               0010  DLE       equ    $10       Data Link Escape (DLE)               0013  XOFFC     equ    $13       XOFF character               0011  XONC      equ    $11       XON character               0018  CNCLC     equ    $18       line cancel char               001B  HOLDC     equ    $1B       ESC - suspend output               001C  QUITC     equ    $1C       FS character               0020  SPACE     equ    $20       space character                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFF6  TTYIPR    equ    -10       Waiting for terminal input               FFEC  TTYOPR    equ    -20       Waiting for terminal output - in ttywrt               FFE2  TTYSPR    equ    -30       Waiting for space in output Q - in req_writeSWTPc      Intelligent I/O Proce     08:51:46  Feb 29, 2020   Page    2Hardware   Definitions                                             FFDD  TTYLOCK   equ    -35       Waiting for access to TTY table               FFD8  TIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIO               FFC4  CLOCKPR   equ    -60       Waiting for a clock tick                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)                                          * -- Configuration constants                                    000A  MAX_TI    equ    10        # Queued terminal interrupts               0004  MAX_TTY   equ    4         # terminal devices               0000  MAX_PPR   equ    0         # printer devices               0000  MAX_NEC   equ    0         # NEC printers               007C  MAX_CL    equ    124       upper limit on # CLISTS               0400  MAX_OB    equ    8*128     upper limit on output buffer size               0120  MIN_OB    equ    (2*128)+32 lower limit on output buffer size               0028  MAX_TSK   equ    40        52 upper limit on # of tasks               0020  MIN_TSK   equ    32        lower limit on # of tasks                     *               0005  MAX_DEV   equ    MAX_TTY+MAX_PPR+MAX_NEC+1 (Includes TOD clock)                     *               0100  PRCSIZ    equ    256               00FE  CHRLIM    equ    PRCSIZ-2  max chars in buffer                     SWTPc      Intelligent I/O Proce     08:51:46  Feb 29, 2020   Page    3Macro Definitions                                                                             *                     * This file contains all macro definitions                     * used in the system.                     *                                    0040  FF        equ    %01000000 FIRQ interrupt mask               0010  IF        equ    %00010000 IRQ interrupt mask                                    0000  D         equ    0               0001  X         equ    1               0002  Y         equ    2               0003  U         equ    3               0004  S         equ    4               0005  PC        equ    5               0006  W         equ    6               0007  V         equ    7               0008  A         equ    8               0009  B         equ    9               000A  CC        equ    10               000B  DP        equ    11               000E  E         equ    14               000F  F         equ    15                                                               *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #FF|IF                               endm                                                               *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(FF|IF)                               endm                                                               SWTPc      Intelligent I/O Proce     08:51:46  Feb 29, 2020   Page    4Macro Definitions                                                                             *                     * lsr a 4 times and increment it                     * used in taskcon.t                     *                                          lsr4p     macro  no        args                               lsra                               lsra                               lsra                               lsra                               inca                               endm                                                               *                     * debug macro                     *                                          dbugm     macro  output_character                               lda    #'&1                               lbsr   syspch                               endm                                          *                     * HD6309 MACRO's                     *                                          ldmd      macro                               fdb    $113d                               fcb    &1                               endm                                          ldwi      macro                               fdb    $1086                               fdb    &1                               endm                                          ldwd      macro                               fdb    $1096                               fcb    &1                               endm                                          ldwe      macro                               fdb    $10b6                               fdb    &1                               endm                                          tfm1      macro                               fdb    $1138                               fcb    &1<<4|&2                               endmSWTPc      Intelligent I/O Proce     08:51:46  Feb 29, 2020   Page    5Macro Definitions                                                                             tfm4      macro                               fdb    $113b                               fcb    &1<<4|&2                               endm                                          lsld      macro                               fdb    $1048                               endm                                          lsrd      macro                               fdb    $1044                               endm                                          eorr      macro                               fdb    $1036                               fcb    &1<<4|&2                               endm                                          *                     * trfr, transfer registers                     *                     trfr      macro                               fcb    $1f                               fcb    &1<<4|&2                               endm                                          *                     * addr, add reg0 + reg1 => reg1                     *                     addr      macro                               fdb    $1030                               fcb    &1<<4|&2                               endm                                          * extended addressing mode                     aime      macro                               fcb    $72                               fcb    &1                               fdb    &2                               endm                                          * extended addressing mode                     oime      macro                               fcb    $71                               fcb    &1                               fdb    &2                               endmSWTPc      Intelligent I/O Proce     08:51:47  Feb 29, 2020   Page    6Device     Table Structure                                                                    *                     * Possible module types table                     *                       0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *                       0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table  0004               dev_brbu  rmb    2         baudrate backup loc  0006               dev_brmk  rmb    1         baudrate mask  0007               dev_spar  rmb    1         spare byte                     *  0008               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device                     *                       0000                         org    $0000  0000                         rmb    2         0  0002               D_OPEN    rmb    2         1  0004               D_CLOSE   rmb    2         2  0006               D_TTYS    rmb    2         3  0008               D_TTYG    rmb    2         4  000A               D_RQWR    rmb    2         5  000C               D_WRITE   rmb    2         6  000E               D_WRC     rmb    2         7  0010               D_RQRD    rmb    2         8  0012               D_SEND    rmb    2         9  0014               D_INTRPT  rmb    2         A  0016                         rmb    2         B  0018                         rmb    2         C  001A                         rmb    2         D  001C                         rmb    2         E  001E               D_CLOCK   rmb    2         F  0020               D_inthan  rmb    2         10 Interrupt poller/handler  0022               D_init    rmb    2         11 Device initialization  0024               D_test    rmb    2         12 Test for device present                     *  0026               D_END     rmb    0         End of common handlers                     SWTPc      Intelligent I/O Proce     08:51:47  Feb 29, 2020   Page    7Device     Table Structure                                               *                     * TTY Specific device routines                     *  0026                         org    D_END  0026               D_ttconf  rmb    2  0028               D_ttputc  rmb    2  002A               D_ttgetc  rmb    2  002C               D_ttenxr  rmb    2  002E               D_ttdisx  rmb    2  0030               D_ttenr   rmb    2  0032               D_ttenx   rmb    2  0034               D_ttenno  rmb    2  0036               D_ttxbsy  rmb    2  0038               D_tttstx  rmb    2  003A               D_ttiscts rmb    2  003C               D_tttstr  rmb    2  003E               D_tttstb  rmb    2  0040               D_tttsts  rmb    2  0042               D_tttstc  rmb    2  0044               D_tttstd  rmb    2  0046               D_tttste  rmb    2  0048               D_ttend   rmb    2  004A               D_ttwcts  rmb    2  004C               D_ttwdcd  rmb    2                     SWTPc      Intelligent I/O Proce     08:51:48  Feb 29, 2020   Page    8History Queue Record Structure                                             0000                         org    0  0000               hst_cmd   rmb    1         Command  0001               hst_seq   rmb    1         Sequence #  0002               hst_tty   rmb    1         TTY #  0003               hst_val   rmb    1         Message dependent data                     *  0004               HRECSIZ   rmb    0                                          *                     * Number of history records supported                     *               0010  MAXHIST   equ    16                     SWTPc      Intelligent I/O Proce     08:51:48  Feb 29, 2020   Page    9IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0100  RAMorg    equ    $0100     12 // 28K of RAM - Thru $6FFF               2FFF  RAMend    equ    $2FFF     // $6FFF               3000  RAMscratch equ   $3000     // $7000      4K of scratchpad RAM               3F00  RAMscrend equ    $3F00     // $7F00               3FFF  ROMstack  equ    $3FFF     // $7FFF      High end of ROM Stack               4000  ROMLOorg  equ    $4000     // $E000      8K of ROM - $E000-$FFFF               6000  DEBUGROM  equ    $6000     // $C000      8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, up to 6 IO boards                     *               8000  SYS_ACIA  equ    $8000     first ACIA in first slot               0001  NUM_SLOTS equ    1         // 6          Number of Physical I/O slots               8000  BASE_SLOT equ    $8000     Base address for I/O slots               0010  NEXT_SLOT equ    $0010     Offest between slots                                          * clock hardware               8070  CLOCK     equ    $8070     hardware clock, status and control               8071  CLOCKI    equ    $8071     interrupt resetSWTPc      Intelligent I/O Proce     08:51:49  Feb 29, 2020   Page   10IOP        Memory Layout                                                                      *                     * Clist Structure                     *                     * The clist structure is the head of a linked list of                     * characters used for i/o.  A head and tail pointer                     * are kept, as well as a character count of active                     * characters on the queue.                     *                                          * struct clist                       0000                         org    0                       0000               clcnt     rmb    1         character count  0001               clfst     rmb    2         head character pointer  0003               cllst     rmb    2         tail character pointer                     *               0005  QH_SIZE   equ    *         Size of Queue Header                                                               *                     * Clist Buffer                     *                     * The characters for i/o are placed in buffers as                     * needed.  Each buffer contains 32 bytes, the first                     * two contain a chain pointer, the next 30 hold                     * the actual characters.                     *                       0000                         org    0                                    0020  CBSIZE    equ    32  0000               cbstrt    rmb    2  0002               cbchrs    rmb    CBSIZE-2SWTPc      Intelligent I/O Proce     08:51:49  Feb 29, 2020   Page   11Output     Queue Structure                                                                    *                     * This is the definition of the output queue used                     * to buffer characters going to a terminal.  It is                     * different from the "clist" mechanism for efficiency                     * concerns.                     *                       0000                         org    0  0000               oq_count  rmb    2         Number of characters in Q  0002               oq_buf    rmb    2         Start of Q buffer  0004               oq_put    rmb    2         Address of next character to insert  0006               oq_get    rmb    2         Address of next character to consume  0008               oq_end    rmb    2         Limiting address of Q                     *  000A               OQH_SIZE  rmb    0         Size of output Queue headerTask       Structure                 08:51:49  Feb 29, 2020   Page   12Output     Queue Structure                                               *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    006C  USTSIZ    equ    108       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tsdev     rmb    1         Terminal task is servicing  0009               tssgnl    rmb    1         Signal waiting for task  000A               tscmd     rmb    1         Saved mailbox command  000B               tsseq     rmb    2         Saved message sequence #  000D               tstval    rmb    1         Saved transaction value  000E               usp       rmb    2         Saved User Stack Pointer  0010               umark0    rmb    2         Stack Frame Markers  0012               umark1    rmb    2  0014                         rmb    USTSIZ    space for per/process stack                                    0080  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system taskTask       Structure                 08:51:49  Feb 29, 2020   Page   13TTY        Structure                                                                          *                     * TTY Structure                     *                     * A tty structure is required for each character type                     * i/o device used for standard terminal i/o.                     *                                          * struct tty                       0000                         org    0                       0000               tqin      rmb    2         pointer to in q clist str  0002               tqproc    rmb    2         pointer to proccessed q clist str  0004               tqout     rmb    2         pointer to out q clist str  0006               taddr     rmb    2         device address  0008               tflags    rmb    1         mode flags  0009               tdelay    rmb    1         time out definitions  000A               tdevic    rmb    1         device name  000B               tdel      rmb    1         raw delimiter count  000C               tcolm     rmb    1         printing column  000D               tbksp     rmb    1         back space character  000E               tcncl     rmb    1         line cancel character  000F               tbaud     rmb    1         device baud rates  0010               tbaud2    rmb    1         actual baud rate (for baud rate generator)  0011               tstate    rmb    1         internal state  0012               tstate2   rmb    1         additional states  0013               tstate3   rmb    1         states of CTS,DCD  0014               tlock     rmb    1         structure lock  0015               tsold     rmb    2         amount of output queue already "sold"  0017               tregs     rmb    8         copy of device registers (for 8274)                                    001F  TTYSIZ    equ    *                                                               * modes                                    0001  RAW       equ    %00000001 raw or cooked mode               0002  ECHO      equ    %00000010 echo characters               0004  XTABS     equ    %00000100 expand tabs               0008  LCASE     equ    %00001000 map to lower case               0010  CRMOD     equ    %00010000 map NL to CR & LF               0020  BSECH     equ    %00100000 backspace echo flag               0040  SCHR      equ    %01000000 single character input               0080  CNTRL     equ    %10000000 ignore control characters                                          * internal states                                    0001  TIMOUT    equ    %00000001 timeout in progress               0002  HOLD      equ    %00000010 output suspended               0004  TOPEN     equ    %00000100 terminal has been opened               0008  TRANSPNT  equ    %00001000 Transparent modeTask       Structure                 08:51:49  Feb 29, 2020   Page   14TTY        Structure                                               0010  IXONXOF   equ    %00010000 Use XON/XOFF to control input               0010  TOPWOC    equ    %00010000 Device opened without carrier present               0020  XANY      equ    %00100000 Allow any character to break HOLD               0040  XONXOF    equ    %01000000 XON/XOFF protocol               0080  ESCOFF    equ    %10000000 Disable ESC as HOLD character                     *               00F8  PROTOCOL  equ    ESCOFF|XANY|XONXOF|IXONXOF|TRANSPNT                                    0001  DSR_OK    equ    %00000001 OK to send               0002  SEND_XON  equ    %00000010 Send XON next               0004  SEND_XOF  equ    %00000100 Send XOFF next               0008  SEND_DLE  equ    %00001000 Send DLE next               0010  XOF_SENT  equ    %00010000 We shut the other guy down               0020  DLE_SENT  equ    %00100000 DLE sequence started               0040  DLE_GOT   equ    %01000000 DLE sequence receivedTask       Structure                 08:51:50  Feb 29, 2020   Page   15Variable   Space                                                           0100                         org    RAMorg                       0100               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"  0100               OBUF_SIZE rmb    2         Size of TTY Output Queues  0102               OQHI      rmb    2         Output Queue High-water mark  0104               OQLO      rmb    2         Output Queue Low-water mark  0106               slot_tbl  rmb    2*NUM_SLOTS slot configuration                       0108               DB_iflg   rmb    1         Debug terminal initialized  0109               DB_cntrl  rmb    2         Debug control flags                     *  010B               runlst    rmb    2         Pointer to active tasks  010D               slplst    rmb    4         Pointer to waiting tasks  0111               utask     rmb    2         Currently executing task  0113               jobpri    rmb    1         Current job priority (for scheduling)  0114               chproc    rmb    1         Set if must switch users of CPU (reschedule)  0115               cfreel    rmb    2         Pointer to first free Clist buffer  0117               cbufct    rmb    1         Count of Clist buffers in use  0118               lcbuf     rmb    1         Limit on Clist buffers  0119               idle      rmb    1         idle loop flag for scheduler  011A               TI_Q      rmb    2*MAX_TI  Max Terminal Interrupts  012E               TI_Q_ptr  rmb    2         current Q pointer  0130               FIO_lock  rmb    1         FIO in use lock  0131               int_buf   rmb    4         Current Message in  0135               int_ptr   rmb    2         Message in pointer  0137               clock_tick rmb   1         Clock tick counter  0138               prcbuf    rmb    PRCSIZ    buffer for erase and kill                       0238               hstbuf    rmb    HRECSIZ*MAXHIST  0278               hstptr    rmb    2         next "put" pointer in history queue                                          * Pointers to system tables - configuration dependent  027A               CLISTS    rmb    2         Space for Clists  027C               TTYTABS   rmb    2         Terminal tables  027E               TTYQS     rmb    2         TTY Input Queue Headers  0280               OBUFRS    rmb    2         TTY Output Queues  0282               tsktab    rmb    2         Task Control Tables  0284               tskend    rmb    2         End of task table  0286               PPstr     rmb    2         Pointer to parallel device tables  0288               NECstr    rmb    2         Pointer to NEC device tables  028A               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table  02B2               NEC_IQ    rmb    2         Pointer to NEC input queue  02B4               NECADR    rmb    2         Address of NEC printer                     *  02B6               brbutb    rmb    MAX_TTY/2 baudrate latch backup table                     *  02B8               SYS_TABS  rmb    0         Start of dynamic system tables                                    2FFF  end_vars  equ    RAMend    End of System VariablesTask       Structure                 08:51:50  Feb 29, 2020   Page   16Variable   Space                                    Task       Structure                 08:51:50  Feb 29, 2020   Page   17Variable   Space                                                         *                     * ACIA Structure                     *                                          * struct acia                       0000                         org    0                                            0000               csr       rmb    1         control - status  0001               dbuf      rmb    1         data buffer  0002               brr       rmb    1         baudrate latch                                          *                     * status codes                     *               0001  AS_RDRF   equ    %00000001 receive data register full               0002  AS_TDRE   equ    %00000010 transmit data register empty               0004  AS_NDCD   equ    %00000100 DCD status bit, 1 is inactive               0008  AS_NCTS   equ    %00001000 CTS bit, 1 is inactive TX IRQ off               0010  AS_FRME   equ    %00010000 receive framing error               0020  AS_OVRN   equ    %00100000 receive overrun               0040  AS_PERR   equ    %01000000 receive parity error               0080  AS_IRQ    equ    %10000000 INT flag, 1 is active                     *                     * control codes                     *               0001  AC_DIV0   equ    %00000001 counter divide bit 0 :1/:16/:64/reset               0002  AC_DIV1   equ    %00000010 counter divide bit 1               0004  AC_WS0    equ    %00000100 word select 0 7E2/7O2/7E1/7O1               0008  AC_WS1    equ    %00001000 word select 1 8N2/8N1/8E1/8O1               0010  AC_WS2    equ    %00010000 word select 2               0020  AC_TEIN   equ    %00100000 transmit control 0  NRTS/NINT,NRTS/INTE               0040  AC_DRTS   equ    %01000000 transmit control 1  RTS/NINT,NRTS/SBRK/NINT               0080  AC_REIN   equ    %10000000 receive enable IRQ                     *               0001  AC_DV16   equ    %00000001 setting for clk/16               0003  AC_MRES   equ    AC_DIV1+AC_DIV0 master reset               0014  AC_8N1    equ    AC_WS2+AC_WS0 select for 8N1               0015  AC_SET    equ    AC_8N1+AC_DV16 ACIA default setupTask       Structure                 08:51:50  Feb 29, 2020   Page   18FIO Simulation Structure                                                                      *                     *                     * Control structure used to simulate Z8038 FIO                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     * -- As seen by Main 6809 CPU (UniFLEX)                     *                                    0080  FIFO_SIZE equ    128       Size of FIFO buffer                       0000                         org    $0000     -- Shared Dual Port RAM                                          ************************************************************  0000               iop_cpu   rmb    1         IOP -> CPU Mailbox cell  0001               iop_cpu1  rmb    1         -- Additional cell  0002               iop_cpu2  rmb    1         --  0003               iop_cpu3  rmb    1         --                     ************************************************************  0004               cpu_iop   rmb    1         CPU -> IOP Mailbox cell          message code  0005               cpu_iop1  rmb    1         -- Additional cell    sequence #  0006               cpu_iop2  rmb    1         --                    message specific data  0007               cpu_iop3  rmb    1         --                    terminal #                     ************************************************************  0008               fifo_cnt  rmb    1         Count of data in FIFO  0009               fifo_get  rmb    2         FIFO consumer pointer  000B               fifo_put  rmb    2         FIFO producre pointer  000D                         rmb    16-(*-iop_cpu) ** Filler **                       0010               fifo      rmb    FIFO_SIZE actual FIFO                       0090                         rmb    $100-(*-iop_cpu)-7                                          * IOP Configuration constants  00F9               NUM_TSK   rmb    1         Number of tasks  00FA               NUM_CL    rmb    1         Number of CLISTS  00FB               NUM_TRM   rmb    1         Number of terminals              initialized from IOP  00FC               NUM_NEC   rmb    1         Number of NEC/Qume printers  00FD               NUM_PPR   rmb    1         Number of parallel printers                     * should end up at the two top locations in the DUALPORT RAM  00FE               iop_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  00FF               cpu_iopF  rmb    1         INT + non-zero   contains info AND set IOP IRQ when written                     **************************************************************                                                         0018  MAX_TRAN  equ    24        Max # concurrent transactions / IOP                                          *                     * IOP ROM Version #                     *Task       Structure                 08:51:51  Feb 29, 2020   Page   19FIO Simulation Structure                                           0012  ROM_VERSION equ  $12       Major/Minor Version of IOP ROM                                          *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some osrt of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   equ    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)                                          *                     * Normal responses                     *               0001  R_RESET   equ    $01       System reset & functioning               0002  R_OPEN    equ    $02       Device open successful               0003  R_CLOSE   equ    $03       Device close successful               0004  R_REQOK   equ    $04       Write request now granted               0005  R_WRITE   equ    $05       Write data complete               0006  R_TTY     equ    $06       TTYSET/GET complete               0007  R_RDOK    equ    $07       Read data now available               0008  R_SNDNC   equ    $08       Read data in FIFO & no more data is available               0009  R_RD1C    equ    $09       Single character available               000A  R_INTRPT  equ    $0A       Interrupt complete               000B  R_SNDMC   equ    $0B       Read data in FIFO & there is more available               000C  R_CLOCK   equ    $0C       Interval Timer Tick               000D  R_BAUD    equ    $0D       baudrate data processed                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     *               0010  O_OPEN    equ    $10       Open device               0020  O_CLOSE   equ    $20       Close device               0030  O_TTYS    equ    $30       TTY Set               0040  O_TTYG    equ    $40       TTY Get               0050  O_RQWR    equ    $50       Request write               0060  O_WRITE   equ    $60       Write data               0070  O_WRC     equ    $70       Write single character               0080  O_RQRD    equ    $80       Request read data               0090  O_SEND    equ    $90       Send data for read               00A0  O_INTRPT  equ    $A0       Interrupt all tasks on a terminal               00B0  O_BAUDR   equ    $B0       Read baudrate settings               00C0  O_BAUDW   equ    $C0       Write baudrate settings                                          Task       Structure                 08:51:51  Feb 29, 2020   Page   20CPU        Vectors                                                         FFF0                         org    CPUtraps                       FFF0 40A3                    fdb    rom_trap  Unused  FFF2 409C                    fdb    rom_swi3  SWI3  FFF4 4095                    fdb    rom_swi2  SWI2  FFF6 4088                    fdb    rom_firq  FIRQ  FFF8 447E                    fdb    IRQ_han   IRQ  FFFA 408F                    fdb    rom_swi   SWI  FFFC 4082                    fdb    rom_nmi   NMI  FFFE 405A                    fdb    rom_init  Reset                     Task       Structure                 08:51:51  Feb 29, 2020   Page   21System     RESET Code                                                      4000                         org    ROMLOorg                       4000 0D 49 4F 50   DBmsg00   fcc    $d,'IOP ROM',0  4009 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  4029 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  403D 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          *                     * System RESET code                     *  405A 10CE 3FFF     rom_init  lds    #ROMstack initialize stack pointer                       405E 8E   447E               ldx    #IRQ_han  4061 BF   7F00               stx    $7f00     set ROM IRQ vector                       4064 8E   0100               ldx    #sys_vars clear all of RAM  4067 CC   0000               ldd    #0  406A ED   81       10        std    ,x++  406C 8C   2FFF               cmpx   #end_vars  406F 25   F9                 blo    10b                                           >4071 17   0050     20        lbsr   stbinit   go initialize system memory                                            4074 10FE 0282     30        lds    tsktab    Task 0 Stack  4078 32   E9 0080            leas   TSKSIZ,s  407C 17   029A               lbsr   fio_reset                                          *                     * Initialization complete - Start executing commands                     *  407F               fio_start                     *         ldb     #ROM_VERSION                     *         stb     iop_cpu1                     *         ldb     #R_RESET   send "system reset & running" message                     *         lbsr    fio_msg                                            407F 7E   4608     10        jmp    rsched                     Task       Structure                 08:51:51  Feb 29, 2020   Page   22ROM        Interrupt Fielders                                              4082 8D   26       rom_nmi   bsr    rom_int  4084 4E 4D 49 00             fcc    'NMI',0  4088 8D   20       rom_firq  bsr    rom_int  408A 46 49 52 51             fcc    'FIRQ',0  408F 8D   19       rom_swi   bsr    rom_int  4091 53 57 49 00             fcc    'SWI',0  4095 8D   13       rom_swi2  bsr    rom_int  4097 53 57 49 32             fcc    'SWI2',0  409C 8D   0C       rom_swi3  bsr    rom_int  409E 53 57 49 33             fcc    'SWI3',0  40A3 8D   05       rom_trap  bsr    rom_int  40A5 54 52 41 50             fcc    'TRAP',0                       40AA 8E   40B7     rom_int   ldx    #ROM_ERR  40AD BD   5065               jsr    DB_pdata  40B0 35   10                 puls   x  40B2 BD   5065               jsr    DB_pdata  40B5 20   FE       rom_bad   bra    *                     *  40B7 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0Task       Structure                 08:51:52  Feb 29, 2020   Page   23Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  40C4 8E   0100     stbinit   ldx    #sys_vars clear all variables  40C7 CC   0000               ldd    #0  40CA ED   81       10        std    ,x++  40CC 8C   2FFF               cmpx   #end_vars done yet?  40CF 25   F9                 blo    10b  40D1 CC   0D04               ldd    #DEBUG  40D4 FD   0109               std    DB_cntrl >40D7 17   001F               lbsr   set_tables go figure out configuration, tables, etc                                          ***+++                     * Initialize history queue  40DA 8E   0238               ldx    #hstbuf  40DD BF   0278               stx    hstptr                     ***---                                          ***+++                     ***---                                          * Initialize Terminal Interrupt Queue  40E0 8E   011A     15        ldx    #TI_Q     set queue empty  40E3 BF   012E               stx    TI_Q_ptr  40E6 8E   0131               ldx    #int_buf  reset message in pointer  40E9 BF   0135               stx    int_ptr  40EC 17   0156               lbsr   clinit    initialize Clists                                          ***+++                     ***---                       40EF 17   0175     16        lbsr   ttyinit   initialize TTY tables                                          ***+++                     ***---                       40F2 17   01C1     17        lbsr   tskinit   initialize tasks                                          ***+++                     ***---                       40F5 17   0F8B     18        lbsr   DB_config display configuration  40F8 39                      rts                                                                                    *                     * Set up system tables                     *Task       Structure                 08:51:52  Feb 29, 2020   Page   24Table      Initialization                             40F9               set_tables                                          ***+++                     ***---                                          * -- Force in the on-board PIA                     *09        ldd     #PIA_SLOT                     *          jsr     [D_test+DEV_L2]                     * -- Force in the TOD interface                     *          ldy     #dev_tab+((MAX_DEV-1)*DEV_SIZE)                     *          ldx     #DEV_TOD                     *          stx     dev_type,y                                                               * Compute configuration  40F9 86   01                 lda    #NUM_SLOTS  40FB 34   02                 pshs   a  40FD CC   8000               ldd    #BASE_SLOT set port address  4100 8E   0106               ldx    #slot_tbl  4103 34   10                 pshs   x  4105 CE   4230     10        ldu    #no_dev  4108 EF   84                 stu    0,x  410A CE   430A               ldu    #mod_tbl  tables with module refs  410D AE   C4       12        ldx    mod_type,u  410F 27   0D                 beq    20f       jump if end of module table  4111 AD   98 24              jsr    [D_test,x] check for device  4114 25   04                 bcs    15f       jump if found  4116 33   44                 leau   MOD_SIZE,u  4118 20   F3                 bra    12b  411A AE   42       15        ldx    mod_name,u  411C AF   F4                 stx    [0,s]  411E C3   0010     20        addd   #NEXT_SLOT advance address  4121 AE   E4                 ldx    0,s       update slot table pointer  4123 30   02                 leax   2,x  4125 AF   E4                 stx    0,s  4127 6A   62                 dec    2,s       any more slots  4129 26   DA                 bne    10b  412B 35   12                 puls   a,x                     * -- All done setting up configuration                                          ***+++                     ***---                                          * Set up constants based on configuration  412D 86   7C       22        lda    #MAX_CL  412F 97   FA                 sta    NUM_CL                     *                     *         lda     #MAX_TSK  4131 86   18                 lda    #MAX_TRAN reserve for system tasks  4133 8B   04                 adda   #4  4135 97   F9                 sta    NUM_TSK                     *Task       Structure                 08:51:52  Feb 29, 2020   Page   25Table      Initialization                             4137 CC   0400               ldd    #MAX_OB  413A FD   0100               std    OBUF_SIZE                     * Now figure out where system tables go, based on configuration  413D FC   0100     30        ldd    OBUF_SIZE  4140 83   000A               subd   #10  4143 FD   0102               std    OQHI  4146 83   0085               subd   #(FIFO_SIZE+5)  4149 FD   0104               std    OQLO  414C CC   02B8               ldd    #SYS_TABS start of system tables                     * -- Round up to CBSIZE boundary  414F C3   001F               addd   #CBSIZE-1  4152 C4   E0                 andb   #!(CBSIZE-1)  4154 1F   03                 tfr    d,u                     * -- CLISTS  4156 86   20                 lda    #CBSIZE  4158 D6   FA                 ldb    NUM_CL  415A 3D                      mul  415B FF   027A               stu    CLISTS  415E 17   00D6               lbsr   sto_chk   check for system table space overflow >4161 1025 004D               lbcs   40f       jump if it happens                     * -- TTY Control tables  4165 86   1F                 lda    #TTYSIZ  4167 D6   FB                 ldb    NUM_TRM  4169 3D                      mul  416A FF   027C               stu    TTYTABS   point to tty table  416D 17   00C7               lbsr   sto_chk   check for system table space overflow  4170 25   40                 bcs    40f       jump if it happens                     * -- TTY Queue headers  4172 86   0A                 lda    #2*QH_SIZE  4174 D6   FB                 ldb    NUM_TRM  4176 3D                      mul  4177 FF   027E               stu    TTYQS  417A 17   00BA               lbsr   sto_chk   check for system table space overflow  417D 25   33                 bcs    40f       jump if it happens  417F 86   0A                 lda    #OQH_SIZE  4181 D6   FB                 ldb    NUM_TRM  4183 3D                      mul  4184 17   00B0               lbsr   sto_chk   check for system table space overflow  4187 25   29                 bcs    40f       jump if it happens                     * -- TTY Output Queues  4189 4F                      clra  418A D6   FB                 ldb    NUM_TRM  418C 1F   01                 tfr    d,x  418E CC   0000               ldd    #0  4191 F3   0100     10        addd   OBUF_SIZE  4194 30   1F                 leax   -1,x  4196 26   F9                 bne    10b  4198 FF   0280               stu    OBUFRS  419B 17   0099               lbsr   sto_chk   check for system table space overflow  419E 25   12                 bcs    40f       jump if it happens                     * -- Task table  41A0 86   80                 lda    #TSKSIZTask       Structure                 08:51:54  Feb 29, 2020   Page   26Table      Initialization                             41A2 D6   F9                 ldb    NUM_TSK  41A4 3D                      mul  41A5 FF   0282               stu    tsktab  41A8 17   008C               lbsr   sto_chk   check for system table space overflow  41AB 25   05                 bcs    40f       jump if it happens  41AD FF   0284               stu    tskend                     *  41B0 20   4D                 bra    60f                     * -- System table space has overflowed!                     * -- Try adjusting some parameters to get it under control  41B2 FC   0100     40        ldd    OBUF_SIZE first step, reduce output buffer size  41B5 83   0020               subd   #32  41B8 FD   0100               std    OBUF_SIZE  41BB 1083 0120               cmpd   #MIN_OB  41BF 2C   3B                 bge    50f       jump if still something left  41C1 CC   0400               ldd    #MAX_OB   start over & try something else  41C4 FD   0100               std    OBUF_SIZE  41C7 96   F9                 lda    NUM_TSK   try reducing # tasks  41C9 80   01                 suba   #1  41CB 97   F9                 sta    NUM_TSK  41CD D6   FB                 ldb    NUM_TRM  41CF DB   FD                 addb   NUM_PPR  41D1 DB   FC                 addb   NUM_NEC  41D3 CB   03                 addb   #3  41D5 34   04                 pshs   b  41D7 A1   E0                 cmpa   ,s+  41D9 2C   21                 bge    50f  41DB 86   28                 lda    #MAX_TSK  41DD 97   F9                 sta    NUM_TSK  41DF 96   FA                 lda    NUM_CL    crank back on # clists  41E1 80   01                 suba   #1  41E3 97   FA                 sta    NUM_CL  41E5 91   FB                 cmpa   NUM_TRM  41E7 2C   13                 bge    50f  41E9 C6   7C                 ldb    #MAX_CL  41EB D7   FA                 stb    NUM_CL  41ED 8E   4219               ldx    #00f  41F0 BD   5065               jsr    DB_pdata  41F3 BD   5083               jsr    DB_config  41F6 BD   505F               jsr    DB_main  41F9 7E   405A               jmp    rom_init  ... what else can I do???  41FC 16   FF3E     50        lbra   30b       go try it all again                     *-- Initialize devices  41FF CE   028A     60        ldu    #dev_tab                                            4202 5F            62        clrb  4203 34   04       70        pshs   b  4205 AE   C4                 ldx    dev_addr,u get device address  4207 27   06                 beq    75f       jump if none there  4209 10AE 42                 ldy    dev_type,u get device kind                     Task       Structure                 08:51:54  Feb 29, 2020   Page   27Table      Initialization                                                  420C AD   B8 22              jsr    [D_init,y] go initialize device  420F 33   48       75        leau   DEV_SIZE,u  4211 35   04                 puls   b  4213 5C                      incb  4214 C1   04                 cmpb   #MAX_DEV-1  4216 26   EB                 bne    70b                     * -- All done  4218 39            90        rts                     *  4219 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  4230 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                                                                         *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  4237 33   CB       sto_chk   leau   d,u       compute new end pointer  4239 1183 2FFF               cmpu   #end_vars overflow?  423D 22   03                 bhi    10f       yes - return error  423F 1C   FE                 clc              no         - return OK  4241 39                      rts  4242 1A   01       10        sec              ..         bad owies  4244 39                      rts                                          *                     * clinit                     *                     * Initialize character buffer lists.  This routine                     * is only called once at startup time.                     *                       4245 BE   027A     clinit    ldx    CLISTS    point to clist  4248 D6   FA                 ldb    NUM_CL    set count  424A BF   0115               stx    cfreel    set head pointer  424D 31   88 20    clini2    leay   CBSIZE,x  4250 10AF 84                 sty    0,x       set fwd link  4253 1F   21                 tfr    y,x       advance to next  4255 5A                      decb  4256 26   F5                 bne    clini2  4258 96   FA                 lda    NUM_CL    get buffer count  425A 80   02                 suba   #2  425C B7   0118               sta    lcbuf     set max count  425F 4F                      clra             make       d=0  4260 ED   88 E0              std    -CBSIZE,x clear last linkTask       Structure                 08:51:54  Feb 29, 2020   Page   28Table      Initialization                             4263 7F   0117               clr    cbufct  4266 39                      rts              all        done!                                          *                     * ttyinit                     *                     * Init the tty tables and queues.                     *                       4267 10BE 027E     ttyinit   ldy    TTYQS     point to q tables  426B 6F   E2                 clr    ,-s       terminal # counter  426D D6   FB                 ldb    NUM_TRM   get terminal count  426F 34   04                 pshs   b  4271 FE   0280               ldu    OBUFRS    output buffer  4274 BE   027C               ldx    TTYTABS   point to TTY Tables  4277 10AF 84       10        sty    tqin,x    set input q  427A 31   25                 leay   QH_SIZE,y get next q  427C 10AF 02                 sty    tqproc,x  set pr q  427F 31   25                 leay   QH_SIZE,y set next q  4281 10AF 04                 sty    tqout,x   set output q  4284 EF   22                 stu    oq_buf,y  ** Init output Q **  4286 EF   26                 stu    oq_get,y  4288 EF   24                 stu    oq_put,y  428A FC   0100               ldd    OBUF_SIZE  428D 33   CB                 leau   d,u  428F EF   28                 stu    oq_end,y  4291 31   2A                 leay   OQH_SIZE,y get next q  4293 86   15                 lda    #AC_SET   #%101<<2   8 bits, no parity, 1 stop bit  4295 A7   0F                 sta    tbaud,x   set conf word  4297 A6   61                 lda    1,s       get terminal #  4299 A7   0A                 sta    tdevic,x  set in table  429B 34   46                 pshs   d,u  429D C6   08                 ldb    #DEV_SIZE  429F 3D                      mul  42A0 CE   028A               ldu    #dev_tab  42A3 33   CB                 leau   d,u  42A5 EC   C4                 ldd    dev_addr,u -- device address  42A7 ED   06                 std    taddr,x  42A9 35   46                 puls   d,u  42AB 6C   61                 inc    1,s       bump terminal #  42AD 30   88 1F              leax   TTYSIZ,x  next tty entry  42B0 6A   E4                 dec    0,s       dec the count  42B2 26   C3                 bne    10b       repeat?  42B4 35   86                 puls   d,pc      clean up stack & return                                          *                     * tskinit - Initialize all tasks                     *  42B6 BE   0282     tskinit   ldx    tsktab  42B9 BF   0111               stx    utask  42BC D6   F9                 ldb    NUM_TSK   # tasks in system  42BE 34   04                 pshs   bTask       Structure                 08:51:55  Feb 29, 2020   Page   29Table      Initialization                             42C0 10BE 0282               ldy    tsktab    task 1  42C4 31   A9 0080            leay   TSKSIZ,y  42C8               10                                            42C8 86   04       11        lda    #TFREE    mark all tasks free  42CA BC   0282               cmpx   tsktab    is this the system task?  42CD 26   02                 bne    15f  42CF 86   05                 lda    #TSYS     the system task is never free  42D1 A7   04       15        sta    tsstat,x  42D3 86   FF                 lda    #$FF      not associated with a terminal  42D5 A7   08                 sta    tsdev,x  42D7 33   89 0080            leau   TSKSIZ,x  initialize stack  42DB CC   4404               ldd    #IO_han  42DE 34   20                 pshs   y  42E0 AC   E1                 cmpx   ,s++      task 1?  42E2 26   03                 bne    20f       no - normal I/O handling task  42E4 CC   455F               ldd    #TI_HAN   yes - special terminal interrupt handling task  42E7 36   06       20        pshu   d  42E9 EF   0E                 stu    usp,x  42EB EF   88 10              stu    umark0,x  42EE 30   89 0080            leax   TSKSIZ,x  42F2 6A   E4                 dec    0,s       done?  42F4 26   D2                 bne    10b  42F6 32   61                 leas   1,s       clean up stack  42F8 CC   0000               ldd    #0        nothing running or sleeping  42FB FD   010B               std    runlst  42FE FD   010D               std    slplst  4301 FD   010F               std    slplst+tsslnk  4304 30   A4                 leax   0,y       start interrupt handling task  4306 BD   46AE               jsr    makrdy  4309 39                      rts                     Task       Structure                 08:51:55  Feb 29, 2020   Page   30IOP        Configuration                                                                      *                     * define which type of boards are present                     *               430A  mod_tbl   equ    *  430A 4EAE 4310               fdb    DEV_6850,SR4_name  430E 0000                    fdb    0                     *  4310 43 50 55 30   SR4_name  fcc    'CPU09SR4',0Task       Structure                 08:51:55  Feb 29, 2020   Page   31FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     *  4319               fio_reset  4319 8E   0000               ldx    #iop_cpu  clear control structure                     *  431C 6F   80       00        clr    ,x+  431E 8C   0010               cmpx   #fifo  4321 26   F9                 bne    00b                     *  4323 8E   0000               ldx    #0  4326 9F   09                 stx    fifo_get  set Q pointers  4328 9F   0B                 stx    fifo_put                     *#        lda     #$99       tell CPU I'm ready                     *#        sta     iop_cpuF  432A CE   0400               ldu    #1024     -- Reset Time-Out value                     *  432D C6   FF       fio_wait  ldb    #255      Spin counter                     *  432F               00  432F 0D   FE                 tst    iop_cpuF  4331 27   16                 beq    10f                     *  4333 5A                      decb  4334 26   F9                 bne    00b       jump back if not ready                     *  4336 33   5F                 leau   -1,u  4338 1183 0000               cmpu   #0  433C 26   EF                 bne    fio_wait  433E 8E   403D               ldx    #CPU_down  4341 17   0D21               lbsr   DB_pdata  4344 17   0D18               lbsr   DB_main  4347 20   D0                 bra    fio_reset  4349 39            10        rts                                          *                     * fio_msg - Send a message via the FIO Mailbox                     *   B - Message code to send (one byte)                     *   iop_cpu1..3 already set up                     *                                          ***+++                     ***---                                            434A 34   14       fio_msg   pshs   b,x       save register  434C D7   00                 stb    iop_cpu   set up mailbox value                                          ***+++                     ***---                     Task       Structure                 08:51:55  Feb 29, 2020   Page   32FIO        Simulation Routines                        434E 86   FF       5         lda    #$FF      tell CPU mailbox full  4350 97   FE                 sta    iop_cpuF  4352 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  4355 96   FE       10        lda    iop_cpuF  wait till value consumed  4357 27   14                 beq    20f       jump if consumed                     *  4359 30   1F                 leax   -1,x      time-out yet?  435B 26   F8                 bne    10b                     *  435D 8E   436F               ldx    #00f  4360 BD   5065               jsr    DB_pdata  4363 A6   E4                 lda    0,s  4365 BD   506B               jsr    DB_phex  4368 17   0CF4               lbsr   DB_main  436B 20   E5                 bra    05b       try again                     *  436D 35   94       20        puls   b,x,pc                     *  436F 0D 46 49 4F   00        fcc    $d,'FIO Time-out, Value = $',0                                          *                     * fio_response - Return a response code/sequence #                     *    B - Response code                     *    A - Transaction specific value                     *  4388 34   16       fio_response pshs d,x  438A 8D   12                 bsr    FIO_get   access FIO  438C BE   0111               ldx    utask  438F A6   0B                 lda    tsseq,x  4391 97   01                 sta    iop_cpu1  4393 A6   E4                 lda    0,s       get transaction specific value  4395 97   02                 sta    iop_cpu2 >4397 BD   434A               jsr    fio_msg  439A 8D   17                 bsr    FIO_rel   release FIO  439C 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *  439E 34   76       FIO_get   pshs   d,x,y,u   save registers  43A0 108E 0130     10        ldy    #FIO_lock is the device locked  43A4 6D   A4                 tst    0,y  43A6 27   07                 beq    20f       no - go get it                     *  43A8 C6   CE                 ldb    #FIOPRI   waiting for the FIO  43AA BD   46E8               jsr    sleep  43AD 20   F1                 bra    10b       try again                     *  43AF 6C   A4       20        inc    0,y       mark in use  43B1 35   F6                 puls   d,x,y,u,pc returnTask       Structure                 08:51:56  Feb 29, 2020   Page   33FIO        Simulation Routines                                                                *                     * FIO_rel - Release access to FIO                     *  43B3 34   76       FIO_rel   pshs   d,x,y,u  43B5 108E 0130               ldy    #FIO_lock  43B9 6F   A4                 clr    0,y  43BB BD   46C4               jsr    wakeup  43BE 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  43C0 34   04       FIFOgeta  pshs   b  43C2 8D   05                 bsr    FIFO_get  43C4 35   02                 puls   a  43C6 1E   89                 exg    a,b  43C8 39                      rts                     *  43C9 34   10       FIFO_get  pshs   x  43CB D6   08                 ldb    fifo_cnt  any data?  43CD 27   14                 beq    99f       no - exit                     *  43CF 5A                      decb             yes        - adjust count  43D0 D7   08                 stb    fifo_cnt  43D2 9E   09                 ldx    fifo_get  get consumer pointer  43D4 E6   88 10              ldb    fifo,x    fetch byte  43D7 30   01                 leax   1,x       bump pointer  43D9 8C   0080               cmpx   #FIFO_SIZE end of fifo?  43DC 26   03                 bne    10f                     *  43DE 8E   0000               ldx    #0        reset pointer                     *  43E1 9F   09       10        stx    fifo_get                     *  43E3 35   90       99        puls   x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  43E5 34   04       FIFOputa  pshs   b  43E7 1F   89                 tfr    a,b  43E9 8D   02                 bsr    FIFO_put  43EB 35   84                 puls   b,pc                     *  43ED 34   10       FIFO_put  pshs   x  43EF 9E   0B                 ldx    fifo_put  get consumer pointer  43F1 E7   88 10              stb    fifo,x    store byte  43F4 30   01                 leax   1,x       bump pointer  43F6 8C   0080               cmpx   #FIFO_SIZE end of FIFO?Task       Structure                 08:51:56  Feb 29, 2020   Page   34FIO        Simulation Routines                        43F9 26   03                 bne    10f                     *  43FB 8E   0000               ldx    #0        reset pointer  43FE 9F   0B       10        stx    fifo_put                     *  4400 0C   08                 inc    fifo_cnt  update count  4402 35   90       99        puls   x,pcTask       Structure                 08:51:56  Feb 29, 2020   Page   35IO         Command Handler                                                                    *                     * IO_han - I/O Command Handler                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *                                          ***+++                     ***---                                            4404               IO_han    clri   allow     interrupts  4406 BE   0111               ldx    utask     get task control block address  4409 A6   0A                 lda    tscmd,x   get I/O command                                          ***+++                     ***---                       440B 44            10        lsra             isolate    command  440C 44                      lsra  440D 44                      lsra  440E 44                      lsra  440F E6   08                 ldb    tsdev,x   get device #  4411 C1   05                 cmpb   #MAX_DEV  check for legal device #  4413 25   04                 blo    10f       jump if OK                     *  4415 C6   84                 ldb    #E_BADDEV return illegal device error  4417 20   23                 bra    20f       exit                     *  4419 48            10        lsla             --   word index on command  441A 8E   028A               ldx    #dev_tab  441D 34   06                 pshs   d  441F 86   08                 lda    #DEV_SIZE  4421 3D                      mul  4422 30   8B                 leax   d,x  4424 AE   02                 ldx    dev_type,x get handler table address  4426 35   06                 puls   d  4428 10AE 86                 ldy    a,x       get processor address  442B 4F                      clra                     *  442C 8E   443F     10        ldx    #IO_end   interrupt handler address  442F 34   10                 pshs   x  4431 BE   0111               ldx    utask  4434 10EF 88 12              sts    umark1,x                     * X=utask, Y=handler address, U=  4438 AD   A4                 jsr    0,y       perform operation & return status  443A 32   62                 leas   2,s       clean up stack                     *Task       Structure                 08:51:56  Feb 29, 2020   Page   36IO         Command Handler                            443C BD   4388     20        jsr    fio_response                     *  443F               IO_end    seti   mask      interrupts  4441 BE   0111               ldx    utask     restore task control block address  4444 A7   0D                 sta    tstval,x  remember transaction value sent  4446 E7   0A                 stb    tscmd,x   and command response  4448 86   04                 lda    #TFREE    mark task "terminated & free"  444A A7   04                 sta    tsstat,x  444C 86   FF                 lda    #$FF      disassociate from any terminal  444E A7   08                 sta    tsdev,x  4450 6F   09                 clr    tssgnl,x  no waiting signals  4452 BD   4608               jsr    rsched    run other tasks >4455 16   FFAC               lbra   IO_han                                          *                     * Illegal command                     *  4458               bad_cmd  4458 C6   81                 ldb    #E_BADCMD error code  445A 39                      rtsTask       Structure                 08:51:56  Feb 29, 2020   Page   37Device     Table for Illegal Device                                        445B               DEV_BAD     445B 447B                    fdb    bad_dev   0  445D 447B                    fdb    bad_dev   1  445F 447B                    fdb    bad_dev   2  4461 447B                    fdb    bad_dev   3  4463 447B                    fdb    bad_dev   4  4465 447B                    fdb    bad_dev   5  4467 447B                    fdb    bad_dev   6  4469 447B                    fdb    bad_dev   7  446B 447B                    fdb    bad_dev   8  446D 447B                    fdb    bad_dev   9  446F 447B                    fdb    bad_dev   A  4471 447B                    fdb    bad_dev   B  4473 447B                    fdb    bad_dev   C  4475 447B                    fdb    bad_dev   D  4477 447B                    fdb    bad_dev   E  4479 447B                    fdb    bad_dev   F                                          *  447B C6   84       bad_dev   ldb    #E_BADDEV  447D 39                      rtsTask       Structure                 08:51:56  Feb 29, 2020   Page   38Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                                          ***+++                     ***---                                          *  447E               IRQ_han                     *-- Check for clock interrupt                     *          lda     #%10000000 get clock mask                     *          bita    CLOCK      check clock int                     *          beq     00f        no - try something else                     *                     *          sta     CLOCKI     reset interrupt                     *          jsr     clkint     go process interrupt                     *          lbra    99f        exit                     *  447E CE   028A     00        ldu    #dev_tab  scan devices  4481 CC   0000               ldd    #0        start with device 0                     *  4484 AE   C4       10        ldx    dev_addr,u get device address  4486 27   0A                 beq    20f       jump if none there                     *  4488 10AE 42                 ldy    dev_type,u get device type                                          ***+++                     ***---                       448B AD   B8 20    15        jsr    [D_inthan,y] call interrupt poller/handler  448E 1025 008E               lbcs   99f       exit if interrupt serviced                     *  4492 C3   0001     20        addd   #1        next device  4495 33   48                 leau   DEV_SIZE,u  4497 1083 0005               cmpd   #MAX_DEV  any more devices?  449B 25   E7                 blo    10b                     * Check for FIO Mailbox interrupt  449D 96   FF                 lda    cpu_iopF  see if mailbox interrupt  449F 27   77                 beq    50f       no - move on                                          ***+++  44A1 BD   45BA               jsr    H_cpu     record transaction in history Queue                     ***---                                          ***+++                     ***---                       44A4 BE   0135     25        ldx    int_ptr   input message pointer  44A7 96   04                 lda    cpu_iop   move message  44A9 A7   80                 sta    ,x+  44AB 96   05                 lda    cpu_iop1Task       Structure                 08:51:57  Feb 29, 2020   Page   39Interrupt  Processing                                 44AD A7   80                 sta    ,x+  44AF 96   06                 lda    cpu_iop2  44B1 A7   80                 sta    ,x+  44B3 96   07                 lda    cpu_iop3  44B5 A7   80                 sta    ,x+                     *#          tst     irq_gen    reset interrupt  44B7 0F   FF                 clr    cpu_iopF  indicate message consumed  44B9 BF   0135               stx    int_ptr   update pointer  44BC 108E 0131               ldy    #int_buf  get message from buffer  44C0 A6   A4                 lda    0,y       -- Send interrupt command?  44C2 81   A0                 cmpa   #O_INTRPT  44C4 26   0F                 bne    30f                     *  44C6 10BF 0135               sty    int_ptr   reset pointer  44CA E6   23                 ldb    3,y       get terminal #  44CC D1   FB                 cmpb   NUM_TRM   is this a TTY device?  44CE 24   50                 bhs    99f       no - ignore message                     *  44D0 BD   4E93               jsr    send_int  44D3 20   4B                 bra    99f       exit                     *  44D5 BE   0282     30        ldx    tsktab    search for an available task  44D8 D6   F9                 ldb    NUM_TSK   Number of tasks in system                     *  44DA A6   04       32        lda    tsstat,x  44DC 81   04                 cmpa   #TFREE    looking for a "free" task  44DE 27   1B                 beq    40f                     *  44E0 30   89 0080            leax   TSKSIZ,x  44E4 5A                      decb  44E5 26   F3                 bne    32b                     *  44E7 34   16                 pshs   d,x  44E9 8E   452C               ldx    #00f  44EC BD   5065               jsr    DB_pdata  44EF BD   505F               jsr    DB_main  44F2 35   16                 puls   d,x  44F4 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated!  44F6 BD   434A               jsr    fio_msg  44F9 20   25                 bra    99f       exit                     *  44FB 108E 0131     40        ldy    #int_buf  get message from buffer  44FF 10BF 0135               sty    int_ptr   reset pointer  4503 E6   A0                 ldb    ,y+       command byte  4505 E7   0A                 stb    tscmd,x   save for task  4507 A6   A0                 lda    ,y+       sequence #  4509 A7   0B                 sta    tsseq,x  450B E6   A0                 ldb    ,y+       command specific data  450D E7   0D                 stb    tstval,x  450F A6   A0                 lda    ,y+       associate with terminal  4511 A7   08                 sta    tsdev,x                     ** -- Removed 2/21/85Task       Structure                 08:51:57  Feb 29, 2020   Page   40Interrupt  Processing                                                    ** lda #RUNPRI make highest possible priority                     ** sta tsprir,x  4513 BD   46AE               jsr    makrdy    make task ready to run                     ** ldx utask don't switch if this was the system running                     ** cmpx tsktab                     ** beq 99f                     ** jsr change -- whatever I was doing can wait...  4516 20   08                 bra    99f       exit                     *  4518 17   0B62     50        lbsr   DB_check  enter debugger?  451B 24   03                 bcc    99f                     *  451D 17   0B3F               lbsr   DB_main                     *  4520 3B            99        rti              return     from interrupt                     *  4521 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  452C 2D 2D 20 4E   00        fcc    '-- No tasks!',0Task       Structure                 08:51:57  Feb 29, 2020   Page   41Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   A - Device #                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  4539 34   36       int_all   pshs   d,x,y  453B D6   F9                 ldb    NUM_TSK  453D C0   02                 subb   #2  453F BE   0282               ldx    tsktab  4542 30   89 0100            leax   2*TSKSIZ,x                     *  4546 A1   08       10        cmpa   tsdev,x   is this guy associated with the device?  4548 26   0C                 bne    20f                     *  454A BC   0111               cmpx   utask     make sure I don't get blown away  454D 27   07                 beq    20f                     *  454F 34   16                 pshs   d,x  4551 BD   471D               jsr    xmtint    interrupt task  4554 35   16                 puls   d,x                     *  4556 30   89 0080  20        leax   TSKSIZ,x  next task  455A 5A                      decb             any        more tasks?  455B 26   E9                 bne    10b                     *  455D 35   B6                 puls   d,x,y,pc  returnTask       Structure                 08:51:57  Feb 29, 2020   Page   42Terminal   Interrupt Handling Task                                                            *                     * TI_HAN Terminal interrupt handler                     *  455F 108E 011A     TI_HAN    ldy    #TI_Q     Terminal Interrupt Queue  4563                         seti  4565 FE   012E               ldu    TI_Q_ptr  get current Q ptr  4568 1183 011A               cmpu   #TI_Q     anything in Q?  456C 26   07                 bne    20f       yes - go process it                     *  456E C6   D8                 ldb    #TIQPRI   wait for something to do  4570 BD   46E8               jsr    sleep  4573 20   EA                 bra    TI_HAN                     *  4575 E6   C2       20        ldb    ,-u       B = Interrupt #  4577 A6   C2                 lda    ,-u       A = Device #  4579 FF   012E               stu    TI_Q_ptr  update pointer  457C 34   06                 pshs   d         save registers  457E E6   E4                 ldb    0,s       set up to flush all input for this terminal  4580 BD   488E               jsr    ttftab  4583 BD   4C77               jsr    flushi  4586                         clri   allow     interrupts  4588 BD   439E               jsr    FIO_get   get access to FIO  458B E6   E0                 ldb    ,s+       terminal #  458D D7   01                 stb    iop_cpu1  458F E6   E0                 ldb    ,s+       interrupt #  4591 D7   02                 stb    iop_cpu2  4593 C6   0A                 ldb    #R_INTRPT  4595 BD   434A               jsr    fio_msg   send interrupt message  4598 BD   43B3               jsr    FIO_rel   release access to FIO  459B 20   C2                 bra    TI_HAN    process more if needed                                          *                     * Send_TI - Send a terminal interrupt                     *   B = Interrupt #                     *   X = TTY Table                     *   jsr send_TI                     *  459D 34   76       send_TI   pshs   d,x,y,u   save registers  459F FE   012E               ldu    TI_Q_ptr  get Q head  45A2 1183 012E               cmpu   #TI_Q_ptr check for overflow  45A6 24   09                 bhs    90f       exit if so - sorry                     *  45A8 A6   0A                 lda    tdevic,x  get terminal #  45AA A7   C0                 sta    ,u+       place value in Queue  45AC E7   C0                 stb    ,u+  45AE FF   012E               stu    TI_Q_ptr  update pointer                     *  45B1 108E 011A     90        ldy    #TI_Q     wake up Queue server  45B5 BD   46C4               jsr    wakeup  45B8 35   F6                 puls   d,x,y,u,pc return                     Task       Structure                 08:51:58  Feb 29, 2020   Page   43Terminal   Interrupt Handling Task                  Task       Structure                 08:51:58  Feb 29, 2020   Page   44History    Entry Procedures                                                                   *                     * H_cpu - Place a transaction from the CPU into                     *         the history Queue.                     *  45BA 34   16       H_cpu     pshs   d,x  45BC BE   0278               ldx    hstptr    get history queue pointer  45BF 96   04                 lda    cpu_iop  45C1 A7   84                 sta    hst_cmd,x  45C3 96   05                 lda    cpu_iop1  45C5 A7   01                 sta    hst_seq,x  45C7 96   07                 lda    cpu_iop3  45C9 A7   02                 sta    hst_tty,x  45CB 96   06                 lda    cpu_iop2  45CD A7   03                 sta    hst_val,x  45CF 30   04                 leax   HRECSIZ,x  45D1 8C   0278               cmpx   #hstptr   end of Queue?  45D4 25   03                 blo    10f  45D6 8E   0238               ldx    #hstbuf  45D9 BF   0278     10        stx    hstptr  45DC 35   96                 puls   d,x,pc                                          *                     * H_iop - Place a transaction from the IOP into                     *         the history Queue.                     *  45DE 34   16       H_iop     pshs   d,x  45E0 BE   0278               ldx    hstptr    get history queue pointer  45E3 96   00                 lda    iop_cpu  45E5 A7   84                 sta    hst_cmd,x  45E7 96   01                 lda    iop_cpu1  45E9 A7   01                 sta    hst_seq,x  45EB 96   03                 lda    iop_cpu3  45ED A7   02                 sta    hst_tty,x  45EF 96   02                 lda    iop_cpu2  45F1 A7   03                 sta    hst_val,x  45F3 30   04                 leax   HRECSIZ,x  45F5 8C   0278               cmpx   #hstptr   end of Queue?  45F8 25   03                 blo    10f  45FA 8E   0238               ldx    #hstbuf  45FD BF   0278     10        stx    hstptr  4600 35   96                 puls   d,x,pc                     Task       Structure                 08:51:58  Feb 29, 2020   Page   45Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       4602 BE   0111     change    ldx    utask     point to task table entry >4605 17   006D               lbsr   putrun    put on ready list                     *  4608               rsched    seti   mask      interrupts  460A BE   0111               ldx    utask     point to current task  460D 10EF 88 10              sts    umark0,x  save stack pointers  4611 BE   0282               ldx    tsktab    point to task table  4614 8D   23                 bsr    swtchu    switch users  4616 7F   0119               clr    idle      reset idle/running flag                     *  4619 7F   0114     rsche2    clr    chproc    reset change flag >461C 17   0025               lbsr   getjob    get a new task  461F 26   0C                 bne    rsche3    find one?                                          ***+++                     ***---                       4621 86   7F       05        lda    #127      set higheset priority  4623 B7   0113               sta    jobpri    set as current  4626                         clri   clear     interrupts                     * idle work could go on here  4628 12                      nop  4629                         seti  462B 20   EC                 bra    rsche2    loop til find a ready one                     *  462D F7   0113     rsche3    stb    jobpri    set new priority  4630 8D   07                 bsr    swtchu    switch users top page  4632 BE   0111               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  4635 CC   0001               ldd    #1        return 1 to new task  4638 39                      rts              return    Task       Structure                 08:51:59  Feb 29, 2020   Page   46Scheduler  routines                                                                           *                     * Switch users                     *   X - Task entry for new task                     *  4639 35   20       swtchu    puls   y         get return address  463B BF   0111               stx    utask     set up new running task  463E 10EE 88 10              lds    umark0,x  reset stack                                          ***+++                     ***---                       4642 6E   A4                 jmp    0,y       return to caller                                          ***+++                     ***---                                                                                    ***+++                     ***---                                          Task       Structure                 08:51:59  Feb 29, 2020   Page   47Scheduler  routines                                                                           *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       4644 5F            getjob    clrb             clear      flag  4645 BE   010B               ldx    runlst    point to head of list  4648 27   1F                 beq    getjo6    empty list?                     *  464A A6   04       getjo1    lda    tsstat,x  get status byte  464C 81   01                 cmpa   #TRUN     is it in run state?  464E 26   1B                 bne    getjo8                     *  4650 5D                      tstb             first      in list?  4651 27   06                 beq    getjo2                     *  4653 EC   84                 ldd    tslink,x  remove from list  4655 ED   A4                 std    tslink,y  4657 20   07                 bra    getjo4                     *  4659 10AE 84       getjo2    ldy    tslink,x  remove from list head  465C 10BF 010B               sty    runlst    set new head                     *  4660 E6   05       getjo4    ldb    tsprir,x  get priority  4662 6F   84                 clr    tslink,x  zero out link  4664 6F   01                 clr    tslink+1,x so not run list  4666 86   FF                 lda    #$ff      set ne status  4668 39                      rts              return                         *  4669 4F            getjo6    clra             set        eq status  466A 39                      rts                     *  466B 1F   12       getjo8    tfr    x,y       save old pos  466D AE   84                 ldx    tslink,x  follow link  466F 27   F8                 beq    getjo6                     *  4671 C6   01                 ldb    #1        set flag  4673 20   D5                 bra    getjo1    repeat loop                     Task       Structure                 08:51:59  Feb 29, 2020   Page   48Scheduler  routines                                                                           *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       4675 34   01       putrun    pshs   cc        save status  4677                         seti   mask      interrupts  4679 10BE 010B               ldy    runlst    point to head  467D 26   0A                 bne    putru2  467F BF   010B               stx    runlst    set new head                     *  4682 CC   0000     putru1    ldd    #0        set last link  4685 ED   84                 std    tslink,x  4687 35   81                 puls   cc,pc     return                     *  4689 E6   05       putru2    ldb    tsprir,x  get priority  468B E1   25                 cmpb   tsprir,y  look for correct prior slot  468D 2F   08                 ble    putru4                     *  468F FC   010B               ldd    runlst  4692 BF   010B               stx    runlst    set new head  4695 20   0F                 bra    putru5    link in rest                     *  4697 1F   23       putru4    tfr    y,u       save last look  4699 10AE A4                 ldy    tslink,y  follow link  469C 27   0C                 beq    putru6                     *  469E E1   25                 cmpb   tsprir,y  check priority  46A0 2F   F5                 ble    putru4                     *  46A2 EC   C4                 ldd    tslink,u  link into list here  46A4 AF   C4                 stx    tslink,u                     *  46A6 ED   84       putru5    std    tslink,x  46A8 35   81                 puls   cc,pc     return                     *  46AA AF   C4       putru6    stx    tslink,u  46AC 20   D4                 bra    putru1    go zero last link                     Task       Structure                 08:52:01  Feb 29, 2020   Page   49Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       46AE 86   01       makrdy    lda    #TRUN     set status  46B0 A7   04                 sta    tsstat,x  46B2 CC   0000               ldd    #0        clear events flag  46B5 ED   06                 std    tsevnt,x  46B7 8D   BC                 bsr    putrun    put on ready list  46B9 E6   05                 ldb    tsprir,x  get priority  46BB F1   0113               cmpb   jobpri    higher than current?  46BE 2F   03                 ble    makrd6                     *  46C0 7C   0114               inc    chproc    set change flag                     *  46C3 39            makrd6    rts              return    Task       Structure                 08:52:14  Feb 29, 2020   Page   50Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       46C4 34   57       wakeup    pshs   cc,d,x,u  save registers  46C6                         seti   mask      interupts  46C8 CE   010D               ldu    #slplst  46CB AE   42                 ldx    tsslnk,u  point to sleep list  46CD 27   0B                 beq    wakeu4                     *  46CF 10AC 06       wakeu2    cmpy   tsevnt,x  check event  46D2 27   08                 beq    wakeu5  46D4 33   84                 leau   0,x       mark this entry                     *  46D6 AE   02       wakeu3    ldx    tsslnk,x  follow chain  46D8 26   F5                 bne    wakeu2    end of list?                     *  46DA 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  46DC 34   70       wakeu5    pshs   x,y,u     save registers  46DE EC   02                 ldd    tsslnk,x  remove from list  46E0 ED   42                 std    tsslnk,u  46E2 8D   CA                 bsr    makrdy    put on ready list  46E4 35   70                 puls   u,x,y  46E6 20   EE                 bra    wakeu3    repeat                     Task       Structure                 08:52:31  Feb 29, 2020   Page   51Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *                                          ***+++                     ***---                       46E8 34   51       sleep     pshs   cc,x,u    save registers  46EA BE   0111               ldx    utask     point to task                                          ***+++                     ***---                       46ED 6D   09                 tst    tssgnl,x  any signals waiting?  46EF 26   1F                 bne    sleep7                     *  46F1                         seti   mask      ints  46F3 E7   05                 stb    tsprir,x  set priority  46F5 10AF 06                 sty    tsevnt,x  set event  46F8 86   02                 lda    #TSLEEP   set status  46FA A7   04                 sta    tsstat,x  46FC FC   010F               ldd    slplst+tsslnk get head of list  46FF ED   02                 std    tsslnk,x  set new link  4701 BF   010F               stx    slplst+tsslnk set new head  4704 17   FF01               lbsr   rsched    reschedule cpu                                          ***+++                     ***---                       4707 BE   0111     20        ldx    utask     get task entry  470A 6D   09                 tst    tssgnl,x  any signals waiting?  470C 26   02                 bne    sleep7                     *  470E 35   D1                 puls   cc,x,u,pc return                     *  4710 BE   0111     sleep7    ldx    utask     reset signal  4713 6F   09                 clr    tssgnl,x  4715 EC   88 12              ldd    umark1,x  stack reset point  4718 35   51                 puls   cc,x,u    reset cc and registers  471A 1F   04                 tfr    d,s       change stacks  471C 39                      rts              return    Task       Structure                 08:52:35  Feb 29, 2020   Page   52Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  jsr xmtint                     *  471D 34   76       xmtint    pshs   d,x,y,u   save registers  471F A6   04                 lda    tsstat,x  get task state  4721 81   01                 cmpa   #TRUN     running?  4723 26   06                 bne    10f       no - try something else                     *  4725 86   01                 lda    #1        set signal  4727 A7   09                 sta    tssgnl,x  4729 20   0E                 bra    99f       exit                     *  472B 81   02       10        cmpa   #TSLEEP   task sleeping?  472D 26   0A                 bne    99f       no - can't send interrupt                     *  472F 86   01                 lda    #1        set signal  4731 A7   09                 sta    tssgnl,x  4733 10AE 06                 ldy    tsevnt,x  wake task up >4736 17   FF8B               lbsr   wakeup                     *  4739 35   F6       99        puls   d,x,y,u,pc returnTask       Structure                 08:52:35  Feb 29, 2020   Page   53Clist      - Get & Put Char Code                                                              *                     * getc                     *                     * Get a character from a specified character q.                     * The q is pointed to by y upon entry.  The char                     * is returned in b.                     *                       473B 34   15       getc      pshs   x,b,cc    save x  473D                         seti  473F AE   21                 ldx    clfst,y   get first pointer  4741 27   3A                 beq    getc4  4743 E6   80                 ldb    0,x+      get character  4745 E7   61                 stb    1,s  4747 AF   21                 stx    clfst,y   save new ptr  4749 6A   A4                 dec    clcnt,y   dec the count  474B 26   09                 bne    getc1  474D CC   0000               ldd    #0        zero pointers  4750 ED   21                 std    clfst,y  4752 ED   23                 std    cllst,y  4754 20   0E                 bra    getc2  4756 1F   10       getc1     tfr    x,d  4758 C5   1F                 bitb   #CBSIZE-1 check pointer  475A 26   1C                 bne    getc3  475C EC   88 E0              ldd    -CBSIZE,x  475F C3   0002               addd   #2  4762 ED   21                 std    clfst,y   set new first  4764 1F   10       getc2     tfr    x,d  4766 83   0001               subd   #1  4769 C4   E0                 andb   #!(CBSIZE-1) check pointer  476B 1F   01                 tfr    d,x       reset  476D FC   0115               ldd    cfreel    get free block  4770 ED   84                 std    0,x       set link  4772 BF   0115               stx    cfreel  4775 7A   0117               dec    cbufct    dec the buffer count  4778 35   01       getc3     puls   cc  477A 4F                      clra  477B 35   94                 puls   b,x,pc  477D 35   01       getc4     puls   cc  477F 86   FF                 lda    #$ff      set -1  4781 35   94                 puls   b,x,pc                     Task       Structure                 08:52:35  Feb 29, 2020   Page   54Clist      - Get & Put Char Code                                                              *                     * putc                     *                     * Put a character on the specified q.  The q is                     * pointed to by y upon entry and the character                     * should be in b.                     *                       4783 34   15       putc      pshs   x,b,cc  4785                         seti  4787 AE   23                 ldx    cllst,y   get tail pointer  4789 26   16                 bne    putc1  478B BE   0115               ldx    cfreel    get free list  478E 27   43                 beq    putc4  4790 EC   84                 ldd    0,x       pickup pointer  4792 FD   0115               std    cfreel  4795 7C   0117               inc    cbufct    update buffer count  4798 CC   0000               ldd    #0        zero fwd link  479B ED   81                 std    0,x++  479D AF   21                 stx    clfst,y   set first  479F 20   23                 bra    putc2  47A1 1F   10       putc1     tfr    x,d       mask pointer  47A3 C5   1F                 bitb   #CBSIZE-1  47A5 26   1D                 bne    putc2  47A7 34   20                 pshs   y  47A9 10BE 0115               ldy    cfreel    get free list  47AD 27   22                 beq    putc3  47AF EC   A4                 ldd    0,y       get pointer  47B1 FD   0115               std    cfreel    save new head  47B4 7C   0117               inc    cbufct    update buffer count  47B7 10AF 88 E0              sty    -CBSIZE,x  47BB 1F   21                 tfr    y,x  47BD 35   20                 puls   y  47BF CC   0000               ldd    #0        clear fwd link  47C2 ED   81                 std    0,x++  47C4 E6   61       putc2     ldb    1,s       get character  47C6 E7   80                 stb    0,x+      put in q  47C8 AF   23                 stx    cllst,y   save last ptr  47CA 6C   A4                 inc    clcnt,y   update character count  47CC 35   01                 puls   cc  47CE 4F                      clra  47CF 35   94                 puls   b,x,pc    return  47D1 35   20       putc3     puls   y  47D3 35   01       putc4     puls   cc  47D5 86   FF                 lda    #$ff      set error  47D7 35   94                 puls   b,x,pc                     Task       Structure                 08:52:36  Feb 29, 2020   Page   55Output     Q Handling                                                                         *                     * get_oq                     *                     * Fetch the next character from the output Q                     *   Y - Output Queue Header                     *   jsr get_oq                     *   B - Character                     *   <EQ> if Queue was not empty                     *  47D9 34   13       get_oq    pshs   cc,a,x    save registers  47DB                         seti   no        interrupts allowed!  47DD EC   A4                 ldd    oq_count,y  47DF 27   16                 beq    20f       Queue empty  47E1 83   0001               subd   #1  47E4 ED   A4                 std    oq_count,y update counter  47E6 AE   26                 ldx    oq_get,y  source pointer  47E8 E6   80                 ldb    ,x+       get data  47EA AC   28                 cmpx   oq_end,y  buffer overflow?  47EC 25   02                 blo    10f       no - continue  47EE AE   22                 ldx    oq_buf,y  yes - reset pointer  47F0 AF   26       10        stx    oq_get,y  update pointer  47F2 35   01                 puls   cc  47F4 4F                      clra             Queue not empty  47F5 35   92                 puls   a,x,pc    return  47F7 35   01       20        puls   cc  47F9 86   FF                 lda    #$FF      Queue empty  47FB 35   92                 puls   a,x,pc                     Task       Structure                 08:52:36  Feb 29, 2020   Page   56Output     Q Handling                                                                         *                     * put_oq                     *                     * Put a character into an output Q                     *    Y - Output Q header                     *    B - Character to insert                     *    jsr put_oq                     *  47FD 34   17       put_oq    pshs   cc,d,x    save registers  47FF                         seti   no        interrupts  4801 AE   24                 ldx    oq_put,y  get pointer  4803 E7   80                 stb    ,x+       put data into Q  4805 AC   28                 cmpx   oq_end,y  buffer overflow?  4807 25   02                 blo    10f       no - continue  4809 AE   22                 ldx    oq_buf,y  yes - reset pointer  480B AF   24       10        stx    oq_put,y  save new pointer  480D EC   A4                 ldd    oq_count,y update count  480F C3   0001               addd   #1  4812 ED   A4                 std    oq_count,y  4814 35   97                 puls   cc,d,x,pc returnTask       Structure                 08:52:36  Feb 29, 2020   Page   57Terminal   Drivers                                                                            *                     * The routines in this file make up the main system                     * terminal drivers.  Most of the work is actually                     * performed by other internal routines.                     *                                          *                     * ttopn                     *                     * Open a terminal for use.  On entry, D has                     * the device number.                     *                       4816 34   06       ttopn     pshs   d         save device number  4818 8D   74                 bsr    ttftab    get table address  481A A6   88 11              lda    tstate,x  get states  481D 85   04                 bita   #TOPEN    is it already open?  481F 26   02                 bne    ttopn8  4821 8D   08                 bsr    ttdopn    do actual open  4823 10AE 06       ttopn8    ldy    taddr,x   point to device  4826 AD   D8 30              jsr    [D_ttenr,u] enable rcv interrupts  4829 35   86                 puls   d,pc      return                                                               *                     * ttdopn                     *                     * Do actual terminal open.  X points to tty entry.                     *                       482B 10AE 06       ttdopn    ldy    taddr,x   get device address  482E 6F   88 13              clr    tstate3,x  4831 AD   D8 26    10        jsr    [D_ttconf,u] configure the port                     * response of NE implies open OK                                          * if EQ then blocked by CTS if Carry is 0  4834 26   18                 bne    ttdop6    is it ready?  4836 25   0B                 bcs    ttdop5    branch if blocked by DCD  4838 34   31                 pshs   cc,x,y    save regs  483A                         seti   mask      ints  483C AD   D8 4A              jsr    [D_ttwcts,u] wait for CTS  483F 35   31                 puls   cc,x,y    reset regs  4841 20   E8                 bra    ttdopn    repeat open  4843 34   31       ttdop5    pshs   cc,x,y    save regs  4845                         seti   mask      ints  4847 AD   D8 4C              jsr    [D_ttwdcd,u] wait for DCD  484A 35   31                 puls   cc,x,y    reset regs  484C 20   DD                 bra    ttdopn    repeat open  484E 86   36       ttdop6    lda    #ECHO|XTABS|CRMOD|BSECH  4850 A7   08                 sta    tflags,x  setup initial mode  4852 86   7F                 lda    #BSPCH    get backspace charTask       Structure                 08:52:36  Feb 29, 2020   Page   58Terminal   Drivers                                    4854 A7   0D                 sta    tbksp,x   save in table  4856 86   18                 lda    #CNCLC    get cancel character  4858 A7   0E                 sta    tcncl,x   save in table  485A A6   88 11              lda    tstate,x  set OPEN flag  485D 8A   04                 ora    #TOPEN    set open status  485F A7   88 11              sta    tstate,x  save in table  4862 86   01                 lda    #DSR_OK   allow transmitting  4864 A7   88 12              sta    tstate2,x  4867 39                      rts              return                     Task       Structure                 08:52:36  Feb 29, 2020   Page   59Terminal   Drivers                                                                            *                     * ttcls                     *                     * Close the terminal whode device number is in D.                     *                       4868 8D   24       ttcls     bsr    ttftab    find table entry  486A A6   88 11              lda    tstate,x  was the port actually open?  486D 85   04                 bita   #TOPEN  486F 27   0E                 beq    10f       no - skip flush  4871 84   FB                 anda   #!TOPEN   yes - clear bit  4873 A7   88 11              sta    tstate,x  ... so we don't get hung up ...  4876 17   03D3               lbsr   flusho    flush out buffers  4879 10AE 06                 ldy    taddr,x   get device address  487C AD   D8 34              jsr    [D_ttenno,u] close down the port  487F A6   88 11    10        lda    tstate,x  clear state bits  4882 84   F8                 anda   #PROTOCOL preserve protocol flags  4884 A7   88 11              sta    tstate,x  4887 6F   88 12              clr    tstate2,x  488A 6F   88 13              clr    tstate3,x  488D 39                      rts                                          *                     * ttftab                     *                     * Find tty table entry associated with device in D.                     * Exit with entry pointed at by X.                     * Also compute device handler table in U.                     *                       488E 34   06       ttftab    pshs   d  4890 BE   027C               ldx    TTYTABS   point to table  4893 86   1F                 lda    #TTYSIZ   set size up  4895 3D                      mul              calculate  offset  4896 30   8B                 leax   d,x       point to entry  4898 35   06                 puls   d  489A CE   028A               ldu    #dev_tab  489D 86   08                 lda    #DEV_SIZE  489F 3D                      mul  48A0 33   CB                 leau   d,u  48A2 EE   42                 ldu    dev_type,u get handler table address  48A4 39                      rts              return                                          Task       Structure                 08:52:37  Feb 29, 2020   Page   60Terminal   Drivers                                                                            *                     * tintr                     *                     * TTY interrupt handler.  Determine if the interrupt                     * is a receive or transmit one and take appropriate                     * actions.                     *                       48A5 8D   E7       tintr     bsr    ttftab    calculate table addresses  48A7 10AE 06                 ldy    taddr,x   get device address  48AA 34   20       01        pshs   y         save port address  48AC EC   64                 ldd    4,s       fetch device status (if present)                       48AE AD   D8 3E              jsr    [D_tttstb,u] test for break interrupt  48B1 26   3E                 bne    tintr5                       48B3 AD   D8 42              jsr    [D_tttstc,u] test drop carrier int  48B6 26   41                 bne    tintr6                       48B8 AD   D8 3C              jsr    [D_tttstr,u] test for rcv int  48BB 26   16                 bne    tintr2                       48BD AD   D8 40              jsr    [D_tttsts,u] test CTS change interrupt  48C0 26   5F                 bne    tintr9                       48C2 AD   D8 38              jsr    [D_tttstx,u] test for xmit int  48C5 26   14                 bne    tintr3                       48C7 AD   D8 44              jsr    [D_tttstd,u] test dsr change  48CA 26   3C                 bne    tintr8                       48CC AD   D8 46              jsr    [D_tttste,u] test error int  48CF 26   30                 bne    tintr7    ** should be 7? **                       48D1 20   4E                 bra    tintr9                       48D3 AD   D8 2A    tintr2    jsr    [D_ttgetc,u] get character from port  48D6 BD   4B2A               jsr    ttyin     go buffer char  48D9 20   46                 bra    tintr9                       48DB BD   4A26     tintr3    jsr    ttyst     go output another char  48DE EC   98 04              ldd    [tqout,x] check queue count  48E1 27   06                 beq    tintr4  48E3 10B3 0104               cmpd   OQLO      low water mark?  48E7 26   38                 bne    tintr9                       48E9 10AE 04       tintr4    ldy    tqout,x   get output queue  48EC BD   46C4               jsr    wakeup  48EF 20   30                 bra    tintr9                       48F1 CC   0002     tintr5    ldd    #INTS     set INT interruptTask       Structure                 08:52:37  Feb 29, 2020   Page   61Terminal   Drivers                                    48F4 BD   459D               jsr    send_TI   send interrupt  48F7 20   28                 bra    tintr9                       48F9 CC   0001     tintr6    ldd    #HANGS    set hangup unt  48FC BD   459D               jsr    send_TI   send interrupt  48FF 20   20                 bra    tintr9                       4901 C6   07       tintr7    ldb    #$07      set bell char  4903 BD   4B2A               jsr    ttyin     go buffer it  4906 20   19                 bra    tintr9    exit                       4908 A6   88 12    tintr8    lda    tstate2,x get state  490B 85   01                 bita   #DSR_OK   was it OK to send before?  490D 27   0A                 beq    85f       no - must be now  490F 84   FE                 anda   #!DSR_OK  don't allow any sending  4911 A7   88 12              sta    tstate2,x  4914 AD   D8 2E              jsr    [D_ttdisx,u] disable transmitter  4917 20   08                 bra    tintr9    exit  4919 8A   01       85        ora    #DSR_OK   allow transmitting  491B A7   88 12              sta    tstate2,x  491E BD   4A0E               jsr    ttyren    restart transmission  4921 35   20       tintr9    puls   y         restore port address  4923 6E   D8 48              jmp    [D_ttend,u] clean up the port & return                     Task       Structure                 08:52:54  Feb 29, 2020   Page   62Terminal   Drivers                                                                            *                     * ttyset/ttyget                     *                     * Handle the actual get or put of data for ttyset                     * and ttyget.                     *                       4926 17   FF65     ttyset    lbsr   ttftab    get tty table address                     * U=dev_tab#, X=tty_table#, Y=DEV_XXXX  4929 17   FA94               lbsr   FIFOgeta  move data from FIFO       (1)  492C E6   08                 ldb    tflags,x  save current flags  492E A7   08                 sta    tflags,x  set flags  4930 C5   41                 bitb   #RAW|SCHR currently in RAW or Single Character mode?  4932 26   20                 bne    10f       yes - no change  4934 85   41                 bita   #RAW|SCHR going to one of those modes?  4936 27   1C                 beq    10f       no - continue  4938 6D   94                 tst    [tqin,x]  any unsolicited input?  493A 27   06                 beq    00f       no - continue  493C 6D   0B                 tst    tdel,x    any delimiters?  493E 27   02                 beq    00f  4940 6C   0B                 inc    tdel,x    force a delimiter  4942 85   01       00        bita   #RAW      going into RAW mode?  4944 27   0E                 beq    10f       no  4946 A6   88 11              lda    tstate,x  yes - no HOLD processing in RAW mode  4949 85   02                 bita   #HOLD     currently holding?  494B 27   07                 beq    10f       no - continue  494D 84   FD                 anda   #!HOLD  494F A7   88 11              sta    tstate,x  4952 8D   00                 bsr    ttyren    kick output***  Relative branch too long  4954 17   FA69     10        lbsr   FIFOgeta  move data from FIFO       (2)  4957 A7   09                 sta    tdelay,x  set delays  4959 17   FA64               lbsr   FIFOgeta  move data from FIFO       (3)  495C A7   0E                 sta    tcncl,x   set cancel char  495E 17   FA5F               lbsr   FIFOgeta  move data from FIFO       (4)  4961 A7   0D                 sta    tbksp,x   set back space char  4963 17   FA5A               lbsr   FIFOgeta  move data from FIFO       (5)  4966 84   7F                 anda   #$7F  4968 A7   0F                 sta    tbaud,x   set bauds  496A 17   FA53               lbsr   FIFOgeta  move data from FIFO       (6)  496D 34   02                 pshs   a  496F 84   F8                 anda   #PROTOCOL save protocol bits  4971 34   02                 pshs   a  4973 A6   88 11              lda    tstate,x  update state  4976 84   07                 anda   #(!PROTOCOL)&$FF clear current bits  4978 AA   E0                 ora    ,s+       set new bits  497A A7   88 11              sta    tstate,x  497D 35   02                 puls   a  497F 84   0F                 anda   #$0F      get baud rate  4981 34   02                 pshs   a  4983 A6   88 10              lda    tbaud2,x  update baud rateTask       Structure                 08:53:16  Feb 29, 2020   Page   63Terminal   Drivers                                    4986 84   F0                 anda   #$F0  4988 AA   E0                 ora    ,s+  498A A7   88 10              sta    tbaud2,x                     *  498D A6   D8 04              lda    [dev_brbu,u]  4990 E6   46                 ldb    dev_brmk,u  4992 C1   0F                 cmpb   #$0f  4994 27   04                 beq    01f  4996 84   0F                 anda   #$0f  4998 20   00                 bra    02f***  Illegal operand  499A 84   F0       01        anda   #$f0  499C 34   02                 pshs   a  499E 17   FA28               lbsr   FIFO_geta (7)  49A1 E6   46                 ldb    dev_brmk,u  49A3 C1   0F                 cmpb   #$0f  49A5 27   04                 beq    03f  49A7 48                      lsla  49A8 48                      lsla  49A9 48                      lsla  49AA 48                      lsla  49AB AA   00 1212  03        ora    0s,+***  Illegal operand***  Illegal indexed mode  49AF A7   D8 04              sta    [dev_brbu,u]  49B2 AE   C4                 ldx    dev_addr,u  49B4 A7   02                 sta    brr,x                     *  49B6 17   FA10               lbsr   FIFO_geta (8)  49B9 C6   06                 ldb    #R_TTY    return TTYSET OK  49BB 39                      rts              return                                            49BC 17   FECF     ttyget    lbsr   ttftab    get table address                     * U=dev_tab#, X=tty_table#, Y=DEV_XXXX  49BF A6   08                 lda    tflags,x  get flags byte  49C1 17   FA21               lbsr   FIFOputa  put data into FIFO             (1)  49C4 A6   09                 lda    tdelay,x  get delays  49C6 17   FA1C               lbsr   FIFOputa  put data into FIFO             (2)  49C9 A6   0E                 lda    tcncl,x   get cancel char  49CB 17   FA17               lbsr   FIFOputa  put data into FIFO             (3)  49CE A6   0D                 lda    tbksp,x   get b.s. char  49D0 17   FA12               lbsr   FIFOputa  put data into FIFO             (4)  49D3 A6   0F                 lda    tbaud,x   get bauds  49D5 84   7F                 anda   #$7F  49D7 6D   0B                 tst    tdel,x    check delimiter count  49D9 26   05                 bne    ttys45  49DB 6D   98 02              tst    [tqproc,x] any chars in processed queue?  49DE 27   02                 beq    ttysg5  49E0 8A   80       ttys45    ora    #%10000000 set del bit  49E2 17   FA00     ttysg5    lbsr   FIFOputa  put data into FIFO             (5)  49E5 A6   88 11              lda    tstate,x  return protocol bitsTask       Structure                 08:53:16  Feb 29, 2020   Page   64Terminal   Drivers                                    49E8 84   F8                 anda   #PROTOCOL  49EA 34   02                 pshs   a  49EC A6   88 10              lda    tbaud2,x  get baud rate  49EF 84   0F                 anda   #$0F  49F1 AA   E0                 ora    ,s+  49F3 17   F9EF               lbsr   FIFOputa  put data into FIFO             (6)                     *  49F6 E6   46                 ldb    dev_brmk,u  49F8 A6   D8 04              lda    [dev_brbu,u]  49FB C1   0F                 cmpb   #$0f  49FD 27   04                 beq    01f  49FF 44                      lsra  4A00 44                      lsra  4A01 44                      lsra  4A02 44                      lsra  4A03 17   F9DF     01        lbsr   FIFOputa  (7)  4A06 86   FF                 lda    #$ff  4A08 17   F9DA               lbsr   FIFOputa  (8)  4A0B C6   06                 ldb    #R_TTY    response = TTYGET = OK  4A0D 39                      rts              returnTask       Structure                 08:53:17  Feb 29, 2020   Page   65TTY        Handlers                                                                           *                     * All code in this section is the common tty handler                     * code.  The device dependent code resides with the                     * drivers.  This handler package requires an ACIA be used                     * for all character type devices.                     *                                                               *                     * ttyren                     *                     * Re-enable the tty output after a timeout operation.                     * Upon entry, x should point to the tty structure.                     *                       4A0E               ttyren  4A0E A6   88 11              lda    tstate,x  check state  4A11 85   02                 bita   #HOLD >4A13 1026 0056               lbne   ttyst9                     *  4A17 84   FE                 anda   #!TIMOUT  clear time out  4A19 A7   88 11              sta    tstate,x  reset state  4A1C 10AE 06                 ldy    taddr,x >4A1F 1027 0036               lbeq   ttys55                     *  4A23 AD   D8 2C              jsr    [D_ttenxr,u] enable xmit interrupts                                          Task       Structure                 08:53:17  Feb 29, 2020   Page   66TTY        Handlers                                                                           *                     * ttyst                     *                     * TTY start will output a character to the terminal.                     * Upon entry, x should point to the tty structure in                     * use.  Getc is called for the character.                     *                       4A26 A6   88 12    ttyst     lda    tstate2,x is it ok to transmit?  4A29 85   01                 bita   #DSR_OK >4A2B 1027 003E               lbeq   ttyst9    no - wait until it is                     *  4A2F 10AE 06                 ldy    taddr,x   get device address  4A32 27   25                 beq    ttys55                     *  4A34 AD   D8 36              jsr    [D_ttxbsy,u] test xmit busy?  4A37 27   20                 beq    ttys55                     *  4A39 A6   88 11    ttyst1    lda    tstate,x  4A3C 85   01                 bita   #TIMOUT >4A3E 1026 002B               lbne   ttyst9                                          ***+++                     ***---                       4A42               ttyst15  4A42 10AE 04                 ldy    tqout,x   get out q  4A45 17   FD91               lbsr   get_oq    get character  4A48 26   23                 bne    ttyst9    exit if queue empty                                          ***+++                     ***---                       4A4A A6   08                 lda    tflags,x  4A4C 85   01                 bita   #RAW      test raw mode  4A4E 26   03                 bne    ttyst2                     *  4A50 5D                      tstb             char       negative?  4A51 2B   07                 bmi    ttyst6                     *  4A53 10AE 06       ttyst2    ldy    taddr,x   get device address  4A56 6E   D8 28              jmp    [D_ttputc,u] write characetr                     *  4A59 39            ttys55    rts                     *  4A5A A6   88 11    ttyst6    lda    tstate,x  4A5D 85   60                 bita   #XANY|XONXOF HOLD processing enabled?  4A5F 26   04                 bne    ttyst65   yes                     *  4A61 85   80                 bita   #ESCOFF   ESCape HOLD disabled?  4A63 26   F4                 bne    ttys55    yes - ignore HOLD characterTask       Structure                 08:53:17  Feb 29, 2020   Page   67TTY        Handlers                                                      *  4A65 A6   88 11    ttyst65   lda    tstate,x  get states  4A68 8A   03                 ora    #TIMOUT|HOLD set hold mode  4A6A A7   88 11              sta    tstate,x  reset states                     *  4A6D 10AE 06       ttyst9    ldy    taddr,x   get port  4A70 6E   D8 2E              jmp    [D_ttdisx,u] disable xmit interrupts                     Task       Structure                 08:53:17  Feb 29, 2020   Page   68TTY        Handlers                                                                           *                     * ttyout                     *                     * Put the character in b into the output q.  Upon                     * entry, x should point to the tty structure.  Tab                     * expansions, upper case mapping, and special character                     * handling are all done here.                     *                       4A73 A6   08       ttyout    lda    tflags,x  get flags  4A75 85   01                 bita   #RAW      raw mode?  4A77 27   11                 beq    ttyo12                     *  4A79 A6   88 11              lda    tstate,x  no hold in RAW mode  4A7C 84   FD                 anda   #!HOLD  4A7E A7   88 11              sta    tstate,x  4A81 10AE 04                 ldy    tqout,x   point to out q  4A84 17   FD76               lbsr   put_oq    put char in q  4A87 16   0087               lbra   ttyoue    go finish                     *  4A8A C1   FF       ttyo12    cmpb   #$ff      special hold char?  4A8C 27   53                 beq    ttyou6                     *  4A8E C4   7F                 andb   #$7f      mask parity bit  4A90 C1   09                 cmpb   #TABCH  4A92 26   11                 bne    ttyou2                     *  4A94 A6   08                 lda    tflags,x  check mode  4A96 85   04                 bita   #XTABS    expand tabs?  4A98 27   0B                 beq    ttyou2                     *  4A9A C6   20       ttyo14    ldb    #SPACE  4A9C 8D   D5                 bsr    ttyout    output it  4A9E A6   0C                 lda    tcolm,x   check column  4AA0 85   07                 bita   #7  4AA2 26   F6                 bne    ttyo14                     *  4AA4 39                      rts                     *  4AA5 A6   08       ttyou2    lda    tflags,x  check mode  4AA7 85   08                 bita   #LCASE    lower case mode?  4AA9 27   25                 beq    ttyou4                     *  4AAB C1   61                 cmpb   #'a       lower case letter?  4AAD 25   08                 blo    ttyo22                     *  4AAF C1   7A                 cmpb   #'z  4AB1 22   04                 bhi    ttyo22                     *  4AB3 C0   20                 subb   #$20      make upper  4AB5 20   19                 bra    ttyou4Task       Structure                 08:53:17  Feb 29, 2020   Page   69TTY        Handlers                                                      *  4AB7 108E 4B1F     ttyo22    ldy    #lcht     point to map                     *  4ABB E1   A1       ttyo23    cmpb   0,y++  4ABD 26   0D                 bne    ttyo24                     *  4ABF E6   3F                 ldb    -1,y      get mapped char  4AC1 34   04                 pshs   b  4AC3 C6   5C                 ldb    #'\       output escape >4AC5 17   FFAB               lbsr   ttyout  4AC8 35   04                 puls   b  4ACA 20   15                 bra    ttyou6                     *  4ACC 6D   A4       ttyo24    tst    0,y       end of list?  4ACE 26   EB                 bne    ttyo23                     *  4AD0 C1   0D       ttyou4    cmpb   #CR  4AD2 26   0D                 bne    ttyou6                     *  4AD4 A6   08                 lda    tflags,x  check mode  4AD6 85   10                 bita   #CRMOD  4AD8 27   07                 beq    ttyou6                     *  4ADA C6   0A                 ldb    #NL       convert to NL >4ADC 17   FF94               lbsr   ttyout    output it  4ADF C6   0D                 ldb    #CR       reset CR                     *  4AE1 10AE 04       ttyou6    ldy    tqout,x   point to out q  4AE4 17   FD16               lbsr   put_oq  4AE7 C1   0D                 cmpb   #CR  4AE9 22   20                 bhi    ttyou8                     *  4AEB 26   02                 bne    ttyo75    is it cr?                     *  4AED 6F   0C                 clr    tcolm,x   clear out column count!                     *  4AEF C1   09       ttyo75    cmpb   #9        is it tab character?  4AF1 26   0A                 bne    ttyo77                     *  4AF3 A6   0C                 lda    tcolm,x   get column count  4AF5 84   F8                 anda   #!7       mask low 3 bits  4AF7 8B   08                 adda   #8        add in tab  4AF9 A7   0C                 sta    tcolm,x   save new column  4AFB 20   14                 bra    ttyoue                     *  4AFD C1   08       ttyo77    cmpb   #$08      hardware backspace?  4AFF 25   10                 blo    ttyoue  4B01 26   08                 bne    ttyou8  4B03 6D   0C                 tst    tcolm,x   column zero?  4B05 27   0A                 beq    ttyoue  4B07 6A   0C                 dec    tcolm,x  4B09 20   06                 bra    ttyoueTask       Structure                 08:53:34  Feb 29, 2020   Page   70TTY        Handlers                                                      *  4B0B C1   20       ttyou8    cmpb   #SPACE    is it control char?  4B0D 25   02                 blo    ttyoue                     *  4B0F 6C   0C                 inc    tcolm,x   bump column count                     *  4B11 A6   88 11    ttyoue    lda    tstate,x  ** kludge for ACIA **  4B14 85   02                 bita   #HOLD  4B16 26   06                 bne    ttyoe1                     *  4B18 10AE 06                 ldy    taddr,x   get device address  4B1B 6E   D8 2C              jmp    [D_ttenxr,u] enable xmit interrupts                     *  4B1E 39            ttyoe1    rts              return                       4B1F 7E 5E 7C 21   lcht      fcc    "~^|!{(})`'"  4B29 00                      fcb    0Task       Structure                 08:53:37  Feb 29, 2020   Page   71TTY        Handlers                                                                           *                     * ttyin                     *                     * Place the character in b on the input q.                     * Upon entry, x should point to the tty structure.                     * Signal processing and character mapping are                     * performed in this roiutine.                     *                       4B2A               ttyin                                          ***+++                     ***---                       4B2A A6   08                 lda    tflags,x  raw mode?  4B2C 85   01                 bita   #RAW  4B2E 26   51                 bne    ttyi44                     *  4B30 C4   7F                 andb   #$7f      mask par bit                     *  4B32 C1   20       ttyin0    cmpb   #SPACE    control char?  4B34 24   4B                 bhs    ttyi44    skip junk if so                     *  4B36 C1   1C       ttyin2    cmpb   #QUITC  4B38 27   09                 beq    ttyi25                     *  4B3A C1   03                 cmpb   #INTRC  4B3C 26   0B                 bne    ttyin3                     *  4B3E CC   0002               ldd    #INTS     set signal  4B41 20   03                 bra    ttyi27                     *  4B43 CC   0003     ttyi25    ldd    #QUITS    set signal                     *  4B46 7E   459D     ttyi27    jmp    send_TI   send interrupt & get out                     *  4B49 A6   88 11    ttyin3    lda    tstate,x  get state  4B4C C1   1B                 cmpb   #HOLDC    Escape?  4B4E 26   10                 bne    ttyi34                     *  4B50 85   80                 bita   #ESCOFF   escape processing disabled?  4B52 26   27                 bne    ttyin4    yes - ignore ESC as special character                     *  4B54 85   02                 bita   #HOLD     holding??  4B56 26   1B                 bne    ttyi36                     *  4B58 8A   03       ttyi33    ora    #TIMOUT|HOLD set HOLDing  4B5A A7   88 11              sta    tstate,x  4B5D 7E   4A0E               jmp    ttyren                     *  4B60 85   40       ttyi34    bita   #XONXOF   doing XON/XOFF processing?Task       Structure                 08:53:38  Feb 29, 2020   Page   72TTY        Handlers                                   4B62 27   17                 beq    ttyin4    no - don't bother                     *  4B64 C1   13                 cmpb   #XOFFC    XOFF character?  4B66 26   07                 bne    ttyi35    no                     *  4B68 85   02                 bita   #HOLD     already stopped?  4B6A 27   EC                 beq    ttyi33    no - stop output                     *  4B6C 16   00B4               lbra   ttyin9    ignore XOFF if already stopped!                     *  4B6F C1   11       ttyi35    cmpb   #XONC     XON character  4B71 26   08                 bne    ttyin4    no - continue                     * -- HOLD off  4B73 84   FD       ttyi36    anda   #!HOLD    clear hold mode  4B75 A7   88 11              sta    tstate,x  4B78 7E   4A0E               jmp    ttyren                     *  4B7B C1   0D       ttyin4    cmpb   #CR       new line?  4B7D 26   02                 bne    ttyi44                     *  4B7F 6F   0C                 clr    tcolm,x   clear out column                     *  4B81 A6   88 11    ttyi44    lda    tstate,x  get current state  4B84 85   20                 bita   #XANY     allow any character to restart?  4B86 27   04                 beq    ttyi46    no - continue on                     *  4B88 85   02                 bita   #HOLD     currently stopped?  4B8A 26   E7                 bne    ttyi36    yes - go restart it                     *  4B8C 10AE 84       ttyi46    ldy    tqin,x    input Q pointer  4B8F A6   A4                 lda    0,y       check q count                                          ***+++                     ***---                       4B91 81   FE                 cmpa   #CHRLIM   hit limit?  4B93 1024 008D               lbhs   flusht    flush this guy!                     *  4B97 B6   0117               lda    cbufct    check buffer count  4B9A B1   0118               cmpa   lcbuf  4B9D 1022 0083               lbhi   flusht    if overflow, flush!                     *  4BA1 A6   08       49        lda    tflags,x  check mode  4BA3 85   01                 bita   #RAW      raw mode?  4BA5 27   10                 beq    ttyin5                     *  4BA7 17   FBD9               lbsr   putc      put char in q  4BAA 10AE 84                 ldy    tqin,x    get in q  4BAD 34   04                 pshs   b         save char  4BAF 17   FB12               lbsr   wakeup    awaken those waiting  4BB2 35   04                 puls   b         get character  4BB4 6C   0B                 inc    tdel,x    bump delimiter countTask       Structure                 08:53:38  Feb 29, 2020   Page   73TTY        Handlers                                   4BB6 39                      rts              return                     *  4BB7 85   08       ttyin5    bita   #LCASE  4BB9 27   0A                 beq    ttyin6                     *  4BBB C1   41                 cmpb   #'A       capital letter?  4BBD 25   06                 blo    ttyin6                     *  4BBF C1   5A                 cmpb   #'Z  4BC1 22   02                 bhi    ttyin6                     *  4BC3 CB   20                 addb   #$20      make lower case                     *  4BC5 10AE 84       ttyin6    ldy    tqin,x    point to input q  4BC8 17   FBB8               lbsr   putc  4BCB A6   08                 lda    tflags,x  check mode  4BCD 85   40                 bita   #SCHR     single char mode?  4BCF 26   0A                 bne    ttyi65                     *  4BD1 C1   0D                 cmpb   #CR  4BD3 22   12                 bhi    ttyin7                     *  4BD5 27   04                 beq    ttyi65                     *  4BD7 C1   04                 cmpb   #EOTCH  4BD9 26   0C                 bne    ttyin7                     *  4BDB 10AE 84       ttyi65    ldy    tqin,x    point to input q  4BDE 34   04                 pshs   b  4BE0 17   FAE1               lbsr   wakeup    wake up waiting  4BE3 6C   0B                 inc    tdel,x    bump count                     *  4BE5 35   04       ttyi67    puls   b         reset char                     *  4BE7 E1   0E       ttyin7    cmpb   tcncl,x   kill character?  4BE9 26   18                 bne    ttyin8                     *  4BEB A6   08                 lda    tflags,x  check mode  4BED 85   40                 bita   #SCHR     single character?  4BEF 26   12                 bne    ttyin8                     *  4BF1 C6   5E                 ldb    #'^       output '^x\n'  4BF3 17   FE7D               lbsr   ttyout  4BF6 C6   78                 ldb    #'x  4BF8 17   FE78               lbsr   ttyout  4BFB C6   0D                 ldb    #CR  4BFD 17   FE73               lbsr   ttyout  4C00 7E   4A26               jmp    ttyst                     *  4C03 A6   08       ttyin8    lda    tflags,x  check mode  4C05 85   02                 bita   #ECHO  4C07 27   1A                 beq    ttyin9Task       Structure                 08:53:48  Feb 29, 2020   Page   74TTY        Handlers                                                      *  4C09 E1   0D                 cmpb   tbksp,x   back space?  4C0B 26   10                 bne    ttyi85                     *  4C0D 85   20                 bita   #BSECH    echo bs?  4C0F 27   0C                 beq    ttyi85                     *  4C11 C6   08                 ldb    #$08      set bs  4C13 17   FE5D               lbsr   ttyout  4C16 C6   20                 ldb    #SPACE    set space  4C18 17   FE58               lbsr   ttyout  4C1B C6   08                 ldb    #$08      reset char                     *  4C1D 17   FE53     ttyi85    lbsr   ttyout    echo character  4C20 7E   4A26               jmp    ttyst     start output                     *  4C23 39            ttyin9    rts              return                     Task       Structure                 08:53:59  Feb 29, 2020   Page   75TTY        Handlers                                                                           *                     * flusht                     *                     * Flush all queues belonging to this terminal.                     *                       4C24               flusht >4C24 17   0050               lbsr   flushi    flush Input queues  4C27 10AE 04                 ldy    tqout,x   point to out q                     *  4C2A 17   FBAC     10        lbsr   get_oq    flush out q  4C2D 2A   FB                 bpl    10b                     *  4C2F 10AE 84                 ldy    tqin,x    get input q  4C32 17   FA8F               lbsr   wakeup    wakeup input q waiters  4C35 10AE 04                 ldy    tqout,x   wake up out q waiters  4C38 17   FA89               lbsr   wakeup  4C3B A6   88 11              lda    tstate,x  get states  4C3E 84   FC                 anda   #!(HOLD|TIMOUT) clear hold mode  4C40 A7   88 11              sta    tstate,x  4C43 CC   0000               ldd    #0        no pre-sold output  4C46 ED   88 15              std    tsold,x  4C49 7E   4A26               jmp    ttyst                                          *                     * flusho                     *                     * Flush all this guys queues after waiting for the                     * output q to empty.                     *                       4C4C A6   88 11    flusho    lda    tstate,x  check state  4C4F 85   02                 bita   #HOLD     holding?  4C51 27   08                 beq    fluso1                     *  4C53 84   FC       fluso0    anda   #!(HOLD|TIMOUT)  4C55 A7   88 11              sta    tstate,x  clear hold  4C58 17   FDB3               lbsr   ttyren    kick output                     *  4C5B EC   98 04    fluso1    ldd    [tqout,x] check char count >4C5E 1027 FFC2               lbeq   flusht  4C62 A6   88 11              lda    tstate,x  check for hold  4C65 85   02                 bita   #HOLD  4C67 26   EA                 bne    fluso0                                          ***+++                     ***---                       4C69 10AE 04                 ldy    tqout,x   point to out q  4C6C C6   EC                 ldb    #TTYOPR   set priority  4C6E 34   10                 pshs   x         save xTask       Structure                 08:54:25  Feb 29, 2020   Page   76TTY        Handlers                                   4C70 17   FA75               lbsr   sleep  4C73 35   10                 puls   x  4C75 20   E4                 bra    fluso1                                          *                     * flushi - Flush input Queues only                     *  4C77               flushi  4C77 10AE 02                 ldy    tqproc,x  get procd q                     *  4C7A 17   FABE     10        lbsr   getc      get character  4C7D 2A   FB                 bpl    10b                     *  4C7F 10AE 84                 ldy    tqin,x    flush input q                     *  4C82 17   FAB6     20        lbsr   getc  4C85 2A   FB                 bpl    20b                     *  4C87 6F   0B                 clr    tdel,x    clear delim count                                          ***+++                     ***---                       4C89 39                      rts                                                                                    *                     * xtprcq                     *                     * Transfer characters from input q to procd q.  If not                     * in raw mode, do escape, backspace, and cancel                     * processing.  Enter with x pointing to tty structure.                     *                       4C8A 34   01       xtprcq    pshs   cc        save cc  4C8C                         seti   mask      ints  4C8E 6D   0B                 tst    tdel,x    delimiters yet?  4C90 26   10                 bne    xtprc0                                          ***+++                     ***---                       4C92 10AE 84                 ldy    tqin,x    sleep on input q  4C95 C6   F6                 ldb    #TTYIPR  4C97 34   10                 pshs   x         save x  4C99 17   FA4C               lbsr   sleep  4C9C 35   10                 puls   x  4C9E 35   01                 puls   cc        reset cc  4CA0 20   E8                 bra    xtprcq                     *  4CA2 35   01       xtprc0    puls   cc        reset ccTask       Structure                 08:54:39  Feb 29, 2020   Page   77TTY        Handlers                                   4CA4 6D   94                 tst    [tqin,x]  input q empty?  4CA6 26   04                 bne    xtprc1                     *  4CA8 6A   0B                 dec    tdel,x    dec the del count  4CAA 20   DE                 bra    xtprcq    repeat test                     *  4CAC 108E 013A     xtprc1    ldy    #prcbuf+2 point to buffer  4CB0 5F                      clrb  4CB1 34   24                 pshs   b,y       delimiter flag                     *  4CB3 6D   E4       xtprc2    tst    0,s       delimiter?  4CB5 27   10                 beq    xtpr22                     *  4CB7 6F   E4                 clr    0,s       clear del flag  4CB9 6D   0B                 tst    tdel,x    check del count  4CBB 27   02                 beq    xtpr21    if 0 - skip                     *  4CBD 6A   0B                 dec    tdel,x    dec the del count                     *  4CBF A6   08       xtpr21    lda    tflags,x  get flags  4CC1 85   41                 bita   #RAW|SCHR in raw mode?  4CC3 1027 0081               lbeq   xtprc5                     *  4CC7 10AE 84       xtpr22    ldy    tqin,x    point to in q  4CCA 17   FA6E               lbsr   getc      get a character  4CCD 2B   79                 bmi    xtprc5    none left?                     *  4CCF C1   0D                 cmpb   #CR       check for delim  4CD1 27   0C                 beq    xtpr25                     *  4CD3 C1   04                 cmpb   #EOTCH  4CD5 26   0A                 bne    xtprc3                     *  4CD7 6C   E4                 inc    0,s       set del flag  4CD9 A6   08                 lda    tflags,x  get flags  4CDB 85   40                 bita   #SCHR     single char mode?  4CDD 26   D4                 bne    xtprc2                     *  4CDF 6C   E4       xtpr25    inc    0,s       set del flag                     *  4CE1 A6   08       xtprc3    lda    tflags,x  check mode  4CE3 85   41                 bita   #RAW|SCHR  4CE5 27   04                 beq    xtpr31                     *  4CE7 6C   E4                 inc    0,s       set del flag for each raw char  4CE9 20   4D                 bra    xtpr45                     *  4CEB 10AE 61       xtpr31    ldy    1,s       point to buffer  4CEE A6   3F                 lda    -1,y      check previous  4CF0 81   5C                 cmpa   #'\       escape?  4CF2 26   13                 bne    xtca32                     *Task       Structure                 08:54:40  Feb 29, 2020   Page   78TTY        Handlers                                   4CF4 C1   04                 cmpb   #EOTCH    is it eot?  4CF6 27   08                 beq    xtp315                     *  4CF8 E1   0D                 cmpb   tbksp,x   backspace char?  4CFA 27   04                 beq    xtp315                     *  4CFC E1   0E                 cmpb   tcncl,x   cancel char?  4CFE 26   07                 bne    xtca32                     *  4D00 31   3F       xtp315    leay   -1,y      backup over slash  4D02 10AF 61                 sty    1,s       save new ptr  4D05 20   31                 bra    xtpr45                     *  4D07 E1   0D       xtca32    cmpb   tbksp,x   backspace char?  4D09 26   0D                 bne    xtca33                     *  4D0B 108C 013A               cmpy   #prcbuf+2 buffer begin?  4D0F 27   A2                 beq    xtprc2                     *  4D11 31   3F                 leay   -1,y      backup pointer  4D13 10AF 61                 sty    1,s  4D16 20   9B                 bra    xtprc2                     *  4D18 C1   04       xtca33    cmpb   #EOTCH    eot char?  4D1A 27   97                 beq    xtprc2                     *  4D1C E1   0E                 cmpb   tcncl,x   cancel char?  4D1E 26   04                 bne    xtprc4                     *  4D20 35   24                 puls   b,y       -- caution (order)  4D22 20   88                 bra    xtprc1    repeat all                     *  4D24 C1   20       xtprc4    cmpb   #$20      check for control char  4D26 24   10                 bhs    xtpr45                     *  4D28 C1   0D                 cmpb   #CR       is it cr?  4D2A 27   0C                 beq    xtpr45                     *  4D2C C1   09                 cmpb   #9        is it tab char?  4D2E 27   08                 beq    xtpr45                     *  4D30 A6   08                 lda    tflags,x  get flags  4D32 85   80                 bita   #CNTRL    control char ignore?  4D34 1026 FF7B               lbne   xtprc2                     *  4D38 10AE 61       xtpr45    ldy    1,s       get pointer  4D3B E7   A0                 stb    0,y+      transfer char  4D3D 10AF 61                 sty    1,s       save pointer  4D40 108C 0238               cmpy   #prcbuf+PRCSIZ overflow??  4D44 1025 FF6B               lblo   xtprc2                     *  4D48 35   04       xtprc5    puls   b         remove del flag from stackTask       Structure                 08:54:40  Feb 29, 2020   Page   79TTY        Handlers                                   4D4A 10AE 02                 ldy    tqproc,x  get procd q  4D4D 34   10                 pshs   x  4D4F 8E   013A               ldx    #prcbuf+2 point to processed buf                     *  4D52 AC   62       xtprc6    cmpx   2,s       end of buffer?  4D54 24   07                 bhs    xtprc7                     *  4D56 E6   80                 ldb    0,x+      get character  4D58 17   FA28               lbsr   putc  4D5B 20   F5                 bra    xtprc6                     *  4D5D               xtprc7                                          ***+++                     ***---                       4D5D CC   FFFF               ldd    #-1       set good  4D60 35   B0                 puls   x,y,pc    return                                          ***+++                     ***---                     Task       Structure                 08:54:40  Feb 29, 2020   Page   80TTY        Handlers                                                                           *                     * req_read - CPU has informed us he wants to read                     * Tell him when some data is available.                     *  4D62 17   FB29     req_read  lbsr   ttftab    get TTY table address  4D65 A6   98 02              lda    [tqproc,x] anything available?  4D68 26   03                 bne    00f       yes - go use it                     *  4D6A 17   FF1D               lbsr   xtprcq    go process input (wait if none there)                     *  4D6D A6   98 02    00        lda    [tqproc,x] get input processed count  4D70 27   0A                 beq    05f       jump for EOF detected                     *  4D72 81   01                 cmpa   #1        special case for single character  4D74 27   09                 beq    10f                     *  4D76 E6   08                 ldb    tflags,x  single character & RAW always return 1 char  4D78 C5   41                 bitb   #RAW|SCHR  4D7A 26   03                 bne    10f                     *  4D7C C6   07       05        ldb    #R_RDOK   inform CPU data now available  4D7E 39                      rts                     *  4D7F 10AE 02       10        ldy    tqproc,x  go fetch character  4D82 17   F9B6               lbsr   getc  4D85 86   09                 lda    #R_RD1C   inform CPU single character returned  4D87 1E   89                 exg    a,b  4D89 39                      rts                                          *                     * read_data - CPU wants IOP to send data                     *  Max # chars to move in transaction speicific value                     *  4D8A 17   FB01     read_data lbsr   ttftab    get TTY table address  4D8D FE   0111               ldu    utask     see how many chars to send  4D90 10AE 02                 ldy    tqproc,x  input queue pointer  4D93 6F   E2                 clr    ,-s       set FIFO counter                     *  4D95 A6   A4       10        lda    0,y       any more characters?  4D97 27   0C                 beq    20f       no - done                     *  4D99 17   F99F               lbsr   getc      fetch character  4D9C 17   F64E               lbsr   FIFO_put  put into FIFO  4D9F 6C   E4                 inc    0,s       bump FIFO count  4DA1 6A   4D                 dec    tstval,u  does the guy want more?  4DA3 26   F0                 bne    10b                     *  4DA5 A6   E0       20        lda    ,s+       get # chars in FIFO  4DA7 C6   08                 ldb    #R_SNDNC  data now available in FIFO  4DA9 6D   A4                 tst    0,y       any more data in case guy wants it?  4DAB 27   02                 beq    30fTask       Structure                 08:55:06  Feb 29, 2020   Page   81TTY        Handlers                                                      *  4DAD C6   0B                 ldb    #R_SNDMC  yes - special response                     *  4DAF 39            30        rtsTask       Structure                 08:55:10  Feb 29, 2020   Page   82TTY        Handlers                                                                           *                     * ttywrt                     *                     * The main terminal write routine.  Control is passed                     * to here from the device driver routine which calculates                     * the ttys structure location and passes it in x.                     *                       4DB0 D6   08       ttywrt    ldb    fifo_cnt  get FIFO input length  4DB2 C1   00                 cmpb   #0        anything in FIFO?  4DB4 27   0E                 beq    90f       no - exit                     *  4DB6 34   04                 pshs   b         save input length                     *  4DB8 17   F60E     10        lbsr   FIFO_get  fetch character  4DBB 17   FCB5               lbsr   ttyout    output it  4DBE 6A   E4                 dec    0,s       decrement count  4DC0 26   F6                 bne    10b       repeat                     *  4DC2 35   02                 puls   a         clean up stack                     *  4DC4 34   01       90        pshs   cc        save cc  4DC6                         seti   mask      ints  4DC8 17   FC5B               lbsr   ttyst     give output a kick  4DCB 35   81                 puls   cc,pc     return                                          *                     * open_tty - Perform device open                     *  4DCD               open_tty  4DCD BD   4816               jsr    ttopn     perform tty open                                          ***+++                     ***---                       4DD0 C6   02       10        ldb    #R_OPEN  4DD2 39                      rts                                          *                     * close_tty - Perform device close                     *  4DD3               close_tty  4DD3 BD   4868               jsr    ttcls     perform tty close                                          ***+++                     ***---                       4DD6 C6   03       10        ldb    #R_CLOSE  4DD8 39                      rts                                          *Task       Structure                 08:55:34  Feb 29, 2020   Page   83TTY        Handlers                                                      * req_write - Request permission to write data                     *  4DD9               req_write  4DD9 BD   488E               jsr    ttftab    get TTY table                                          ***+++                     ***---                       4DDC 34   01       05        pshs   cc        mask interrupts while fiddling                     *  4DDE               10        seti  4DE0 10AE 04                 ldy    tqout,x   get output queue pointer  4DE3 EC   A4                 ldd    oq_count,y get queue length  4DE5 E3   88 15              addd   tsold,x   include any space already sold  4DE8 C3   0080               addd   #FIFO_SIZE and assume the CPU will send this many more  4DEB 10B3 0102               cmpd   OQHI      space available?  4DEF 2F   16                 ble    20f       yes - OK                     *  4DF1 A6   09                 lda    tdelay,x  special flush bit?  4DF3 85   40                 bita   #$40  4DF5 27   05                 beq    15f       no - go to sleep                     *  4DF7 BD   4C4C               jsr    flusho    yes - flush output  4DFA 20   E2                 bra    10b       try again                     *  4DFC 34   76       15        pshs   d,x,y,u   no - save registers  4DFE C6   E2                 ldb    #TTYSPR  4E00 BD   46E8               jsr    sleep  4E03 35   76                 puls   d,x,y,u   restore registers  4E05 20   D7                 bra    10b       try again                     *  4E07 10BE 0111     20        ldy    utask     am I supposed to be dead?  4E0B 6D   29                 tst    tssgnl,y  4E0D 26   0D                 bne    30f       yes - abort                     *  4E0F EC   88 15              ldd    tsold,x   update amount pre-sold  4E12 C3   0080               addd   #FIFO_SIZE -- assume entire FIFO load  4E15 ED   88 15              std    tsold,x  4E18 C6   04                 ldb    #R_REQOK  request granted code  4E1A 35   81                 puls   cc,pc     return                     *  4E1C 35   01       30        puls   cc        clean up stack  4E1E 32   62                 leas   2,s       -- pop normal return  4E20 39                      rts              abnormal   I/O completion (no response)                                          *                     * write_data - Write data to a terminal                     *  4E21               write_data  4E21 BD   488E               jsr    ttftab    get tty table pointer >4E24 BD   4DB0               jsr    ttywrt    go consume data  4E27 34   01                 pshs   cc        save interrupt stateTask       Structure                 08:55:48  Feb 29, 2020   Page   84TTY        Handlers                                   4E29                         seti   mask      interrupts  4E2B EC   88 15              ldd    tsold,x  4E2E 83   0080               subd   #FIFO_SIZE  4E31 2A   03                 bpl    00f                     *  4E33 CC   0000               ldd    #0        don't screw up!                     *  4E36 ED   88 15    00        std    tsold,x   update count  4E39 10AE 04                 ldy    tqout,x   wake up anybody waiting for space                                          ***+++                     ***---                       4E3C BD   46C4     10        jsr    wakeup  4E3F C6   05                 ldb    #R_WRITE  4E41 35   81                 puls   cc,pc     return                     *  4E43 0D 46 49 46   00        fcc    $d,'FIFO consumed, wakeup at $',0                                          *                     * Write single character                     *  -- Character passed via transaction message                     *  4E5F 34   01       wrt_sc    pshs   cc        save interrupt state  4E61 BD   488E               jsr    ttftab    compute tty table address                     *  4E64 10AE 04       00        ldy    tqout,x   output Q pointer  4E67 EC   A4                 ldd    oq_count,y check for overrun  4E69 10B3 0102               cmpd   OQHI  4E6D 23   12                 bls    10f       jump if space                     *  4E6F A6   09                 lda    tdelay,x  special flush bit?  4E71 85   40                 bita   #$40  4E73 27   05                 beq    05f       no - wait for space                     *  4E75 BD   4C4C               jsr    flusho    yes - make space!  4E78 20   EA                 bra    00b                     *  4E7A C6   EC       05        ldb    #TTYOPR   wait a while  4E7C BD   46E8               jsr    sleep  4E7F 20   E3                 bra    00b       try again                     *  4E81 10BE 0111     10        ldy    utask     fetch character  4E85 E6   2D                 ldb    tstval,y  4E87 BD   4A73               jsr    ttyout    send to output queue  4E8A                         seti   mask      interrupts  4E8C BD   4A26               jsr    ttyst     kick output - make sure it starts  4E8F C6   05                 ldb    #R_WRITE  4E91 35   81                 puls   cc,pc     return                                          *                     * send_int - Interrupt all tasks associated with a terminalTask       Structure                 08:55:48  Feb 29, 2020   Page   85TTY        Handlers                                                      *  4E93 34   76       send_int  pshs   d,x,y,u  4E95 BD   488E               jsr    ttftab    get TTY table address  4E98 BD   4C24               jsr    flusht    flush terminal buffers  4E9B A6   61                 lda    1,s       get terminal #  4E9D BD   4539               jsr    int_all   interrupt all associated tasks  4EA0 BE   0111               ldx    utask     also interrupt current task if appropriate  4EA3 A6   61                 lda    1,s  4EA5 A1   08                 cmpa   tsdev,x  4EA7 26   03                 bne    10f                     *  4EA9 BD   471D               jsr    xmtint                     *  4EAC 35   F6       10        puls   d,x,y,u,pc clean up stack & return                                          ***+++                     ***----                     Task       Structure                 08:55:49  Feb 29, 2020   Page   86ACIA       interface routines                                                                 * The routines in this file are specific to an ACIA (6850).                     * They are called from the "ttyhan" and "ttydrv" files.                                          *                     * 6850 Device table                     *  4EAE               DEV_6850  4EAE 4458                    fdb    bad_cmd   0 -  4EB0 4DCD                    fdb    open_tty  1 -  4EB2 4DD3                    fdb    close_tty 2 -  4EB4 4926                    fdb    ttyset    3 -  4EB6 49BC                    fdb    ttyget    4 -  4EB8 4DD9                    fdb    req_write 5 -  4EBA 4E21                    fdb    write_data 6 -  4EBC 4E5F                    fdb    wrt_sc    7 -  4EBE 4D62                    fdb    req_read  8 -  4EC0 4D8A                    fdb    read_data 9 -  4EC2 4458                    fdb    bad_cmd   A -  4EC4 4458                    fdb    bad_cmd   B -  4EC6 4458                    fdb    bad_cmd   C -  4EC8 4458                    fdb    bad_cmd   D -  4ECA 4458                    fdb    bad_cmd   E -  4ECC 4458                    fdb    bad_cmd   F -  * clock_on  4ECE 4F04                    fdb    SR4_IRQ   10  4ED0 4F1E                    fdb    SR4_init  11  4ED2 4F2C                    fdb    SR4_test  12                     *  4ED4 4FBD                    fdb    SR4ttconf  4ED6 4FE5                    fdb    SR4ttputc  4ED8 4FE8                    fdb    SR4ttgetc  4EDA 4FEB                    fdb    SR4ttnxr  4EDC 4FF2                    fdb    SR4ttdisx  4EDE 4FF9                    fdb    SR4ttnr  4EE0 5000                    fdb    SR4ttnx  4EE2 5007                    fdb    SR4ttnno  4EE4 500E                    fdb    SR4ttxbsy  4EE6 5045                    fdb    SR4ttstx  4EE8 5013                    fdb    SR4ttiscts  4EEA 5039                    fdb    SR4ttstr  4EEC 501F                    fdb    SR4ttstb  4EEE 503F                    fdb    SR4ttsts  4EF0 5030                    fdb    SR4ttstc  4EF2 5050                    fdb    SR4ttstd  4EF4 504B                    fdb    SR4ttste  4EF6 5053                    fdb    SR4ttnd  4EF8 5054                    fdb    SR4ttwcts  4EFA 505E                    fdb    SR4ttwdcd                     *                     * preset table for baudrates at each port                     * this table MUST have the same length as tspd_iop in tspddrvr.t                     *Task       Structure                 08:55:49  Feb 29, 2020   Page   87ACIA       interface routines                                            * baudrate latch backup bytes, for 2 acia's each                     *                     * CB B2 B1 B0 CA A2 A1 A0       C=/CTS override, 0 = active                     * X2 X1 X0 are baudrate select bits 0K3/0K6/1K2/2K4/4K8/9K6/19K2/38K4                     * 111 is highest baudrate, 000 is lowest.                     *  4EFC 77            brbupr    fcb    $77       acia 0 and 1 board 1  4EFD 77                      fcb    $77       acia 2 and 3  4EFE 77                      fcb    $77       acia 4 and 5 board 2  4EFF 77                      fcb    $77       acia 6 and 7  4F00 77                      fcb    $77       acia 8 and 9 board3  4F01 77                      fcb    $77       acia 10 and 11  4F02 77                      fcb    $77       acia 12 and 13 board 4  4F03 77                      fcb    $77       acia 14 and 15               0008  BRTBSIZ   equ    *-brbupr                                          *                     * Check for and process an ACIA interrupt                     *  D - Device #                     *  X - Device address                     *  4F04 34   76       SR4_IRQ   pshs   d,x,y,u   save registers just in case  4F06 A6   84                 lda    csr,x     check for interrupt  4F08 85   80                 bita   #AS_IRQ  4F0A 27   0E                 beq    10f       jump if no interrupt                     *  4F0C 5F                      clrb  4F0D 34   06                 pshs   d                     *  4F0F EC   62                 ldd    2,s       restore device #  4F11 BD   48A5               jsr    tintr     go process interrupt  4F14 32   62                 leas   2,s       remove device status  4F16 1A   01                 sec              --         interrupt processed  4F18 20   02                 bra    99f                     *  4F1A 1C   FE       10        clc              --         no interrupt processed                     *  4F1C 35   F6       99        puls   d,x,y,u,pc                                          *                     * Initialize ACIA port                     *   B - Device #                     *   X - Device address                     *  4F1E 34   76       SR4_init  pshs   d,x,y,u  4F20 6F   02                 clr    2,x       init baudrate latch  4F22 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  4F24 A7   84                 sta    0,x       reset acia  4F26 34   06                 pshs   d         delay  4F28 35   06                 puls   d  4F2A 35   F6                 puls   d,x,y,u,pc                     Task       Structure                 08:55:49  Feb 29, 2020   Page   88ACIA       interface routines                                            *                     * Determine if CPU09SR4 ACIA board is present                     *  D - ACIA port address                     *  Y - Device table address                     *  <CS> if present & ACIA                     *  4F2C 34   56       SR4_test  pshs   d,x,u  4F2E 1F   03                 tfr    d,u  4F30 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  4F32 A7   C4                 sta    0,u       reset acia  4F34 34   06                 pshs   d         delay  4F36 35   06                 puls   d  4F38 A6   C4                 lda    0,u       check response  4F3A 27   08                 beq    00f                     *  4F3C 84   F3                 anda   #%11110011 todo: bit names  4F3E 27   04                 beq    00f                     *  4F40 1C   FE                 clc              --         not an 6350  4F42 20   77                 bra    99f                     *                     * found an ACIA, fill in the port info                     *  4F44 96   FB       00        lda    NUM_TRM   compute device table address  4F46 C6   08                 ldb    #DEV_SIZE  4F48 3D                      mul  4F49 108E 028A               ldy    #dev_tab  4F4D 31   AB                 leay   d,y  4F4F 96   FB                 lda    NUM_TRM  4F51 46                      rora             2 ports for each baudrate backup  4F52 CE   02B6               ldu    #brbutb   address of table  4F55 33   C6                 leau   a,u                     * account for 4 ports CPU09SR4  4F57 D6   FB                 ldb    NUM_TRM  4F59 CB   04                 addb   #4  4F5B D7   FB                 stb    NUM_TRM                     *  4F5D EC   E4                 ldd    0,s       port address  4F5F 8E   4EAE               ldx    #DEV_6850  4F62 ED   A4                 std    dev_addr,y device address  4F64 AF   22                 stx    dev_type,y handler dispatch table  4F66 EF   24                 stu    dev_brbu,y baudrate latch backup  4F68 34   02                 pshs   a  4F6A 86   0F                 lda    #%00001111  4F6C A7   26                 sta    dev_brmk,y baudrate latch mask  4F6E A6   C9 4C46            lda    (brbupr-brbutb),u get rom preset  4F72 A7   C4                 sta    0,u  4F74 35   02                 puls   a  4F76 31   28                 leay   DEV_SIZE,y  4F78 C3   0004               addd   #4        offset to next ACIA  4F7B ED   A4                 std    dev_addr,y  4F7D AF   22                 stx    dev_type,yTask       Structure                 08:55:51  Feb 29, 2020   Page   89ACIA       interface routines                         4F7F EF   24                 stu    dev_brbu,y  4F81 34   02                 pshs   a  4F83 86   F0                 lda    #%11110000  4F85 A7   26                 sta    dev_brmk,y baudrate latch mask  4F87 35   02                 puls   a  4F89 31   28                 leay   DEV_SIZE,y  4F8B C3   0004               addd   #4  4F8E 33   41                 leau   1,u       next backup location  4F90 ED   A4                 std    dev_addr,y  4F92 AF   22                 stx    dev_type,y  4F94 EF   24                 stu    dev_brbu,y  4F96 34   02                 pshs   a  4F98 86   0F                 lda    #%00001111  4F9A A7   26                 sta    dev_brmk,y baudrate latch mask  4F9C A6   C9 4C46            lda    (brbupr-brbutb),u get rom preset  4FA0 A7   C4                 sta    0,u  4FA2 35   02                 puls   a  4FA4 31   28                 leay   DEV_SIZE,y  4FA6 C3   0004               addd   #4  4FA9 ED   A4                 std    dev_addr,y  4FAB AF   22                 stx    dev_type,y  4FAD EF   24                 stu    dev_brbu,y  4FAF 34   02                 pshs   a  4FB1 86   F0                 lda    #%11110000  4FB3 A7   26                 sta    dev_brmk,y baudrate latch mask  4FB5 35   02                 puls   a  4FB7 31   28                 leay   DEV_SIZE,y  4FB9 1A   01                 sec  4FBB 35   D6       99        puls   d,x,u,pc                                                               *                     * ttconf                     *                     * Configure the port pointed at by the Y register.  The X                     * register is pointing to the terminal table.  All registers                     * except D should be preserved.                     *                       4FBD 86   03       SR4ttconf lda    #AC_MRES  reset the acia  4FBF A7   A4                 sta    csr,y  4FC1 34   06                 pshs   d         delay some here  4FC3 35   06                 puls   d  4FC5 A6   A4                 lda    csr,y     get status - see if acia is really here  4FC7 27   04                 beq    2f        if 0 status - then ok                     *  4FC9 85   F3                 bita   #$f3      see if funny status is ok  todo: bit names  4FCB 26   10                 bne    4f                     *  4FCD A6   0F       2         lda    tbaud,x   get configuration word from table                                          Task       Structure                 08:56:17  Feb 29, 2020   Page   90ACIA       interface routines                         4FCF 8A   01                 ora    #AC_DV16  set up full configuration  4FD1 A7   A4                 sta    csr,y     (no ints enabled & RTS brought high)                     *  4FD3 86   77                 lda    #$77      tbaud2,x  4FD5 A7   22                 sta    brr,y     baudrate latch                     *  4FD7 A6   A4                 lda    csr,y     get new status  4FD9 85   08                 bita   #AS_NCTS  is CTS ok?  4FDB 27   05                 beq    6f                     *  4FDD 1A   04       4         sez              set        false status  4FDF 1C   FE                 clc              show       wait for CTS  4FE1 39                      rts              return                     *  4FE2 1C   FB       6         clz              set        true status  4FE4 39                      rts              return                                                               *                     * ttputc                     *                     * Send the character in the B register to the ACIA.  All                     * registers should be preserved.  Y points to the device.                     *                       4FE5 E7   21       SR4ttputc stb    dbuf,y    send character  4FE7 39                      rts              return                                                               *                     * ttgetc                     *                     * Get the character from the device and return in the B                     * register.  Y points to the device and all registers                     * should be preserved.                     *                       4FE8 E6   21       SR4ttgetc ldb    dbuf,y    get the character  4FEA 39                      rts              return                                                               *                     * ttenxr                     *                     * Enable the transmit interrupts and leave the receive                     * interrupt enabled (it is enabled upon routine entry).                     * Y points to the device and X points to to the terminal                     * table entry.  Preserve all registers but D.                     *                     *                       4FEB A6   0F       SR4ttnxr  lda    tbaud,x   get configurationTask       Structure                 08:56:17  Feb 29, 2020   Page   91ACIA       interface routines                         4FED 8A   A1                 ora    #AC_TEIN+AC_REIN+AC_DV16 enable int bits  4FEF A7   A4                 sta    csr,y     send to acia  4FF1 39                      rts              return                                                               *                     * ttdisx                     *                     * Disable the transmit interrupt and leave the receive                     * interrupt enabled.  Y points to the device and X points                     * to the terminal table entry.  Preserve all but D.                     *                       4FF2 A6   0F       SR4ttdisx lda    tbaud,x   get configuration word  4FF4 8A   81                 ora    #AC_REIN+AC_DV16 set bits  4FF6 A7   A4                 sta    csr,y     send to acia  4FF8 39                      rts              return                                                               *                     * ttenr                     *                     * Enable the receive interrupts only.  The transmit                     * interrupts should be turned off.  Y points to the device                     * and X point to the terminal table entry.  Preserve all                     * but the D register.                     *                       4FF9 A6   0F       SR4ttnr   lda    tbaud,x   get configuration word  4FFB 8A   81                 ora    #AC_REIN+AC_DV16 set bits  4FFD A7   A4                 sta    csr,y     send to acia  4FFF 39                      rts              return                                                               *                     * ttenx                     *                     * Enable the transmit interrupts only.  The receive                     * interrupts should be left disabled.  Y points to the                     * device and X points to the terminal table entry.                     * All registers but D shoud be preserved.                     *                       5000 A6   0F       SR4ttnx   lda    tbaud,x   get configuration word  5002 8A   21                 ora    #AC_TEIN+AC_DV16 set bits  5004 A7   A4                 sta    csr,y     send to acia  5006 39                      rts              return                                                               *                     * ttenno                     *Task       Structure                 08:56:17  Feb 29, 2020   Page   92ACIA       interface routines                                            * Disable all interrupts from device and drop the RTS                     * line.  Y points to the device and X points to the                     * terminal table entry.  Preserve all but D register.                     *                       5007 A6   0F       SR4ttnno  lda    tbaud,x   get configuration word  5009 8A   41                 ora    #AC_DRTS+AC_DV16 set bits  500B A7   A4                 sta    csr,y     send to acia  500D 39                      rts              return                                                               *                     * ttxbsy                     *                     * Test if the transmit buffer is empty.  Return TRUE if                     * it is empty (N.E. status). Y points to the device and                     * all but A needs preserved.                     *                       500E A6   A4       SR4ttxbsy lda    csr,y     get status  5010 85   02                 bita   #AS_TDRE  is it busy?  5012 39                      rts              return                                          *                     * ttiscts                     *                     * Test device pointed at by X for "Clear to Send"                     * -- Return TRUE (not equal) if yes                     *  5013 A6   A4       SR4ttiscts lda   csr,y     check for CTS  5015 85   08                 bita   #AS_NCTS  is CTS down?  5017 26   03                 bne    SR4false  5019 1C   FB       SR4true   clz              no         - return TRUE  501B 39                      rts  501C 1A   04       SR4false  sez              yes        - return FALSE  501E 39                      rts                                          *************************************************************                     *                     * tttstb                     *                     * Test device pointed at by Y for a "break" condition.                     * Return TRUE if found.  Preserve all registers but A                     * and return NULL in B (for break character).                     *                       501F A6   A4       SR4ttstb  lda    csr,y  5021 85   30                 bita   #AS_OVRN+AS_FRME check for break condition  5023 27   0A                 beq    2f                     *  5025 E6   21                 ldb    dbuf,y    get character from acia  5027 34   76                 pshs   d,x,y,u   delay some hereTask       Structure                 08:56:18  Feb 29, 2020   Page   93ACIA       interface routines                         5029 35   76                 puls   d,x,y,u  502B A6   21                 lda    dbuf,y    get next garbage char if any  502D 1C   FB                 clz              set        true                     *  502F 39            2         rts              return                                          *                     * tttstc                     *                     * Test device pointed at by Y for drop "Carrier Detect"                     * type interrupt.  Return TRUE if so.  Preserve all registers                     * but A.                     *                       5030 85   04       SR4ttstc  bita   #AS_NDCD  check for carrier drop  5032 27   04                 beq    1f        jump if no error                     *  5034 E6   21                 ldb    dbuf,y    read reg to reset status  5036 1C   FB                 clz              return     true                     *  5038 39            1         rts              return                                          *                     * tttstr                     *                     * Test device pointed at by Y for a receive interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       5039               SR4ttstr  5039 85   01                 bita   #AS_RDRF  503B 26   DC                 bne    SR4true  503D 20   DD                 bra    SR4false                                          *****************************************************************                     *                     *                     * tttsts                     *                     * Test device for "CTS" interrupt.                     *                       503F A6   A4       SR4ttsts  lda    csr,y  5041 85   08                 bita   #AS_NCTS                       5043 20   D7                 bra    SR4false  not currently implemented                                          *                     * tttstx                     *                     * Test device pointed at by Y for a transmit interrupt.Task       Structure                 08:56:32  Feb 29, 2020   Page   94ACIA       interface routines                                            * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *  5045               SR4ttstx  5045 85   02                 bita   #AS_TDRE  5047 26   D0                 bne    SR4true  5049 20   D1                 bra    SR4false                                          *                     * tttste                     *                     * Test device pointed at by Y for error conditions.                     * Handle all errors local to this routine - no status                     * returned.  Preserve all but A.                     *                       504B A6   21       SR4ttste  lda    dbuf,y    read data register to clear any interrupt conditions  504D 1A   04                 sez              return false clz     return     true  504F 39                      rts              return                                          *                     * tttstd - Test for drop in DTR                     *  5050 1A   04       SR4ttstd  sez              --         not supported by hardware  5052 39                      rts                                                               *                     * ttend                     *                     * Terminate i/o operation for device pointed at by Y.                     * Preserve all but D.                     *                       5053 39            SR4ttnd   rts              return     (nothing for acia)                                                               *                     * ttwcts                     *                     * Wait for CTS to go high (sleep on it).                     *                       5054 8D   AA       SR4ttwcts bsr    SR4ttnx   enable xmit ints only  5056 C6   EC                 ldb    #TTYOPR   set priority  5058 10AE 04                 ldy    tqout,x   point to output q  505B 7E   46E8               jmp    sleep     sleep on CTS                                                               *                     * ttwdcd                     *Task       Structure                 08:56:53  Feb 29, 2020   Page   95ACIA       interface routines                                            * Wait for DCD to go high (sleep on it).                     *                       505E 39            SR4ttwdcd rts              currently  not implementedTask       Structure                 08:56:56  Feb 29, 2020   Page   96Debug Interface Routines                                                   505F               DB_main  505F 8D   4F                 bsr    DB_test   see if debug routines present  5061 6E   9F 6002            jmp    [DEBUGROM+2]  5065               DB_pdata  5065 8D   49                 bsr    DB_test   see if debug routines present  5067 6E   9F 6004            jmp    [DEBUGROM+4]  506B               DB_phex  506B 8D   43                 bsr    DB_test   see if debug routines present  506D 6E   9F 6006            jmp    [DEBUGROM+6]  5071               DB_phex2  5071 8D   3D                 bsr    DB_test   see if debug routines present  5073 6E   9F 6008            jmp    [DEBUGROM+8]  5077               DB_pcrlf  5077 8D   37                 bsr    DB_test   see if debug routines present  5079 6E   9F 600A            jmp    [DEBUGROM+10]  507D               DB_check  507D 8D   31                 bsr    DB_test   see if debug routines present  507F 6E   9F 600C            jmp    [DEBUGROM+12]  5083               DB_config  5083 8D   2B                 bsr    DB_test   see if debug routines present  5085 6E   9F 600E            jmp    [DEBUGROM+14]  5089 34   17       DB_msg    pshs   cc,d,x  508B AE   65                 ldx    1+2+2,s   get return address  508D EC   81                 ldd    ,x++      get mask word  508F B4   0109               anda   DB_cntrl  5092 F4   010A               andb   DB_cntrl+1  5095 34   04                 pshs   b  5097 AA   E0                 ora    ,s+  5099 27   04                 beq    10f       jump if flag not set  509B 30   02                 leax   2,x       skip over false address & fall through  509D 20   02                 bra    20f  509F AE   84       10        ldx    ,x        get false branch label  50A1 AF   65       20        stx    1+2+2,s   fix up return address  50A3 35   97                 puls   cc,d,x,pc return                     *  50A5               DB_pspace  50A5               DB_outsp  50A5 34   16                 pshs   d,x  50A7 8E   50AE               ldx    #00f  50AA 8D   B9                 bsr    DB_pdata  50AC 35   96                 puls   d,x,pc  50AE 20 00         00        fcc    ' ',0                       50B0 34   07       DB_test   pshs   cc,d  50B2 FC   6000               ldd    DEBUGROM  Debug rom present?  50B5 1083 1234               cmpd   #$1234    special marker  50B9 27   05                 beq    99f       yes - exit  50BB 35   07                 puls   cc,d      no - abort DB_xx function  50BD 32   62                 leas   2,s  50BF 39                      rts  50C0 35   87       99        puls   cc,d,pc   returnTask       Structure                 08:56:56  Feb 29, 2020   Page   97Debug Interface Routines                                                                                                     end4 Error(s) detected    17 Excessive BRANCH/JUMP(S) detectedTask       Structure                 08:56:56  Feb 29, 2020   Page   98Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AC_8N1   0014   AC_DIV0  0001   AC_DIV1  0002   AC_DRTS  0040   AC_DV16  0001   AC_MRES  0003   AC_REIN  0080   AC_SET   0015   AC_TEIN  0020   AC_WS0   0004   AC_WS1   0008   AC_WS2   0010   AS_FRME  0010   AS_IRQ   0080   AS_NCTS  0008   AS_NDCD  0004   AS_OVRN  0020   AS_PERR  0040   AS_RDRF  0001   AS_TDRE  0002   B        0009   BASE_SLO 8000   BRTBSIZ  0008   BSECH    0020   BSPCH    007F   CBSIZE   0020   CC       000A   CHRLIM   00FE   CLISTS   027A   CLOCK    8070   CLOCKI   8071   CLOCKPR  FFC4   CNCLC    0018   CNTRL    0080   CPU_down 403D   CPUtraps FFF0   CR       000D   CRMOD    0010   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check 507D   DB_cntrl 0109   DB_confi 5083   DB_iflg  0108   DB_main  505F   DB_msg   5089   DB_outsp 50A5   DB_pcrlf 5077   DB_pdata 5065   DB_phex  506B   DB_phex2 5071   DB_pspac 50A5   DB_test  50B0   DBmsg00  4000   DBmsg01  4009   DBmsg02  4029   DEBUG    0D04   DEBUGROM 6000   DEBUG_CO 0000   DEV_6850 4EAE   DEV_BAD  445B   DEV_SIZE 0008   DLE      0010   DLE_GOT  0040   DLE_SENT 0020   DO_HISTO 0001   DO_IXON  0000   DP       000B   DSR_OK   0001   D_CLOCK  001E   D_CLOSE  0004   D_END    0026   D_INTRPT 0014   D_OPEN   0002   D_RQRD   0010   D_RQWR   000A   D_SEND   0012   D_TTYG   0008   D_TTYS   0006   D_WRC    000E   D_WRITE  000C   D_init   0022   D_inthan 0020   D_test   0024   D_ttconf 0026   D_ttdisx 002E   D_ttend  0048   D_ttenno 0034   D_ttenr  0030   D_ttenx  0032   D_ttenxr 002C   D_ttgetc 002A   D_ttisct 003A   D_ttputc 0028   D_tttstb 003E   D_tttstc 0042   D_tttstd 0044   D_tttste 0046   D_tttstr 003C   D_tttsts 0040   D_tttstx 0038   D_ttwcts 004A   D_ttwdcd 004C   D_ttxbsy 0036   E        000E   ECHO     0002   EOTCH    0004   ESCOFF   0080   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SYSBSY 0082   F        000F   FF       0040   FIFO_SIZ 0080   FIFO_get 43C9   FIFO_put 43ED   FIFOgeta 43C0   FIFOputa 43E5   FIOPRI   FFCE   FIO_get  439E   FIO_lock 0130   FIO_rel  43B3   HANGS    0001   HOLD     0002   HOLDC    001B   HRECSIZ  0004   H_cpu    45BA   H_iop    45DE   IF       0010   INTRC    0003   INTS     0002   IO_end   443F   IO_han   4404   IRQ_han  447E   IRQmsg10 4521   IXONXOF  0010   LCASE    0008   MAXHIST  0010   MAX_CL   007C   MAX_DEV  0005   MAX_NEC  0000   MAX_OB   0400   MAX_PPR  0000   MAX_TI   000A   MAX_TRAN 0018   MAX_TSK  0028   MAX_TTY  0004   MIN_OB   0120   MIN_TSK  0020   MOD_SIZE 0004   NECADR   02B4   NEC_IQ   02B2   NECstr   0288   NEXT_SLO 0010   NL       000A   NUM_CL   00FA   NUM_NEC  00FC   NUM_PPR  00FD   NUM_SLOT 0001   NUM_TRM  00FB   NUM_TSK  00F9   OBUFRS   0280   OBUF_SIZ 0100   OQHI     0102   OQH_SIZE 000A   OQLO     0104   O_BAUDR  00B0   O_BAUDW  00C0   O_CLOSE  0020   O_INTRPT 00A0   O_OPEN   0010   O_RQRD   0080   O_RQWR   0050   O_SEND   0090   O_TTYG   0040   O_TTYS   0030   O_WRC    0070   O_WRITE  0060   PC       0005   PPstr    0286   PRCSIZ   0100   PROTOCOL 00F8   QH_SIZE  0005   QUITC    001C   QUITS    0003   RAMend   2FFF   RAMorg   0100   RAMscrat 3000   RAMscren 3F00   RAW      0001   REJECT   0080   ROMLOorg 4000   ROM_ERR  40B7   ROM_VERS 0012   ROMstack 3FFF   RUNPRI   0046   R_BAUD   000D   R_CLOCK  000C   R_CLOSE  0003   R_INTRPT 000A   R_OPEN   0002   R_RD1C   0009   R_RDOK   0007   R_REQOK  0004   R_RESET  0001   R_SNDMC  000B   R_SNDNC  0008   R_TTY    0006   Task       Structure                 08:56:57  Feb 29, 2020   Page   99Debug Interface Routines                            R_WRITE  0005   S        0004   SCHR     0040   SEND_DLE 0008   SEND_XOF 0004   SEND_XON 0002   SPACE    0020   SR4_IRQ  4F04   SR4_init 4F1E   SR4_name 4310   SR4_test 4F2C   SR4false 501C   SR4true  5019   SR4ttcon 4FBD   SR4ttdis 4FF2   SR4ttget 4FE8   SR4ttisc 5013   SR4ttnd  5053   SR4ttnno 5007   SR4ttnr  4FF9   SR4ttnx  5000   SR4ttnxr 4FEB   SR4ttput 4FE5   SR4ttstb 501F   SR4ttstc 5030   SR4ttstd 5050   SR4ttste 504B   SR4ttstr 5039   SR4ttsts 503F   SR4ttstx 5045   SR4ttwct 5054   SR4ttwdc 505E   SR4ttxbs 500E   SYS_ACIA 8000   SYS_TABS 02B8   TABCH    0009   TFREE    0004   TIMOUT   0001   TIQPRI   FFD8   TI_HAN   455F   TI_Q     011A   TI_Q_ptr 012E   TOPEN    0004   TOPWOC   0010   TRANSPNT 0008   TRUN     0001   TSKSIZ   0080   TSLEEP   0002   TSYS     0005   TTYIPR   FFF6   TTYLOCK  FFDD   TTYOPR   FFEC   TTYQS    027E   TTYSIZ   001F   TTYSPR   FFE2   TTYTABS  027C   TWAIT    0003   U        0003   USTSIZ   006C   V        0007   W        0006   X        0001   XANY     0020   XOFFC    0013   XOF_SENT 0010   XONC     0011   XONXOF   0040   XTABS    0004   Y        0002   bad_cmd  4458   bad_dev  447B   brbupr   4EFC   brbutb   02B6   brr      0002   cbchrs   0002   cbstrt   0000   cbufct   0117   cfreel   0115   change   4602   chproc   0114   clcnt    0000   clfst    0001   clini2   424D   clinit   4245   cllst    0003   clock_ti 0137   close_tt 4DD3   cpu_iop  0004   cpu_iop1 0005   cpu_iop2 0006   cpu_iop3 0007   cpu_iopF 00FF   csr      0000   dbuf     0001   dev_addr 0000   dev_brbu 0004   dev_brmk 0006   dev_spar 0007   dev_tab  028A   dev_type 0002   end_vars 2FFF   fifo     0010   fifo_cnt 0008   fifo_get 0009   fifo_put 000B   fio_msg  434A   fio_rese 4319   fio_resp 4388   fio_star 407F   fio_wait 432D   flushi   4C77   flusho   4C4C   flusht   4C24   fluso0   4C53   fluso1   4C5B   get_oq   47D9   getc     473B   getc1    4756   getc2    4764   getc3    4778   getc4    477D   getjo1   464A   getjo2   4659   getjo4   4660   getjo6   4669   getjo8   466B   getjob   4644   hst_cmd  0000   hst_seq  0001   hst_tty  0002   hst_val  0003   hstbuf   0238   hstptr   0278   idle     0119   int_all  4539   int_buf  0131   int_ptr  0135   iop_cpu  0000   iop_cpu1 0001   iop_cpu2 0002   iop_cpu3 0003   iop_cpuF 00FE   jobpri   0113   lcbuf    0118   lcht     4B1F   makrd6   46C3   makrdy   46AE   mod_name 0002   mod_tbl  430A   mod_type 0000   no_dev   4230   open_tty 4DCD   oq_buf   0002   oq_count 0000   oq_end   0008   oq_get   0006   oq_put   0004   prcbuf   0138   put_oq   47FD   putc     4783   putc1    47A1   putc2    47C4   putc3    47D1   putc4    47D3   putru1   4682   putru2   4689   putru4   4697   putru5   46A6   putru6   46AA   putrun   4675   read_dat 4D8A   req_read 4D62   req_writ 4DD9   rom_bad  40B5   rom_firq 4088   rom_init 405A   rom_int  40AA   rom_nmi  4082   rom_swi  408F   rom_swi2 4095   rom_swi3 409C   rom_trap 40A3   rsche2   4619   rsche3   462D   rsched   4608   runlst   010B   send_TI  459D   send_int 4E93   set_tabl 40F9   sleep    46E8   sleep7   4710   slot_tbl 0106   slplst   010D   stbinit  40C4   sto_chk  4237   swtchu   4639   sys_vars 0100   taddr    0006   tbaud    000F   tbaud2   0010   tbksp    000D   tcncl    000E   tcolm    000C   tdel     000B   tdelay   0009   tdevic   000A   tflags   0008   tintr    48A5   tintr2   48D3   tintr3   48DB   tintr4   48E9   tintr5   48F1   tintr6   48F9   tintr7   4901   tintr8   4908   tintr9   4921   tlock    0014   tqin     0000   tqout    0004   tqproc   0002   tregs    0017   tscmd    000A   tsdev    0008   tsevnt   0006   tskend   0284   tskinit  42B6   tsktab   0282   tslink   0000   tsold    0015   tsprir   0005   tsseq    000B   tssgnl   0009   tsslnk   0002   tsstat   0004   tstate   0011   tstate2  0012   tstate3  0013   tstval   000D   ttcls    4868   ttdop5   4843   ttdop6   484E   ttdopn   482B   ttftab   488E   ttopn    4816   ttopn8   4823   ttyget   49BC   ttyi25   4B43   ttyi27   4B46   ttyi33   4B58   ttyi34   4B60   ttyi35   4B6F   ttyi36   4B73   ttyi44   4B81   ttyi46   4B8C   ttyi65   4BDB   ttyi67   4BE5   ttyi85   4C1D   ttyin    4B2A   ttyin0   4B32   ttyin2   4B36   Task       Structure                 08:56:57  Feb 29, 2020   Page  100Debug Interface Routines                            ttyin3   4B49   ttyin4   4B7B   ttyin5   4BB7   ttyin6   4BC5   ttyin7   4BE7   ttyin8   4C03   ttyin9   4C23   ttyinit  4267   ttyo12   4A8A   ttyo14   4A9A   ttyo22   4AB7   ttyo23   4ABB   ttyo24   4ACC   ttyo75   4AEF   ttyo77   4AFD   ttyoe1   4B1E   ttyou2   4AA5   ttyou4   4AD0   ttyou6   4AE1   ttyou8   4B0B   ttyoue   4B11   ttyout   4A73   ttyren   4A0E   ttys45   49E0   ttys55   4A59   ttyset   4926   ttysg5   49E2   ttyst    4A26   ttyst1   4A39   ttyst15  4A42   ttyst2   4A53   ttyst6   4A5A   ttyst65  4A65   ttyst9   4A6D   ttywrt   4DB0   umark0   0010   umark1   0012   usp      000E   utask    0111   wakeu2   46CF   wakeu3   46D6   wakeu4   46DA   wakeu5   46DC   wakeup   46C4   write_da 4E21   wrt_sc   4E5F   xmtint   471D   xtca32   4D07   xtca33   4D18   xtp315   4D00   xtpr21   4CBF   xtpr22   4CC7   xtpr25   4CDF   xtpr31   4CEB   xtpr45   4D38   xtprc0   4CA2   xtprc1   4CAC   xtprc2   4CB3   xtprc3   4CE1   xtprc4   4D24   xtprc5   4D48   xtprc6   4D52   xtprc7   4D5D   xtprcq   4C8A   