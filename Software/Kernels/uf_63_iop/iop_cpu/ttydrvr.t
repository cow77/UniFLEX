          sttl    Terminal   Drivers          pag** The routines in this file make up the main system* terminal drivers.  Most of the work is actually* performed by other internal routines.*** ttopn** Open a terminal for use.  On entry, D has* the device number.*ttopn     pshs    d          save device number          bsr     ttftab     get table address          lda     tstate,x   get states          bita    #TOPEN     is it already open?          bne     ttopn8          bsr     ttdopn     do actual openttopn8    ldy     taddr,x    point to device          jsr     [D_ttenr,u] enable rcv interrupts          puls    d,pc       return** ttdopn** Do actual terminal open.  X points to tty entry.*ttdopn    ldy     taddr,x    get device address          clr     tstate3,x10        jsr     [D_ttconf,u] configure the port* response of NE implies open OK* if EQ then blocked by CTS if Carry is 0          bne     ttdop6     is it ready?          bcs     ttdop5     branch if blocked by DCD          pshs    cc,x,y     save regs          seti    mask       ints          jsr     [D_ttwcts,u] wait for CTS          puls    cc,x,y     reset regs          bra     ttdopn     repeat openttdop5    pshs    cc,x,y     save regs          seti    mask       ints          jsr     [D_ttwdcd,u] wait for DCD          puls    cc,x,y     reset regs          bra     ttdopn     repeat openttdop6    lda     #ECHO|XTABS|CRMOD|BSECH          sta     tflags,x   setup initial mode          lda     #BSPCH     get backspace char          sta     tbksp,x    save in table          lda     #CNCLC     get cancel character          sta     tcncl,x    save in table          lda     tstate,x   set OPEN flag          ora     #TOPEN     set open status          sta     tstate,x   save in table          lda     #DSR_OK    allow transmitting          sta     tstate2,x          rts     return          pag** ttcls** Close the terminal whode device number is in D.*ttcls     bsr     ttftab     find table entry          lda     tstate,x   was the port actually open?          bita    #TOPEN          beq     10f        no - skip flush          anda    #!TOPEN    yes - clear bit          sta     tstate,x   ... so we don't get hung up ...          lbsr    flusho     flush out buffers          ldy     taddr,x    get device address          jsr     [D_ttenno,u] close down the port10        lda     tstate,x   clear state bits          anda    #PROTOCOL  preserve protocol flags          sta     tstate,x          clr     tstate2,x          clr     tstate3,x          rts** ttftab** Find tty table entry associated with device in D.* Exit with entry pointed at by X.* Also compute device handler table in U.*ttftab    pshs    d          ldx     TTYTABS    point to table          lda     #TTYSIZ    set size up          mul                calculate  offset          leax    d,x        point to entry          puls    d          ldu     #dev_tab          lda     #DEV_SIZE          mul          leau    d,u          ldu     dev_type,u get handler table address          rts     return          pag** tintr** TTY interrupt handler.  Determine if the interrupt* is a receive or transmit one and take appropriate* actions.*tintr     bsr     ttftab     calculate table addresses          ldy     taddr,x    get device address01        pshs    y          save port address          ldd     4,s        fetch device status (if present)          jsr     [D_tttstb,u] test for break interrupt          bne     tintr5          jsr     [D_tttstc,u] test drop carrier int          bne     tintr6          jsr     [D_tttstr,u] test for rcv int          bne     tintr2          jsr     [D_tttsts,u] test CTS change interrupt          bne     tintr9          jsr     [D_tttstx,u] test for xmit int          bne     tintr3          jsr     [D_tttstd,u] test dsr change          bne     tintr8          jsr     [D_tttste,u] test error int          bne     tintr7     ** should be 7? **          bra     tintr9tintr2    jsr     [D_ttgetc,u] get character from port          jsr     ttyin      go buffer char          bra     tintr9tintr3    jsr     ttyst      go output another char          ldd     [tqout,x]  check queue count          beq     tintr4          cmpd    OQLO       low water mark?          bne     tintr9tintr4    ldy     tqout,x    get output queue          jsr     wakeup          bra     tintr9tintr5    ldd     #INTS      set INT interrupt          jsr     send_TI    send interrupt          bra     tintr9tintr6    ldd     #HANGS     set hangup unt          jsr     send_TI    send interrupt          bra     tintr9tintr7    ldb     #$07       set bell char          jsr     ttyin      go buffer it          bra     tintr9     exittintr8    lda     tstate2,x  get state          bita    #DSR_OK    was it OK to send before?          beq     85f        no - must be now          anda    #!DSR_OK   don't allow any sending          sta     tstate2,x          jsr     [D_ttdisx,u] disable transmitter          bra     tintr9     exit85        ora     #DSR_OK    allow transmitting          sta     tstate2,x          jsr     ttyren     restart transmissiontintr9    puls    y          restore port address          jmp     [D_ttend,u] clean up the port & return          pag** ttyset/ttyget** Handle the actual get or put of data for ttyset* and ttyget.*ttyset    lbsr    ttftab     get tty table address* U=dev_tab#, X=tty_table#, Y=DEV_XXXX          lbsr    FIFOgeta   move data from FIFO       (1)          ldb     tflags,x   save current flags          sta     tflags,x   set flags          bitb    #RAW|SCHR  currently in RAW or Single Character mode?          bne     10f        yes - no change          bita    #RAW|SCHR  going to one of those modes?          beq     10f        no - continue          tst     [tqin,x]   any unsolicited input?          beq     00f        no - continue          tst     tdel,x     any delimiters?          beq     00f          inc     tdel,x     force a delimiter00        bita    #RAW       going into RAW mode?          beq     10f        no          lda     tstate,x   yes - no HOLD processing in RAW mode          bita    #HOLD      currently holding?          beq     10f        no - continue          anda    #!HOLD          sta     tstate,x          bsr     ttyren     kick output10        lbsr    FIFOgeta   move data from FIFO       (2)          sta     tdelay,x   set delays          lbsr    FIFOgeta   move data from FIFO       (3)          sta     tcncl,x    set cancel char          lbsr    FIFOgeta   move data from FIFO       (4)          sta     tbksp,x    set back space char          lbsr    FIFOgeta   move data from FIFO       (5)          anda    #$7F          sta     tbaud,x    set bauds          lbsr    FIFOgeta   move data from FIFO       (6)          pshs    a          anda    #PROTOCOL  save protocol bits          pshs    a          lda     tstate,x   update state          anda    #(!PROTOCOL)&$FF clear current bits          ora     ,s+        set new bits          sta     tstate,x          puls    a          anda    #$0F       get baud rate          pshs    a          lda     tbaud2,x   update baud rate          anda    #$F0          ora     ,s+          sta     tbaud2,x*          lda     [dev_brbu,u]          ldb     dev_brmk,u          cmpb    #$0f          beq     01f          anda    #$0f          bra     02f01        anda    #$f0          pshs    a          lbsr FIFO_geta                                (7)          ldb     dev_brmk,u          cmpb    #$0f          beq     03f          lsla          lsla          lsla          lsla03        ora     0s,+          sta     [dev_brbu,u]          ldx     dev_addr,u          sta     brr,x*          lbsr FIFO_geta                                (8)          ldb     #R_TTY     return TTYSET OK          rts     returnttyget    lbsr    ttftab     get table address* U=dev_tab#, X=tty_table#, Y=DEV_XXXX          lda     tflags,x   get flags byte          lbsr    FIFOputa   put data into FIFO             (1)          lda     tdelay,x   get delays          lbsr    FIFOputa   put data into FIFO             (2)          lda     tcncl,x    get cancel char          lbsr    FIFOputa   put data into FIFO             (3)          lda     tbksp,x    get b.s. char          lbsr    FIFOputa   put data into FIFO             (4)          lda     tbaud,x    get bauds          anda    #$7F          tst     tdel,x     check delimiter count          bne     ttys45          tst     [tqproc,x] any chars in processed queue?          beq     ttysg5ttys45    ora     #%10000000 set del bitttysg5    lbsr    FIFOputa   put data into FIFO             (5)          lda     tstate,x   return protocol bits          anda    #PROTOCOL          pshs    a          lda     tbaud2,x   get baud rate          anda    #$0F          ora     ,s+          lbsr    FIFOputa   put data into FIFO             (6)*          ldb     dev_brmk,u          lda     [dev_brbu,u]          cmpb    #$0f          beq     01f          lsra          lsra          lsra          lsra01        lbsr    FIFOputa                                  (7)          lda     #$ff          lbsr    FIFOputa                                  (8)          ldb     #R_TTY     response = TTYGET = OK          rts     return