          lib     ./environment.h          opt     nol          lib     ../include/macdefs.h          lib     ../include/inttab.h          lib     ../include/task.h          lib     ../include/tty.h          lib     ../include/sysdefs.h          opt     lis          lib     ../include/fio.h          lib     ../include/fio_codes.h          sttl    IOP        Interface          pag          global  NUM_TRM,NUM_TSK* keep this at zero if you share normal serial ports with IOP portsACT_COST  set     0          Activity cost for IOP transaction          data          global  iop_open,iop_close,iop_write,iop_read,iop_spcl          global  iop_wait,strm4iop,fio_int* during intialistation strm is added with # of iop ttys'* when initialisation is done strm is restoredstrm4iop  fcb     0          original strm value (tty on CPU)iop_wait  fcb     0          Count of tasks waiting for IOP access (global)*          lib     ./fio_sim.t** fio_int - Process IOP interrupt, testing for INT already reset the IRQ*   U - FIO address*   Y - IOP Control structure*fio_int   pshs    x,y          ldx     iop_dba,y  X - dual port RAM address          lda     iop_cpu2,x move transaction data (interrupt#)          pshs    a          -- Transaction specific value          clr     ,-s        ** Filler **          lda     iop_cpu1,x                       (terminal#)          pshs    a          -- Sequence #          lda     iop_cpu,x                        (response)          pshs    a          -- Response code          clr     iop_cpuF,x indicate message received** stack contains resp code, seq#, fil, data, x ,y*          lda     0,s        get response code          cmpa    #R_INTRPT          bne     10f** handle INTERRUPT form tty*05        ldb     1,s        relative terminal #          jsr     find_dn    compute absolute terminal #          ldx     ttytab     compute TTY table address          lda     #TTYSIZ          mul          leax    d,x          clra          ldb     3,s        get interrupt code          jsr     intrpt send interrupt to this terminal          leas    4,s        clean up stack          bra     99f        exit** 0,s - response code* 1,s - sequence #* 3,s - transaction specific returned value*10        leay    iop_tran,y point to transaction list          ldb     #MAX_TRAN   # transactions          pshs    b15        lda     2,s        check transaction #          beq     16f        empty?          cmpa    tran_seq,y match?          beq     20f        yes - go*16        leay    TRAN_SIZ,y next transaction          dec     0,s        any more?          bne     15b* -- Unsolicited response!          leas    5,s        clean up stack          bra     99f        exit*20        puls    b          clean up stack          lda     0,s        get response code          sta     tran_resp,y save response code          lda     3,s        get response value          sta     tran_val,y          leas    4,s        clean up stack          jsr     wakeup     wake up sender99        puls    x,y,pc     return** fio_msg - Send a value via the FIO Mailbox & wait for response*   U - maj/min*   D - Value to send (B = Command, A = Specific data)*   Y - IOP control block*   jsr fio_msg*   D - Value returned (B = Error response, A = Specific data)*fio_msg   pshs    cc,d,x,y,u save registers* -- Find an empty transaction box10        seti               turn off interrupts          ldy     5,s        get IOP control address          jsr     MBX_lock   get access to IOP          lbsr    find_slot  go find a slot          beq     15f        jump if one found*          ldy     5,s        restore IOP structure pointer          jsr     MBX_unlock give up IOP until slot available          lbsr    find_slot  make sure no slots available          beq     10b        jump if there is one*          ldy     5,s        get IOP pointer          leay    iop_tflg,y sleep on transaction slots          ldb     #IOPPRI          jsr     Q_sleep    wait for available message slot          bra     10b        try for a transaction slot*15        ldb     utask+1    set sequence # in slot ???          orb     #1          stb     tran_seq,y          ldb     0,s        enable (old) interrupts          tfr     b,cc          pshs    y          save transaction slot pointer          ldb     4,s        restore message code (B)          lda     3,s        restore specific data (A)          exg     d,u          lda     utask+1          ora     #1         set sequence #          stb     tran_dev,y   minor device          exg     d,u          sta     tran_oval,y                         (A)          stb     tran_msg,y                          (B)          ldy     7,s        restore IOP structure pointer          lbsr    fio_send          jsr     MBX_unlock release mailbox*20        puls    y          get transaction slot address          seti               mask interrupts          tst     tran_resp,y any response yet?          bne     30f        yes - go process*          ldx     5,s        get IOP control address          ldd     iop_fifo,x does this task own the FIFO?          bne     25f        yes - don't allow interrupts!*          pshs    y,u        save registers          ldd     umark1     set up to allow interruptable sleep          pshs    d          ldx     #27f       interrupt handling label          pshs    x          sts     umark1          ldb     #TTYIPR    set interruptable priority          jsr     A_sleep    wait for IOP response          puls    d,x,y,u    restore registers          stx     umark1     restore interrupt point          bra     30f        continue*27        puls    x,y,u      Interrupt happened! - (D) already popped          stx     umark1     restore stack mark          lda     #E_ABORT   aborted transaction!          sta     tran_resp,y          ldb     #O_INTRPT          pshs    y          save transaction slot pointer          ldy     7,s        restore IOP control pointer          jsr     MBX_lock   get access to mailbox          jsr     fio_send          jsr     MBX_unlock release mailbox          puls    y          restore transaction slot pointer          bra     30f*25        ldb     #IOPPRI          pshs    x,y,u      save registers          jsr     A_sleep          puls    x,y,u      restore registers*30        ldx     utask          seti               turn off interrupts while fiddling with transaction slots* -- See if there is a response.  It is possible to* -- get here without one if an interrupt happened which* -- was being ignored.  In this case, the IOP doesn't* -- need to be notified of any interrupt, but we must* -- wait for the IOP response to actually arrive.          ldb     tran_resp,y get response code          bne     35f        jump if response present*          pshs    y          reset stack          bra     20b        wait for response*35        clra               release transaction slot          sta     tran_seq,y          clr     tran_resp,y          lda     tran_val,y get response value          std     1,s        set return value (resp val,resp. code)          ldy     5,s        wake anybody waiting for this slot          leay    iop_tflg,y          jsr     wakeup          lda     2,s        interrupted transaction?          cmpa    #E_ABORT          bne     50f        no - continue*          lds     umark1     yes - get out          rts*50        puls    cc,d,x,y,u,pc return** find_slot - find a transaction slot*   Y - IOP control address*   jsr find_slot*   Y - Transaction slot*   <NE> if none available*find_slot pshs    d,y      save register          leay    iop_tran,y point to transactions          ldb     #MAX_TRAN          pshs    b          beq     40f* look for OUR slot first10        lda     utask+1    check for busy entries          ora     #1          cmpa    tran_seq,y          beq     30f        yes - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     10b*          ldy     3,s        restore IOP pointer          leay    iop_tran,y point to transactions          ldb     #MAX_TRAN          stb     0,s          beq     40f* next search free slot20        lda     tran_seq,y entry busy?          beq     30f        no - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     20b*40        lda     #1         return NE - no slot          bra     99f*30        sty     3,s        return slot          clra               return EQ - slot found*99        leas    1,s        remove counter          puls    d,y,pc     clean stack & return**  get_F_S - Allocate a transaction slot and the FIFO*    Y - IOP control*get_F_S   pshs    cc,d,x,y,u save registers          seti    mask       interrupts          jsr     find_slot  allocate transaction slot          beq     10f        jump if one found*          ldy     5,s        wait for slot          leay    iop_tflg,y          ldb     #IOPPRI          jsr     Q_sleep          puls    cc,d,x,y,u restore registers          bra     get_F_S    try again*10        ldb     utask+1    "allocate" slot          orb     #1          stb     tran_seq,y          puls    cc,d,x,y,u restore interrupts/registers          jmp     FIFO_lock  lock FIO access** iop_open - Open a terminal on the IOP*   D = Device #*iop_open  pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcc     00f        jump if OK to open*          bra     14f*          ldb     #TTYOPR    hang up task          ldy     iop_open   ** this will never happen! **          jsr     sleep*00        pshs    d,y,u      save IOP parameters*05        ldb     #O_OPEN    send "open device" request          jsr     fio_msg          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     10f*          jsr     p_iop_bsy  print message          bra     05b*10        tstb          bpl     15f*14        lda     #EBDEV     yes - return error          sta     uerror          bra     20f*15        ldy     utask      set controlling terminal          ldd     tstty,y          bne     20f        jump if already set*          ldb     7,s         is this a terminal?          subb    #IOPTDMIN          cmpb    IOP0BASE+NUM_TRM    CPU tty's + IOP tty's          bhs     20f         no - don't screw up the tables          ldb     7,s         renew B*          ldx     ttytab     compute "TTY" table address          lda     #TTYSIZ          mul          leax    d,x          stx     tstty,y    set controlling terminal          ldd     6,s        restore device #          std     tdevic,x   set fake entry in TTY table20        puls    d,y,u      clean up stack*99        puls    d,x,y,u,pc** iop_close - Close a terminal at the IOP*iop_close pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcs     99f        jump if error          pshs    d,u,y      save IOP parameters*00        ldb     #O_CLOSE   send "close device" request          jsr     fio_msg          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     10f*          jsr     p_iop_bsy  print message          bra     00b*10        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** iop_write - Write data to a terminal on the IOP*iop_write pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcs     99f        jump if error*          pshs    d,u,y      save IOP parameters Y - IOP control*00        ldd     uicnt      any data left?          beq     90f        no - exit*          cmpd    #1         single character write?          beq     50f        yes - special case*          ldb     #O_RQWR    send "request write data" request          jsr     fio_msg          cmpb    #E_IOERR   I/O Error? (possible on printers)          beq     80f*          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     05f*          jsr     p_iop_bsy  print message          bra     00b*05        jsr     get_F_S    allocate FIFO and a transaction slot          lda     #0         start queueing characters*10        pshs    a,x,y,u    save registers          lbsr    cpass      get character          puls    a,x,y,u    restore registers          bmi     20f        jump if no more*          jsr     FIFO_put   place character in FIFO          inca               update count          cmpa    #FIFO_SIZE          bne     10b*20        tsta               anything in FIFO?          beq     30f        no - exit*25        ldb     #O_WRITE   set Write code          jsr     fio_msg    signal IOP          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     27f*          jsr     p_iop_bsy  print message          bra     25b*27        jsr     FIFO_unlock release interlock          bra     00b        continue*30        jsr     FIFO_unlock release FIFO          bra     90f        exit* -- Special case for single character write50        pshs    x,y,u      save registers          lbsr    cpass      fetch character from user          puls    x,y,u      restore registers          lda     #O_WRC     write single character          exg     a,b        a=data, b=command          jsr     fio_msg    issue command          cmpb    #E_IOERR          bne     90f*80        lda     #EIO       some sort of I/O error          sta     uerror*90        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** iop_read - Read data from a terminal at the IOP*iop_read  pshs    d,x,y,u          lbsr    iop_fdv    get IOP params          lbcs    99f        exit if error*          pshs    d,y,u      save IOP params*00        ldd     uicnt      how many more characters needed          beq     90f        exit if none*          ldb     #O_RQRD    inform IOP we need data          jsr     fio_msg          cmpb    #R_RD1C    single character returned?          beq     50f        yes - go process it*          jsr     get_F_S    allocate FIFO          ldd     uicnt      how much data to read?          cmpd    #FIFO_SIZE can move no more than FIFO          blo     05f*          ldd     #FIFO_SIZE*05        tfr     b,a        set request max size          ldb     #O_SEND    tell IOP to send data          pshs    a          save size of request          jsr     fio_msg          cmpa    #0         EOF?          beq     20f        yes - go process it*          pshs    a,b        save input count, response type*10        pshs    a,x,y,u    save registers          jsr     FIFO_get   get character          lbsr    passc send to user          puls    a,x,y,u    restore registers          deca    any        more this load?          bne     10b        yes - go get 'em*          jsr     FIFO_unlock & release it to world          puls    a,b        a=size returned, b=response code          cmpa    ,s+        less than requested amount          bne     90f        exit if not the same (must be less)*          cmpb    #R_SNDMC   Make sure there are more chars available          beq     00b*          bra     90f        exit* -- IOP returned EOF20        jsr     FIFO_unlock          puls    a          clean up stack          bra     90f        exit* -- Single character returned50        tfr     a,b        get character          pshs    x,y,u      save registers          lbsr    passc move to user          puls    x,y,u      restore registers90        puls    d,y,u      clean up stack* -- Try to even loading          ldy     utask          clr     tsact,y* --99        puls    d,x,y,u,pc** the transfer IS 8 bytes, only 6 bytes are used for ttyset/ttyget* the last two bytes are used to pass baudrate info* iop_spcl - Perform TTYSET/TTYGET for an IOP terminal* D = maj/min* X - =0 if doing ttyset*    <>0 if ttyget*iop_spcl  pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcs     99f        jump if error*00        pshs    d,y,u      save registers          jsr     get_F_S    allocate FIFO and a transaction slot          ldx     6+2,s      get ttyset/get parameter          cmpx    #0         ttyset?          bne     50f        no - do ttyget* SET          ldd     6,s        device major/minor          jsr     tspdiopd   get vars address          cmpx    #$ffff     invalid,          beq     02f        return 00          ldd     0,x        get data02        std     usarg3*          lda     #8         move ttyset data into FIFO          ldx     #usarg0*10        ldb     ,x+        move data          jsr     FIFO_put   into FIFO          deca          bne     10b*          ldx     #usarg0     from          ldd     6,s        device major/minor           bsr     ttyshad    shadow values in tty tables*10        ldb     #O_TTYS    send "ttyset" request          jsr     fio_msg          bra     90f        exit* GET50        ldb     #O_TTYG    send "ttyget" request          jsr     fio_msg*          pshs    x*          lda     #6         move data from FIFO into buffer60        jsr     FIFO_get   get data from FIFO          stb     ,x+          deca          bne     60b*          puls    x          ldd     6,s        device major/minor          bsr     ttyshad    set shadow registers*          ldd     6,s        device major/minor          jsr     tspdiopd   calculate vars address          cmpx    #$ffff          beq     90f        invalid, skip          jsr     FIFO_get          pshs    b          jsr     FIFO_get          puls    a          std     0,x*90        jsr     FIFO_unlock release FIFO buffer          puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** D=maj/min, X = src* ttyshad, save ttyset/get values in tty tables*ttyshad   equ     *          pshs    d,x,y          ldy     ttytab          lda     #TTYSIZ          mul          leay    d,y          ldd     0,x          stb     tdelay,y*         sta     tflags,y          ldd     2,x          sta     tcncl,y          stb     tbksp,y          ldd     4,x          anda    #$1c       config bits          sta     tbaud,y          andb    #HLDBTS          pshs    b          ldb     tstate,y          andb    #(!HLDBTS)&$ff    clear hold processing bits          orb     0,s+*         stb     tstate,y          puls    d,x,y,pc** findBRG - Find Baud rate generators*findBRG   rts** MBX_lock - Lock the IOP interface*    Y - IOP Control address*MBX_lock  pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     iop_mbx,y  mailbox already locked?          beq     10f        no - go check FIFO*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     iop_fifo,y FIFO locked?          beq     50f        no - go lock mailbox*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        inc     iop_wait          ldb     #IOPPRI          pshs    y          preserve register          jsr     Q_sleep    yes - sleep until available          puls    y          restore register          dec     iop_wait          puls    cc,d,x,y,u restore environ          bra     MBX_lock   try again*50        ldd     tstid,x    lock mailbox          std     iop_mbx,y          clr     iop_int,y  no missed interrupts*99        puls    cc,d,x,y,u,pc return** MBX_unlock - unlock the IOP interface**    Y - IOP Control address*MBX_unlock pshs    cc,d,x,y,u          seti    turn       off interrupts          lda     iop_int,y  did we miss an interrupt?          beq     05f        no - continue*          jsr     fio_int    yes - pretend we're seeing it now!*05        clr     iop_int,y  reset flag          ldd     #0          std     iop_mbx,y  reset lock          jsr     wakeup     wake up anybody waiting on this IOP          ldy     5,s        restore pointer          lda     iop_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** FIFO_lock - Lock the IOP FIFO buffer*    Y - IOP Control address*FIFO_lock pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     iop_fifo,y FIFO locked?          beq     10f        no - go check mailbox*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     iop_mbx,y  mailbox already locked?          beq     50f        no - go lock FIFO*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        ldb     #IOPPRI          inc     iop_wait   mark somebody waiting          pshs    y          save pointer          jsr     Q_sleep    yes - sleep until available          puls    y          restore pointer          dec     iop_wait          puls    cc,d,x,y,u restore environ          bra     FIFO_lock  try again*50        ldd     tstid,x    lock FIFO          std     iop_fifo,y*99        puls    cc,d,x,y,u,pc return** FIFO_unlock - unlock the IOP FIFO buffer**    Y - IOP Control address*FIFO_unlock pshs    cc,d,x,y,u          seti    turn       off interrupts          ldd     #0          std     iop_fifo,y reset lock          jsr     wakeup     wake up anybody waiting on this FIFO          ldy     5,s        restore pointer          lda     iop_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** Q_sleep - Sleep until event with decreased activity*Q_sleep   jmp     sleep** A_sleep - Sleep until event with no decrease in activity*A_sleep   jsr     sleep      wait for event          pshs    a,x        upgrade activity          ldx     utask          lda     tsact,x          adda    #ACT_COST          bcc     00f*          lda     #$FF*00        sta     tsact,x          puls    a,x,pc** iop_fdv - Find device info for IOP terminal*    D - device #*    jsr iop_fdv*    B - device # (0..N)*    U - Sequence #/Terminal #*    Y - FIO interlock*    <Carry> if illegal device #*iop_fdv   pshs    d          save device #          subb    #IOPTDMIN          bmi     98f          cmpb    IOP0BASE+NUM_TRM          bhs     98f          stb     1,s        put corrected value          ldu     0,s        get device code          ldy     #IOP0          clc     no         error99        puls    d,pc       return*98        sec                error          puls    d,pc** find_dn - compute device # for a terminal on an IOP*   B - relative device #*   Y - IOP control address*   jsr find_dn*   D - absolute device #*find_dn   pshs    d,x,y,u    save registers          clra          addb    #IOPTDMIN          std     0,s        set return value          puls    d,x,y,u,pc return*p_iop_bsy pshs    d,x,y,u          ldx     #00f          jsr     Pdata          ldx     #$FFFF10        leax    -1,x          bne     10b*99        puls    d,x,y,u,pc*00        fcc     $d,'IOP Saturated!',0