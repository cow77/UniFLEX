  0000                         absSWTPc      Intelligent I/O Proce     14:06:02  Mar 21, 2020   Page    1Hardware   Definitions                                                                                                                  *       lib ../include/sysdefs.h                     *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100               0F3F  DEBUG_CONTROL set %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0001  DO_HISTORY set   1         Include transaction history mechanism               0000  DO_IXON   set    0         Include Input XON/XOFF Handshaking                                          * Character Constants                                    0003  INTRC     equ    $03       DEL character               0004  EOTCH     equ    $04       EOT character               007F  BSPCH     equ    $7f       back space character               0009  TABCH     equ    $09       tab character               000A  NL        equ    $0A       Line Feed               000D  CR        equ    $0D       Carriage Return               0010  DLE       equ    $10       Data Link Escape (DLE)               0013  XOFFC     equ    $13       XOFF character               0011  XONC      equ    $11       XON character               0018  CNCLC     equ    $18       line cancel char               001B  HOLDC     equ    $1B       ESC - suspend output               001C  QUITC     equ    $1C       FS character               0020  SPACE     equ    $20       space character                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFF6  TTYIPR    equ    -10       Waiting for terminal input               FFEC  TTYOPR    equ    -20       Waiting for terminal output - in ttywrt               FFE2  TTYSPR    equ    -30       Waiting for space in output Q - in req_writeSWTPc      Intelligent I/O Proce     14:06:02  Mar 21, 2020   Page    2Hardware   Definitions                                             FFDD  TTYLOCK   equ    -35       Waiting for access to TTY table               FFD8  TIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIO               FFC4  CLOCKPR   equ    -60       Waiting for a clock tick                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)                                          * -- Configuration constants                                    000A  MAX_TI    equ    10        # Queued terminal interrupts               0004  MAX_TTY   equ    4         # terminal devices               0000  MAX_PPR   equ    0         # printer devices               0000  MAX_NEC   equ    0         # NEC printers               007C  MAX_CL    equ    124       upper limit on # CLISTS               0400  MAX_OB    equ    8*128     upper limit on output buffer size               0120  MIN_OB    equ    (2*128)+32 lower limit on output buffer size               0028  MAX_TSK   equ    40        52 upper limit on # of tasks               0020  MIN_TSK   equ    32        lower limit on # of tasks                     *               0005  MAX_DEV   equ    MAX_TTY+MAX_PPR+MAX_NEC+1 (Includes TOD clock)                     *               0100  PRCSIZ    equ    256               00FE  CHRLIM    equ    PRCSIZ-2  max chars in buffer                     SWTPc      Intelligent I/O Proce     14:06:02  Mar 21, 2020   Page    3Macro Definitions                                                                             *                     * This file contains all macro definitions                     * used in the system.                     *                                    0040  FF        equ    %01000000 FIRQ interrupt mask               0010  IF        equ    %00010000 IRQ interrupt mask                                          * register references               0000  D         equ    0               0001  X         equ    1               0002  Y         equ    2               0003  U         equ    3               0004  S         equ    4               0005  PC        equ    5               0006  W         equ    6               0007  V         equ    7               0008  A         equ    8               0009  B         equ    9               000A  CC        equ    10               000B  DP        equ    11               000E  E         equ    14               000F  F         equ    15                                                               *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #FF|IF                               endm                                                               *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(FF|IF)                               endm                                                               SWTPc      Intelligent I/O Proce     14:06:03  Mar 21, 2020   Page    4Macro Definitions                                                                             *                     * lsr a 4 times and increment it                     * used in taskcon.t                     *                                          lsr4p     macro  no        args                               lsra                               lsra                               lsra                               lsra                               inca                               endm                                                               *                     * debug macro                     *                                          dbugm     macro  output_character                               lda    #'&1                               lbsr   syspch                               endm                                          *                     * HD6309 MACRO's                     *                                          ldmd      macro                               fdb    $113d                               fcb    &1                               endm                                          ldwi      macro                               fdb    $1086                               fdb    &1                               endm                                          ldwd      macro                               fdb    $1096                               fcb    &1                               endm                                          ldwe      macro                               fdb    $10b6                               fdb    &1                               endm                                          tfm1      macro                               fdb    $1138                               fcb    &1<<4|&2                               endmSWTPc      Intelligent I/O Proce     14:06:03  Mar 21, 2020   Page    5Macro Definitions                                                                             tfm4      macro                               fdb    $113b                               fcb    &1<<4|&2                               endm                                          lsld      macro                               fdb    $1048                               endm                                          lsrd      macro                               fdb    $1044                               endm                                          negd      macro                               fdb    $1040                               endm                                          eorr      macro                               fdb    $1036                               fcb    &1<<4|&2                               endm                                          adcdi     macro                               fdb    $1089                               fdb    &1                               endm                                          incd      macro                               fdb    $104c                               endm                                          decd      macro                               fdb    $104a                               endm                                                               *                     * trfr, transfer registers                     *                     trfr      macro                               fcb    $1f                               fcb    &1<<4|&2                               endm                                          *                     * addr, add reg0 + reg1 => reg1                     *                     addr      macro                               fdb    $1030                               fcb    &1<<4|&2                               endmSWTPc      Intelligent I/O Proce     14:06:03  Mar 21, 2020   Page    6Macro Definitions                                                                             * extended addressing mode                     aime      macro                               fcb    $72                               fcb    &1                               fdb    &2                               endm                                          * extended addressing mode                     oime      macro                               fcb    $71                               fcb    &1                               fdb    &2                               endmSWTPc      Intelligent I/O Proce     14:06:03  Mar 21, 2020   Page    7Device     Table Structure                                                                    *                     * Possible module types table                     *                       0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *                       0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table  0004               dev_brbu  rmb    2         baudrate backup loc  0006               dev_brmk  rmb    1         baudrate mask  0007               dev_spar  rmb    1         spare byte                     *  0008               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device                     *                       0000                         org    $0000  0000                         rmb    2         0  0002               D_OPEN    rmb    2         1  0004               D_CLOSE   rmb    2         2  0006               D_TTYS    rmb    2         3  0008               D_TTYG    rmb    2         4  000A               D_RQWR    rmb    2         5  000C               D_WRITE   rmb    2         6  000E               D_WRC     rmb    2         7  0010               D_RQRD    rmb    2         8  0012               D_SEND    rmb    2         9  0014               D_INTRPT  rmb    2         A  0016                         rmb    2         B  0018                         rmb    2         C  001A                         rmb    2         D  001C                         rmb    2         E  001E               D_CLOCK   rmb    2         F  0020               D_inthan  rmb    2         10 Interrupt poller/handler  0022               D_init    rmb    2         11 Device initialization  0024               D_test    rmb    2         12 Test for device present                     *  0026               D_END     rmb    0         End of common handlers                     SWTPc      Intelligent I/O Proce     14:06:03  Mar 21, 2020   Page    8Device     Table Structure                                               *                     * TTY Specific device routines                     *  0026                         org    D_END  0026               D_ttconf  rmb    2  0028               D_ttputc  rmb    2  002A               D_ttgetc  rmb    2  002C               D_ttenxr  rmb    2  002E               D_ttdisx  rmb    2  0030               D_ttenr   rmb    2  0032               D_ttenx   rmb    2  0034               D_ttenno  rmb    2  0036               D_ttxbsy  rmb    2  0038               D_tttstx  rmb    2  003A               D_ttiscts rmb    2  003C               D_tttstr  rmb    2  003E               D_tttstb  rmb    2  0040               D_tttsts  rmb    2  0042               D_tttstc  rmb    2  0044               D_tttstd  rmb    2  0046               D_tttste  rmb    2  0048               D_ttend   rmb    2  004A               D_ttwcts  rmb    2  004C               D_ttwdcd  rmb    2                     SWTPc      Intelligent I/O Proce     14:06:04  Mar 21, 2020   Page    9History Queue Record Structure                                             0000                         org    0  0000               hst_cmd   rmb    1         Command  0001               hst_seq   rmb    1         Sequence #  0002               hst_tty   rmb    1         TTY #  0003               hst_val   rmb    1         Message dependent data                     *  0004               HRECSIZ   rmb    0                                          *                     * Number of history records supported                     *               0010  MAXHIST   equ    16                     SWTPc      Intelligent I/O Proce     14:06:04  Mar 21, 2020   Page   10IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0100  RAMorg    equ    $0100     28K of RAM - Thru $6FFF               6FFF  RAMend    equ    $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7F00  RAMscrend equ    $7F00               7FFF  ROMstack  equ    $7FFF     High end of ROM Stack               E000  ROMLOorg  equ    $E000     8K of ROM - $E000-$FFFF               C000  DEBUGROM  equ    $C000     8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, up to 6 IO boards                     *               8000  SYS_ACIA  equ    $8000     first ACIA in first slot               0003  SR4_SLOTS equ    3         Number of Physical CPU09SR4 I/O slots               8000  BASE_SLOT equ    $8000     Base address for I/O slots               0010  NEXT_SLOT equ    $0010     Offest between slots                                          * clock hardware               8070  CLOCK     equ    $8070     hardware clock, status and control               8071  CLOCKI    equ    $8071     interrupt resetSWTPc      Intelligent I/O Proce     14:06:04  Mar 21, 2020   Page   11IOP        Memory Layout                                                                      *                     * Clist Structure                     *                     * The clist structure is the head of a linked list of                     * characters used for i/o.  A head and tail pointer                     * are kept, as well as a character count of active                     * characters on the queue.                     *                                          * struct clist                       0000                         org    0                       0000               clcnt     rmb    1         character count  0001               clfst     rmb    2         head character pointer  0003               cllst     rmb    2         tail character pointer                     *               0005  QH_SIZE   equ    *         Size of Queue Header                                                               *                     * Clist Buffer                     *                     * The characters for i/o are placed in buffers as                     * needed.  Each buffer contains 32 bytes, the first                     * two contain a chain pointer, the next 30 hold                     * the actual characters.                     *                       0000                         org    0                                    0020  CBSIZE    equ    32  0000               cbstrt    rmb    2  0002               cbchrs    rmb    CBSIZE-2SWTPc      Intelligent I/O Proce     14:06:04  Mar 21, 2020   Page   12Output     Queue Structure                                                                    *                     * This is the definition of the output queue used                     * to buffer characters going to a terminal.  It is                     * different from the "clist" mechanism for efficiency                     * concerns.                     *                       0000                         org    0  0000               oq_count  rmb    2         Number of characters in Q  0002               oq_buf    rmb    2         Start of Q buffer  0004               oq_put    rmb    2         Address of next character to insert  0006               oq_get    rmb    2         Address of next character to consume  0008               oq_end    rmb    2         Limiting address of Q                     *  000A               OQH_SIZE  rmb    0         Size of output Queue headerTask       Structure                 14:06:04  Mar 21, 2020   Page   13Output     Queue Structure                                               *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    006C  USTSIZ    equ    108       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tsdev     rmb    1         Terminal task is servicing  0009               tssgnl    rmb    1         Signal waiting for task  000A               tscmd     rmb    1         Saved mailbox command  000B               tsseq     rmb    2         Saved message sequence #  000D               tstval    rmb    1         Saved transaction value  000E               usp       rmb    2         Saved User Stack Pointer  0010               umark0    rmb    2         Stack Frame Markers  0012               umark1    rmb    2  0014                         rmb    USTSIZ    space for per/process stack                                    0080  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system taskTask       Structure                 14:06:04  Mar 21, 2020   Page   14TTY        Structure                                                                          *                     * TTY Structure                     *                     * A tty structure is required for each character type                     * i/o device used for standard terminal i/o.                     *                                          * struct tty                       0000                         org    0                       0000               tqin      rmb    2         pointer to in q clist str  0002               tqproc    rmb    2         pointer to proccessed q clist str  0004               tqout     rmb    2         pointer to out q clist str  0006               taddr     rmb    2         device address  0008               tflags    rmb    1         mode flags  0009               tdelay    rmb    1         time out definitions  000A               tdevic    rmb    1         device name  000B               tdel      rmb    1         raw delimiter count  000C               tcolm     rmb    1         printing column  000D               tbksp     rmb    1         back space character  000E               tcncl     rmb    1         line cancel character  000F               tbaud     rmb    1         device baud rates  0010               tbaud2    rmb    1         actual baud rate (for baud rate generator)  0011               tstate    rmb    1         internal state  0012               tstate2   rmb    1         additional states  0013               tstate3   rmb    1         states of CTS,DCD  0014               tlock     rmb    1         structure lock  0015               tsold     rmb    2         amount of output queue already "sold"  0017               tregs     rmb    8         copy of device registers (for 8274)                                    001F  TTYSIZ    equ    *                                                               * modes                                    0001  RAW       equ    %00000001 raw or cooked mode               0002  ECHO      equ    %00000010 echo characters               0004  XTABS     equ    %00000100 expand tabs               0008  LCASE     equ    %00001000 map to lower case               0010  CRMOD     equ    %00010000 map NL to CR & LF               0020  BSECH     equ    %00100000 backspace echo flag               0040  SCHR      equ    %01000000 single character input               0080  CNTRL     equ    %10000000 ignore control characters                                          * internal states                                    0001  TIMOUT    equ    %00000001 timeout in progress               0002  HOLD      equ    %00000010 output suspended               0004  TOPEN     equ    %00000100 terminal has been opened               0008  TRANSPNT  equ    %00001000 Transparent modeTask       Structure                 14:06:05  Mar 21, 2020   Page   15TTY        Structure                                               0010  IXONXOF   equ    %00010000 Use XON/XOFF to control input               0010  TOPWOC    equ    %00010000 Device opened without carrier present               0020  XANY      equ    %00100000 Allow any character to break HOLD               0040  XONXOF    equ    %01000000 XON/XOFF protocol               0080  ESCOFF    equ    %10000000 Disable ESC as HOLD character                     *               00F8  PROTOCOL  equ    ESCOFF|XANY|XONXOF|IXONXOF|TRANSPNT                                    0001  DSR_OK    equ    %00000001 OK to send               0002  SEND_XON  equ    %00000010 Send XON next               0004  SEND_XOF  equ    %00000100 Send XOFF next               0008  SEND_DLE  equ    %00001000 Send DLE next               0010  XOF_SENT  equ    %00010000 We shut the other guy down               0020  DLE_SENT  equ    %00100000 DLE sequence started               0040  DLE_GOT   equ    %01000000 DLE sequence receivedTask       Structure                 14:06:05  Mar 21, 2020   Page   16Variable   Space                                                           0100                         org    RAMorg                       0100               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"  0100               OBUF_SIZE rmb    2         Size of TTY Output Queues  0102               OQHI      rmb    2         Output Queue High-water mark  0104               OQLO      rmb    2         Output Queue Low-water mark  0106               slot_tbl  rmb    2*SR4_SLOTS slot configuration                       010C               DB_iflg   rmb    1         Debug terminal initialized  010D               DB_cntrl  rmb    2         Debug control flags                     *  010F               runlst    rmb    2         Pointer to active tasks  0111               slplst    rmb    4         Pointer to waiting tasks  0115               utask     rmb    2         Currently executing task  0117               jobpri    rmb    1         Current job priority (for scheduling)  0118               chproc    rmb    1         Set if must switch users of CPU (reschedule)  0119               cfreel    rmb    2         Pointer to first free Clist buffer  011B               cbufct    rmb    1         Count of Clist buffers in use  011C               lcbuf     rmb    1         Limit on Clist buffers  011D               idle      rmb    1         idle loop flag for scheduler  011E               TI_Q      rmb    2*MAX_TI  Max Terminal Interrupts  0132               TI_Q_ptr  rmb    2         current Q pointer  0134               FIO_lock  rmb    1         FIO in use lock  0135               int_buf   rmb    4         Current Message in  0139               int_ptr   rmb    2         Message in pointer  013B               clock_tick rmb   1         Clock tick counter  013C               prcbuf    rmb    PRCSIZ    buffer for erase and kill                       023C               hstbuf    rmb    HRECSIZ*MAXHIST  027C               hstptr    rmb    2         next "put" pointer in history queue                                          * Pointers to system tables - configuration dependent  027E               CLISTS    rmb    2         Space for Clists  0280               TTYTABS   rmb    2         Terminal tables  0282               TTYQS     rmb    2         TTY Input Queue Headers  0284               OBUFRS    rmb    2         TTY Output Queues  0286               tsktab    rmb    2         Task Control Tables  0288               tskend    rmb    2         End of task table  028A               PPstr     rmb    2         Pointer to parallel device tables  028C               NECstr    rmb    2         Pointer to NEC device tables  028E               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table  02B6               NEC_IQ    rmb    2         Pointer to NEC input queue  02B8               NECADR    rmb    2         Address of NEC printer                     *  02BA               brbutb    rmb    MAX_TTY/2 baudrate latch backup table                     *  02BC               SYS_TABS  rmb    0         Start of dynamic system tables                                    6FFF  end_vars  equ    RAMend    End of System VariablesTask       Structure                 14:06:05  Mar 21, 2020   Page   17Variable   Space                                    Task       Structure                 14:06:05  Mar 21, 2020   Page   18Variable   Space                                                         *                     * ACIA Structure                     *                                          * struct acia                       0000                         org    0                                            0000               csr       rmb    1         control - status  0001               dbuf      rmb    1         data buffer  0002               brr       rmb    1         baudrate latch                                          *                     * status codes                     *               0001  AS_RDRF   equ    %00000001 receive data register full               0002  AS_TDRE   equ    %00000010 transmit data register empty               0004  AS_NDCD   equ    %00000100 DCD status bit, 1 is inactive               0008  AS_NCTS   equ    %00001000 CTS bit, 1 is inactive TX IRQ off               0010  AS_FRME   equ    %00010000 receive framing error               0020  AS_OVRN   equ    %00100000 receive overrun               0040  AS_PERR   equ    %01000000 receive parity error               0080  AS_IRQ    equ    %10000000 INT flag, 1 is active                     *                     * control codes                     *               0001  AC_DIV0   equ    %00000001 counter divide bit 0 :1/:16/:64/reset               0002  AC_DIV1   equ    %00000010 counter divide bit 1               0004  AC_WS0    equ    %00000100 word select 0 7E2/7O2/7E1/7O1               0008  AC_WS1    equ    %00001000 word select 1 8N2/8N1/8E1/8O1               0010  AC_WS2    equ    %00010000 word select 2               0020  AC_TEIN   equ    %00100000 transmit control 0  NRTS/NINT,NRTS/INTE               0040  AC_DRTS   equ    %01000000 transmit control 1  RTS/NINT,NRTS/SBRK/NINT               0080  AC_REIN   equ    %10000000 receive enable IRQ                     *               0001  AC_DV16   equ    %00000001 setting for clk/16               0003  AC_MRES   equ    AC_DIV1+AC_DIV0 master reset               0014  AC_8N1    equ    AC_WS2+AC_WS0 select for 8N1               0015  AC_SET    equ    AC_8N1+AC_DV16 ACIA default setupTask       Structure                 14:06:06  Mar 21, 2020   Page   19FIO Simulation Structure                                                                      *                     *                     * Control structure used to simulate Z8038 FIO                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     * -- As seen by Main 6809 CPU (UniFLEX)                     *                                    0080  FIFO_SIZE equ    128       Size of FIFO buffer                       0000                         org    $0000     -- Shared Dual Port RAM                                          ************************************************************  0000               iop_cpu   rmb    1         IOP -> CPU Mailbox cell  0001               iop_cpu1  rmb    1         -- Additional cell  0002               iop_cpu2  rmb    1         --  0003               iop_cpu3  rmb    1         --                     ************************************************************  0004               cpu_iop   rmb    1         CPU -> IOP Mailbox cell          message code  0005               cpu_iop1  rmb    1         -- Additional cell    sequence #  0006               cpu_iop2  rmb    1         --                    message specific data  0007               cpu_iop3  rmb    1         --                    terminal #                     ************************************************************  0008               fifo_cnt  rmb    1         Count of data in FIFO  0009               fifo_get  rmb    2         FIFO consumer pointer  000B               fifo_put  rmb    2         FIFO producre pointer  000D                         rmb    16-(*-iop_cpu) ** Filler **                       0010               fifo      rmb    FIFO_SIZE actual FIFO                       0090                         rmb    $100-(*-iop_cpu)-7                                          * IOP Configuration constants  00F9               NUM_TSK   rmb    1         Number of tasks  00FA               NUM_CL    rmb    1         Number of CLISTS  00FB               NUM_TRM   rmb    1         Number of terminals              initialized from IOP  00FC               NUM_NEC   rmb    1         Number of NEC/Qume printers  00FD               NUM_PPR   rmb    1         Number of parallel printers                     * should end up at the two top locations in the DUALPORT RAM  00FE               iop_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  00FF               cpu_iopF  rmb    1         INT + non-zero   contains info AND set IOP IRQ when written                     **************************************************************                                                         0018  MAX_TRAN  equ    24        Max # concurrent transactions / IOP                                          *                     * IOP ROM Version #                     *Task       Structure                 14:06:06  Mar 21, 2020   Page   20FIO Simulation Structure                                           0012  ROM_VERSION equ  $12       Major/Minor Version of IOP ROM                                          *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some osrt of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   equ    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)                                          *                     * Normal responses                     *               0001  R_RESET   equ    $01       System reset & functioning               0002  R_OPEN    equ    $02       Device open successful               0003  R_CLOSE   equ    $03       Device close successful               0004  R_REQOK   equ    $04       Write request now granted               0005  R_WRITE   equ    $05       Write data complete               0006  R_TTY     equ    $06       TTYSET/GET complete               0007  R_RDOK    equ    $07       Read data now available               0008  R_SNDNC   equ    $08       Read data in FIFO & no more data is available               0009  R_RD1C    equ    $09       Single character available               000A  R_INTRPT  equ    $0A       Interrupt complete               000B  R_SNDMC   equ    $0B       Read data in FIFO & there is more available               000C  R_CLOCK   equ    $0C       Interval Timer Tick               000D  R_BAUD    equ    $0D       baudrate data processed                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     *               0010  O_OPEN    equ    $10       Open device               0020  O_CLOSE   equ    $20       Close device               0030  O_TTYS    equ    $30       TTY Set               0040  O_TTYG    equ    $40       TTY Get               0050  O_RQWR    equ    $50       Request write               0060  O_WRITE   equ    $60       Write data               0070  O_WRC     equ    $70       Write single character               0080  O_RQRD    equ    $80       Request read data               0090  O_SEND    equ    $90       Send data for read               00A0  O_INTRPT  equ    $A0       Interrupt all tasks on a terminal               00B0  O_BAUDR   equ    $B0       Read baudrate settings               00C0  O_BAUDW   equ    $C0       Write baudrate settings                                          Task       Structure                 14:06:06  Mar 21, 2020   Page   21CPU        Vectors                                                         FFF0                         org    CPUtraps                       FFF0 E0A0                    fdb    rom_trap  Unused  FFF2 E099                    fdb    rom_swi3  SWI3  FFF4 E092                    fdb    rom_swi2  SWI2  FFF6 E085                    fdb    rom_firq  FIRQ  FFF8 E47B                    fdb    IRQ_han   IRQ  FFFA E08C                    fdb    rom_swi   SWI  FFFC E07F                    fdb    rom_nmi   NMI  FFFE E05A                    fdb    rom_init  Reset                     Task       Structure                 14:06:06  Mar 21, 2020   Page   22System     RESET Code                                                      E000                         org    ROMLOorg                       E000 0D 49 4F 50   DBmsg00   fcc    $d,'IOP ROM',0  E009 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  E029 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  E03D 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          *                     * System RESET code                     *  E05A 10CE 7FFF     rom_init  lds    #ROMstack initialize stack pointer  E05E                         ldmd   3                       E061 8E   0000               ldx    #0        clear all of RAM, including FIFO  E064 CC   0000               ldd    #0  E067 ED   81       10        std    ,x++  E069 8C   6FFF               cmpx   #end_vars  E06C 25   F9                 blo    10b                                           >E06E 17   0050     20        lbsr   stbinit   go initialize system memory                                            E071 10FE 0286     30        lds    tsktab    Task 0 Stack  E075 32   E9 0080            leas   TSKSIZ,s  E079 17   029A               lbsr   fio_reset                                          *                     * Initialization complete - Start executing commands                     *  E07C               fio_start                     *         ldb     #ROM_VERSION                     *         stb     iop_cpu1                     *         ldb     #R_RESET   send "system reset & running" message                     *         lbsr    fio_msg                                            E07C 7E   E605     10        jmp    rsched                     Task       Structure                 14:06:07  Mar 21, 2020   Page   23ROM        Interrupt Fielders                                              E07F 8D   26       rom_nmi   bsr    rom_int  E081 4E 4D 49 00             fcc    'NMI',0  E085 8D   20       rom_firq  bsr    rom_int  E087 46 49 52 51             fcc    'FIRQ',0  E08C 8D   19       rom_swi   bsr    rom_int  E08E 53 57 49 00             fcc    'SWI',0  E092 8D   13       rom_swi2  bsr    rom_int  E094 53 57 49 32             fcc    'SWI2',0  E099 8D   0C       rom_swi3  bsr    rom_int  E09B 53 57 49 33             fcc    'SWI3',0  E0A0 8D   05       rom_trap  bsr    rom_int  E0A2 54 52 41 50             fcc    'TRAP',0                       E0A7 8E   E0B4     rom_int   ldx    #ROM_ERR  E0AA BD   F019               jsr    DB_pdata  E0AD 35   10                 puls   x  E0AF BD   F019               jsr    DB_pdata  E0B2 20   FE       rom_bad   bra    *                     *  E0B4 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0Task       Structure                 14:06:07  Mar 21, 2020   Page   24Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  E0C1 8E   0100     stbinit   ldx    #sys_vars clear all variables  E0C4 CC   0000               ldd    #0  E0C7 ED   81       10        std    ,x++  E0C9 8C   6FFF               cmpx   #end_vars done yet?  E0CC 25   F9                 blo    10b  E0CE CC   0D04               ldd    #DEBUG  E0D1 FD   010D               std    DB_cntrl >E0D4 17   001F               lbsr   set_tables go figure out configuration, tables, etc                                          ***+++                     * Initialize history queue  E0D7 8E   023C               ldx    #hstbuf  E0DA BF   027C               stx    hstptr                     ***---                                          ***+++                     ***---                                          * Initialize Terminal Interrupt Queue  E0DD 8E   011E     15        ldx    #TI_Q     set queue empty  E0E0 BF   0132               stx    TI_Q_ptr  E0E3 8E   0135               ldx    #int_buf  reset message in pointer  E0E6 BF   0139               stx    int_ptr  E0E9 17   0156               lbsr   clinit    initialize Clists                                          ***+++                     ***---                       E0EC 17   0175     16        lbsr   ttyinit   initialize TTY tables                                          ***+++                     ***---                       E0EF 17   01C1     17        lbsr   tskinit   initialize tasks                                          ***+++                     ***---                       E0F2 17   0F42     18        lbsr   DB_config display configuration  E0F5 39                      rts                                                                                    *                     * Set up system tables                     *Task       Structure                 14:06:07  Mar 21, 2020   Page   25Table      Initialization                             E0F6               set_tables                                          ***+++                     ***---                                          * -- Force in the on-board PIA                     *09        ldd     #PIA_SLOT                     *          jsr     [D_test+DEV_L2]                     * -- Force in the TOD interface                     *          ldy     #dev_tab+((MAX_DEV-1)*DEV_SIZE)                     *          ldx     #DEV_TOD                     *          stx     dev_type,y                                                               * Compute configuration  E0F6 86   03                 lda    #SR4_SLOTS  E0F8 34   02                 pshs   a  E0FA CC   8000               ldd    #BASE_SLOT set port address  E0FD 8E   0106               ldx    #slot_tbl  E100 34   10                 pshs   x  E102 CE   E22D     10        ldu    #no_dev  E105 EF   84                 stu    0,x  E107 CE   E307               ldu    #mod_tbl  tables with module refs  E10A AE   C4       12        ldx    mod_type,u  E10C 27   0D                 beq    20f       jump if end of module table  E10E AD   98 24              jsr    [D_test,x] check for device  E111 25   04                 bcs    15f       jump if found  E113 33   44                 leau   MOD_SIZE,u  E115 20   F3                 bra    12b  E117 AE   42       15        ldx    mod_name,u  E119 AF   F4                 stx    [0,s]  E11B C3   0010     20        addd   #NEXT_SLOT advance address  E11E AE   E4                 ldx    0,s       update slot table pointer  E120 30   02                 leax   2,x  E122 AF   E4                 stx    0,s  E124 6A   62                 dec    2,s       any more slots  E126 26   DA                 bne    10b  E128 35   12                 puls   a,x                     * -- All done setting up configuration                                          ***+++                     ***---                                          * Set up constants based on configuration  E12A 86   7C       22        lda    #MAX_CL  E12C 97   FA                 sta    NUM_CL                     *                     *         lda     #MAX_TSK  E12E 86   18                 lda    #MAX_TRAN reserve for system tasks  E130 8B   04                 adda   #4  E132 97   F9                 sta    NUM_TSK                     *Task       Structure                 14:06:07  Mar 21, 2020   Page   26Table      Initialization                             E134 CC   0400               ldd    #MAX_OB  E137 FD   0100               std    OBUF_SIZE                     * Now figure out where system tables go, based on configuration  E13A FC   0100     30        ldd    OBUF_SIZE  E13D 83   000A               subd   #10  E140 FD   0102               std    OQHI  E143 83   0085               subd   #(FIFO_SIZE+5)  E146 FD   0104               std    OQLO  E149 CC   02BC               ldd    #SYS_TABS start of system tables                     * -- Round up to CBSIZE boundary  E14C C3   001F               addd   #CBSIZE-1  E14F C4   E0                 andb   #!(CBSIZE-1)  E151 1F   03                 tfr    d,u                     * -- CLISTS  E153 86   20                 lda    #CBSIZE  E155 D6   FA                 ldb    NUM_CL  E157 3D                      mul  E158 FF   027E               stu    CLISTS  E15B 17   00D6               lbsr   sto_chk   check for system table space overflow >E15E 1025 004D               lbcs   40f       jump if it happens                     * -- TTY Control tables  E162 86   1F                 lda    #TTYSIZ  E164 D6   FB                 ldb    NUM_TRM  E166 3D                      mul  E167 FF   0280               stu    TTYTABS   point to tty table  E16A 17   00C7               lbsr   sto_chk   check for system table space overflow  E16D 25   40                 bcs    40f       jump if it happens                     * -- TTY Queue headers  E16F 86   0A                 lda    #2*QH_SIZE  E171 D6   FB                 ldb    NUM_TRM  E173 3D                      mul  E174 FF   0282               stu    TTYQS  E177 17   00BA               lbsr   sto_chk   check for system table space overflow  E17A 25   33                 bcs    40f       jump if it happens  E17C 86   0A                 lda    #OQH_SIZE  E17E D6   FB                 ldb    NUM_TRM  E180 3D                      mul  E181 17   00B0               lbsr   sto_chk   check for system table space overflow  E184 25   29                 bcs    40f       jump if it happens                     * -- TTY Output Queues  E186 4F                      clra  E187 D6   FB                 ldb    NUM_TRM  E189 1F   01                 tfr    d,x  E18B CC   0000               ldd    #0  E18E F3   0100     10        addd   OBUF_SIZE  E191 30   1F                 leax   -1,x  E193 26   F9                 bne    10b  E195 FF   0284               stu    OBUFRS  E198 17   0099               lbsr   sto_chk   check for system table space overflow  E19B 25   12                 bcs    40f       jump if it happens                     * -- Task table  E19D 86   80                 lda    #TSKSIZTask       Structure                 14:06:08  Mar 21, 2020   Page   27Table      Initialization                             E19F D6   F9                 ldb    NUM_TSK  E1A1 3D                      mul  E1A2 FF   0286               stu    tsktab  E1A5 17   008C               lbsr   sto_chk   check for system table space overflow  E1A8 25   05                 bcs    40f       jump if it happens  E1AA FF   0288               stu    tskend                     *  E1AD 20   4D                 bra    60f                     * -- System table space has overflowed!                     * -- Try adjusting some parameters to get it under control  E1AF FC   0100     40        ldd    OBUF_SIZE first step, reduce output buffer size  E1B2 83   0020               subd   #32  E1B5 FD   0100               std    OBUF_SIZE  E1B8 1083 0120               cmpd   #MIN_OB  E1BC 2C   3B                 bge    50f       jump if still something left  E1BE CC   0400               ldd    #MAX_OB   start over & try something else  E1C1 FD   0100               std    OBUF_SIZE  E1C4 96   F9                 lda    NUM_TSK   try reducing # tasks  E1C6 80   01                 suba   #1  E1C8 97   F9                 sta    NUM_TSK  E1CA D6   FB                 ldb    NUM_TRM  E1CC DB   FD                 addb   NUM_PPR  E1CE DB   FC                 addb   NUM_NEC  E1D0 CB   03                 addb   #3  E1D2 34   04                 pshs   b  E1D4 A1   E0                 cmpa   ,s+  E1D6 2C   21                 bge    50f  E1D8 86   28                 lda    #MAX_TSK  E1DA 97   F9                 sta    NUM_TSK  E1DC 96   FA                 lda    NUM_CL    crank back on # clists  E1DE 80   01                 suba   #1  E1E0 97   FA                 sta    NUM_CL  E1E2 91   FB                 cmpa   NUM_TRM  E1E4 2C   13                 bge    50f  E1E6 C6   7C                 ldb    #MAX_CL  E1E8 D7   FA                 stb    NUM_CL  E1EA 8E   E216               ldx    #00f  E1ED BD   F019               jsr    DB_pdata  E1F0 BD   F037               jsr    DB_config  E1F3 BD   F013               jsr    DB_main  E1F6 7E   E05A               jmp    rom_init  ... what else can I do???  E1F9 16   FF3E     50        lbra   30b       go try it all again                     *-- Initialize devices  E1FC CE   028E     60        ldu    #dev_tab                                            E1FF 5F            62        clrb  E200 34   04       70        pshs   b  E202 AE   C4                 ldx    dev_addr,u get device address  E204 27   06                 beq    75f       jump if none there  E206 10AE 42                 ldy    dev_type,u get device kind                     Task       Structure                 14:06:08  Mar 21, 2020   Page   28Table      Initialization                                                  E209 AD   B8 22              jsr    [D_init,y] go initialize device  E20C 33   48       75        leau   DEV_SIZE,u  E20E 35   04                 puls   b  E210 5C                      incb  E211 C1   04                 cmpb   #MAX_DEV-1  E213 26   EB                 bne    70b                     * -- All done  E215 39            90        rts                     *  E216 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  E22D 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                                                                         *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  E234 33   CB       sto_chk   leau   d,u       compute new end pointer  E236 1183 6FFF               cmpu   #end_vars overflow?  E23A 22   03                 bhi    10f       yes - return error  E23C 1C   FE                 clc              no         - return OK  E23E 39                      rts  E23F 1A   01       10        sec              ..         bad owies  E241 39                      rts                                          *                     * clinit                     *                     * Initialize character buffer lists.  This routine                     * is only called once at startup time.                     *                       E242 BE   027E     clinit    ldx    CLISTS    point to clist  E245 D6   FA                 ldb    NUM_CL    set count  E247 BF   0119               stx    cfreel    set head pointer  E24A 31   88 20    clini2    leay   CBSIZE,x  E24D 10AF 84                 sty    0,x       set fwd link  E250 1F   21                 tfr    y,x       advance to next  E252 5A                      decb  E253 26   F5                 bne    clini2  E255 96   FA                 lda    NUM_CL    get buffer count  E257 80   02                 suba   #2  E259 B7   011C               sta    lcbuf     set max count  E25C 4F                      clra             make       d=0  E25D ED   88 E0              std    -CBSIZE,x clear last linkTask       Structure                 14:06:08  Mar 21, 2020   Page   29Table      Initialization                             E260 7F   011B               clr    cbufct  E263 39                      rts              all        done!                                          *                     * ttyinit                     *                     * Init the tty tables and queues.                     *                       E264 10BE 0282     ttyinit   ldy    TTYQS     point to q tables  E268 6F   E2                 clr    ,-s       terminal # counter  E26A D6   FB                 ldb    NUM_TRM   get terminal count  E26C 34   04                 pshs   b  E26E FE   0284               ldu    OBUFRS    output buffer  E271 BE   0280               ldx    TTYTABS   point to TTY Tables  E274 10AF 84       10        sty    tqin,x    set input q  E277 31   25                 leay   QH_SIZE,y get next q  E279 10AF 02                 sty    tqproc,x  set pr q  E27C 31   25                 leay   QH_SIZE,y set next q  E27E 10AF 04                 sty    tqout,x   set output q  E281 EF   22                 stu    oq_buf,y  ** Init output Q **  E283 EF   26                 stu    oq_get,y  E285 EF   24                 stu    oq_put,y  E287 FC   0100               ldd    OBUF_SIZE  E28A 33   CB                 leau   d,u  E28C EF   28                 stu    oq_end,y  E28E 31   2A                 leay   OQH_SIZE,y get next q  E290 86   15                 lda    #AC_SET   #%101<<2   8 bits, no parity, 1 stop bit  E292 A7   0F                 sta    tbaud,x   set conf word  E294 A6   61                 lda    1,s       get terminal #  E296 A7   0A                 sta    tdevic,x  set in table  E298 34   46                 pshs   d,u  E29A C6   08                 ldb    #DEV_SIZE  E29C 3D                      mul  E29D CE   028E               ldu    #dev_tab  E2A0 33   CB                 leau   d,u  E2A2 EC   C4                 ldd    dev_addr,u -- device address  E2A4 ED   06                 std    taddr,x  E2A6 35   46                 puls   d,u  E2A8 6C   61                 inc    1,s       bump terminal #  E2AA 30   88 1F              leax   TTYSIZ,x  next tty entry  E2AD 6A   E4                 dec    0,s       dec the count  E2AF 26   C3                 bne    10b       repeat?  E2B1 35   86                 puls   d,pc      clean up stack & return                                          *                     * tskinit - Initialize all tasks                     *  E2B3 BE   0286     tskinit   ldx    tsktab  E2B6 BF   0115               stx    utask  E2B9 D6   F9                 ldb    NUM_TSK   # tasks in system  E2BB 34   04                 pshs   bTask       Structure                 14:06:09  Mar 21, 2020   Page   30Table      Initialization                             E2BD 10BE 0286               ldy    tsktab    task 1  E2C1 31   A9 0080            leay   TSKSIZ,y  E2C5               10                                            E2C5 86   04       11        lda    #TFREE    mark all tasks free  E2C7 BC   0286               cmpx   tsktab    is this the system task?  E2CA 26   02                 bne    15f  E2CC 86   05                 lda    #TSYS     the system task is never free  E2CE A7   04       15        sta    tsstat,x  E2D0 86   FF                 lda    #$FF      not associated with a terminal  E2D2 A7   08                 sta    tsdev,x  E2D4 33   89 0080            leau   TSKSIZ,x  initialize stack  E2D8 CC   E401               ldd    #IO_han  E2DB 34   20                 pshs   y  E2DD AC   E1                 cmpx   ,s++      task 1?  E2DF 26   03                 bne    20f       no - normal I/O handling task  E2E1 CC   E55C               ldd    #TI_HAN   yes - special terminal interrupt handling task  E2E4 36   06       20        pshu   d  E2E6 EF   0E                 stu    usp,x  E2E8 EF   88 10              stu    umark0,x  E2EB 30   89 0080            leax   TSKSIZ,x  E2EF 6A   E4                 dec    0,s       done?  E2F1 26   D2                 bne    10b  E2F3 32   61                 leas   1,s       clean up stack  E2F5 CC   0000               ldd    #0        nothing running or sleeping  E2F8 FD   010F               std    runlst  E2FB FD   0111               std    slplst  E2FE FD   0113               std    slplst+tsslnk  E301 30   A4                 leax   0,y       start interrupt handling task  E303 BD   E6AB               jsr    makrdy  E306 39                      rts                     Task       Structure                 14:06:09  Mar 21, 2020   Page   31IOP        Configuration                                                                      *                     * define which type of boards are present                     *               E307  mod_tbl   equ    *  E307 EE78 E30D               fdb    DEV_6850,SR4_name  E30B 0000                    fdb    0                     *  E30D 43 50 55 30   SR4_name  fcc    'CPU09SR4',0Task       Structure                 14:06:09  Mar 21, 2020   Page   32FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     *  E316               fio_reset  E316 8E   0000               ldx    #iop_cpu  clear control structure                     *  E319 6F   80       00        clr    ,x+  E31B 8C   0010               cmpx   #fifo  E31E 26   F9                 bne    00b                     *  E320 8E   0000               ldx    #0  E323 9F   09                 stx    fifo_get  set Q pointers  E325 9F   0B                 stx    fifo_put                     *#        lda     #$99       tell CPU I'm ready                     *#        sta     iop_cpuF  E327 CE   0400               ldu    #1024     -- Reset Time-Out value                     *  E32A C6   FF       fio_wait  ldb    #255      Spin counter                     *  E32C               00  E32C 0D   FE                 tst    iop_cpuF  E32E 27   16                 beq    10f                     *  E330 5A                      decb  E331 26   F9                 bne    00b       jump back if not ready                     *  E333 33   5F                 leau   -1,u  E335 1183 0000               cmpu   #0  E339 26   EF                 bne    fio_wait  E33B 8E   E03D               ldx    #CPU_down  E33E 17   0CD8               lbsr   DB_pdata  E341 17   0CCF               lbsr   DB_main  E344 20   D0                 bra    fio_reset  E346 39            10        rts                                          *                     * fio_msg - Send a message via the FIO Mailbox                     *   B - Message code to send (one byte)                     *   iop_cpu1..3 already set up                     *                                          ***+++                     ***---                                            E347 34   14       fio_msg   pshs   b,x       save register  E349 D7   00                 stb    iop_cpu   set up mailbox value                                          ***+++                     ***---                     Task       Structure                 14:06:09  Mar 21, 2020   Page   33FIO        Simulation Routines                        E34B 86   FF       5         lda    #$FF      tell CPU mailbox full  E34D 97   FE                 sta    iop_cpuF  E34F 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  E352 96   FE       10        lda    iop_cpuF  wait till value consumed  E354 27   14                 beq    20f       jump if consumed                     *  E356 30   1F                 leax   -1,x      time-out yet?  E358 26   F8                 bne    10b                     *  E35A 8E   E36C               ldx    #00f  E35D BD   F019               jsr    DB_pdata  E360 A6   E4                 lda    0,s  E362 BD   F01F               jsr    DB_phex  E365 17   0CAB               lbsr   DB_main  E368 20   E5                 bra    05b       try again                     *  E36A 35   94       20        puls   b,x,pc                     *  E36C 0D 46 49 4F   00        fcc    $d,'FIO Time-out, Value = $',0                                          *                     * fio_response - Return a response code/sequence #                     *    B - Response code                     *    A - Transaction specific value                     *  E385 34   16       fio_response pshs d,x  E387 8D   12                 bsr    FIO_get   access FIO  E389 BE   0115               ldx    utask  E38C A6   0B                 lda    tsseq,x  E38E 97   01                 sta    iop_cpu1  E390 A6   E4                 lda    0,s       get transaction specific value  E392 97   02                 sta    iop_cpu2 >E394 BD   E347               jsr    fio_msg  E397 8D   17                 bsr    FIO_rel   release FIO  E399 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *  E39B 34   76       FIO_get   pshs   d,x,y,u   save registers  E39D 108E 0134     10        ldy    #FIO_lock is the device locked  E3A1 6D   A4                 tst    0,y  E3A3 27   07                 beq    20f       no - go get it                     *  E3A5 C6   CE                 ldb    #FIOPRI   waiting for the FIO  E3A7 BD   E6E5               jsr    sleep  E3AA 20   F1                 bra    10b       try again                     *  E3AC 6C   A4       20        inc    0,y       mark in use  E3AE 35   F6                 puls   d,x,y,u,pc returnTask       Structure                 14:06:10  Mar 21, 2020   Page   34FIO        Simulation Routines                                                                *                     * FIO_rel - Release access to FIO                     *  E3B0 34   76       FIO_rel   pshs   d,x,y,u  E3B2 108E 0134               ldy    #FIO_lock  E3B6 6F   A4                 clr    0,y  E3B8 BD   E6C1               jsr    wakeup  E3BB 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  E3BD 34   04       FIFOgeta  pshs   b  E3BF 8D   05                 bsr    FIFO_get  E3C1 35   02                 puls   a  E3C3 1E   89                 exg    a,b  E3C5 39                      rts                     *  E3C6 34   10       FIFO_get  pshs   x  E3C8 D6   08                 ldb    fifo_cnt  any data?  E3CA 27   14                 beq    99f       no - exit                     *  E3CC 5A                      decb             yes        - adjust count  E3CD D7   08                 stb    fifo_cnt  E3CF 9E   09                 ldx    fifo_get  get consumer pointer  E3D1 E6   88 10              ldb    fifo,x    fetch byte  E3D4 30   01                 leax   1,x       bump pointer  E3D6 8C   0080               cmpx   #FIFO_SIZE end of fifo?  E3D9 26   03                 bne    10f                     *  E3DB 8E   0000               ldx    #0        reset pointer                     *  E3DE 9F   09       10        stx    fifo_get                     *  E3E0 35   90       99        puls   x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  E3E2 34   04       FIFOputa  pshs   b  E3E4 1F   89                 tfr    a,b  E3E6 8D   02                 bsr    FIFO_put  E3E8 35   84                 puls   b,pc                     *  E3EA 34   10       FIFO_put  pshs   x  E3EC 9E   0B                 ldx    fifo_put  get consumer pointer  E3EE E7   88 10              stb    fifo,x    store byte  E3F1 30   01                 leax   1,x       bump pointer  E3F3 8C   0080               cmpx   #FIFO_SIZE end of FIFO?Task       Structure                 14:06:10  Mar 21, 2020   Page   35FIO        Simulation Routines                        E3F6 26   03                 bne    10f                     *  E3F8 8E   0000               ldx    #0        reset pointer  E3FB 9F   0B       10        stx    fifo_put                     *  E3FD 0C   08                 inc    fifo_cnt  update count  E3FF 35   90       99        puls   x,pcTask       Structure                 14:06:10  Mar 21, 2020   Page   36IO         Command Handler                                                                    *                     * IO_han - I/O Command Handler                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *                                          ***+++                     ***---                                            E401               IO_han    clri   allow     interrupts  E403 BE   0115               ldx    utask     get task control block address  E406 A6   0A                 lda    tscmd,x   get I/O command                                          ***+++                     ***---                       E408 44            10        lsra             isolate    command  E409 44                      lsra  E40A 44                      lsra  E40B 44                      lsra  E40C E6   08                 ldb    tsdev,x   get device #  E40E C1   05                 cmpb   #MAX_DEV  check for legal device #  E410 25   04                 blo    10f       jump if OK                     *  E412 C6   84                 ldb    #E_BADDEV return illegal device error  E414 20   23                 bra    20f       exit                     *  E416 48            10        lsla             --   word index on command  E417 8E   028E               ldx    #dev_tab  E41A 34   06                 pshs   d  E41C 86   08                 lda    #DEV_SIZE  E41E 3D                      mul  E41F 30   8B                 leax   d,x  E421 AE   02                 ldx    dev_type,x get handler table address  E423 35   06                 puls   d  E425 10AE 86                 ldy    a,x       get processor address  E428 4F                      clra                     *  E429 8E   E43C     10        ldx    #IO_end   interrupt handler address  E42C 34   10                 pshs   x  E42E BE   0115               ldx    utask  E431 10EF 88 12              sts    umark1,x                     * X=utask, Y=handler address, U=  E435 AD   A4                 jsr    0,y       perform operation & return status  E437 32   62                 leas   2,s       clean up stack                     *Task       Structure                 14:06:10  Mar 21, 2020   Page   37IO         Command Handler                            E439 BD   E385     20        jsr    fio_response                     *  E43C               IO_end    seti   mask      interrupts  E43E BE   0115               ldx    utask     restore task control block address  E441 A7   0D                 sta    tstval,x  remember transaction value sent  E443 E7   0A                 stb    tscmd,x   and command response  E445 86   04                 lda    #TFREE    mark task "terminated & free"  E447 A7   04                 sta    tsstat,x  E449 86   FF                 lda    #$FF      disassociate from any terminal  E44B A7   08                 sta    tsdev,x  E44D 6F   09                 clr    tssgnl,x  no waiting signals  E44F BD   E605               jsr    rsched    run other tasks >E452 16   FFAC               lbra   IO_han                                          *                     * Illegal command                     *  E455               bad_cmd  E455 C6   81                 ldb    #E_BADCMD error code  E457 39                      rtsTask       Structure                 14:06:10  Mar 21, 2020   Page   38Device     Table for Illegal Device                                        E458               DEV_BAD     E458 E478                    fdb    bad_dev   0  E45A E478                    fdb    bad_dev   1  E45C E478                    fdb    bad_dev   2  E45E E478                    fdb    bad_dev   3  E460 E478                    fdb    bad_dev   4  E462 E478                    fdb    bad_dev   5  E464 E478                    fdb    bad_dev   6  E466 E478                    fdb    bad_dev   7  E468 E478                    fdb    bad_dev   8  E46A E478                    fdb    bad_dev   9  E46C E478                    fdb    bad_dev   A  E46E E478                    fdb    bad_dev   B  E470 E478                    fdb    bad_dev   C  E472 E478                    fdb    bad_dev   D  E474 E478                    fdb    bad_dev   E  E476 E478                    fdb    bad_dev   F                                          *  E478 C6   84       bad_dev   ldb    #E_BADDEV  E47A 39                      rtsTask       Structure                 14:06:11  Mar 21, 2020   Page   39Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                                          ***+++                     ***---                                          *  E47B               IRQ_han                     *-- Check for clock interrupt                     *          lda     #%10000000 get clock mask                     *          bita    CLOCK      check clock int                     *          beq     00f        no - try something else                     *                     *          sta     CLOCKI     reset interrupt                     *          jsr     clkint     go process interrupt                     *          lbra    99f        exit                     *  E47B CE   028E     00        ldu    #dev_tab  scan devices  E47E CC   0000               ldd    #0        start with device 0                     *  E481 AE   C4       10        ldx    dev_addr,u get device address  E483 27   0A                 beq    20f       jump if none there                     *  E485 10AE 42                 ldy    dev_type,u get device type                                          ***+++                     ***---                       E488 AD   B8 20    15        jsr    [D_inthan,y] call interrupt poller/handler  E48B 1025 008E               lbcs   99f       exit if interrupt serviced                     *  E48F C3   0001     20        addd   #1        next device  E492 33   48                 leau   DEV_SIZE,u  E494 1083 0005               cmpd   #MAX_DEV  any more devices?  E498 25   E7                 blo    10b                     * Check for FIO Mailbox interrupt  E49A 96   FF                 lda    cpu_iopF  see if mailbox interrupt  E49C 27   77                 beq    50f       no - move on                                          ***+++  E49E BD   E5B7               jsr    H_cpu     record transaction in history Queue                     ***---                                          ***+++                     ***---                       E4A1 BE   0139     25        ldx    int_ptr   input message pointer  E4A4 96   04                 lda    cpu_iop   move message  E4A6 A7   80                 sta    ,x+  E4A8 96   05                 lda    cpu_iop1Task       Structure                 14:06:11  Mar 21, 2020   Page   40Interrupt  Processing                                 E4AA A7   80                 sta    ,x+  E4AC 96   06                 lda    cpu_iop2  E4AE A7   80                 sta    ,x+  E4B0 96   07                 lda    cpu_iop3  E4B2 A7   80                 sta    ,x+                     *#          tst     irq_gen    reset interrupt  E4B4 0F   FF                 clr    cpu_iopF  indicate message consumed  E4B6 BF   0139               stx    int_ptr   update pointer  E4B9 108E 0135               ldy    #int_buf  get message from buffer  E4BD A6   A4                 lda    0,y       -- Send interrupt command?  E4BF 81   A0                 cmpa   #O_INTRPT  E4C1 26   0F                 bne    30f                     *  E4C3 10BF 0139               sty    int_ptr   reset pointer  E4C7 E6   23                 ldb    3,y       get terminal #  E4C9 D1   FB                 cmpb   NUM_TRM   is this a TTY device?  E4CB 24   50                 bhs    99f       no - ignore message                     *  E4CD BD   EE5D               jsr    send_int  E4D0 20   4B                 bra    99f       exit                     *  E4D2 BE   0286     30        ldx    tsktab    search for an available task  E4D5 D6   F9                 ldb    NUM_TSK   Number of tasks in system                     *  E4D7 A6   04       32        lda    tsstat,x  E4D9 81   04                 cmpa   #TFREE    looking for a "free" task  E4DB 27   1B                 beq    40f                     *  E4DD 30   89 0080            leax   TSKSIZ,x  E4E1 5A                      decb  E4E2 26   F3                 bne    32b                     *  E4E4 34   16                 pshs   d,x  E4E6 8E   E529               ldx    #00f  E4E9 BD   F019               jsr    DB_pdata  E4EC BD   F013               jsr    DB_main  E4EF 35   16                 puls   d,x  E4F1 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated!  E4F3 BD   E347               jsr    fio_msg  E4F6 20   25                 bra    99f       exit                     *  E4F8 108E 0135     40        ldy    #int_buf  get message from buffer  E4FC 10BF 0139               sty    int_ptr   reset pointer  E500 E6   A0                 ldb    ,y+       command byte  E502 E7   0A                 stb    tscmd,x   save for task  E504 A6   A0                 lda    ,y+       sequence #  E506 A7   0B                 sta    tsseq,x  E508 E6   A0                 ldb    ,y+       command specific data  E50A E7   0D                 stb    tstval,x  E50C A6   A0                 lda    ,y+       associate with terminal  E50E A7   08                 sta    tsdev,x                     ** -- Removed 2/21/85Task       Structure                 14:06:11  Mar 21, 2020   Page   41Interrupt  Processing                                                    ** lda #RUNPRI make highest possible priority                     ** sta tsprir,x  E510 BD   E6AB               jsr    makrdy    make task ready to run                     ** ldx utask don't switch if this was the system running                     ** cmpx tsktab                     ** beq 99f                     ** jsr change -- whatever I was doing can wait...  E513 20   08                 bra    99f       exit                     *  E515 17   0B19     50        lbsr   DB_check  enter debugger?  E518 24   03                 bcc    99f                     *  E51A 17   0AF6               lbsr   DB_main                     *  E51D 3B            99        rti              return     from interrupt                     *  E51E 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  E529 2D 2D 20 4E   00        fcc    '-- No tasks!',0Task       Structure                 14:06:11  Mar 21, 2020   Page   42Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   A - Device #                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  E536 34   36       int_all   pshs   d,x,y  E538 D6   F9                 ldb    NUM_TSK  E53A C0   02                 subb   #2  E53C BE   0286               ldx    tsktab  E53F 30   89 0100            leax   2*TSKSIZ,x                     *  E543 A1   08       10        cmpa   tsdev,x   is this guy associated with the device?  E545 26   0C                 bne    20f                     *  E547 BC   0115               cmpx   utask     make sure I don't get blown away  E54A 27   07                 beq    20f                     *  E54C 34   16                 pshs   d,x  E54E BD   E71A               jsr    xmtint    interrupt task  E551 35   16                 puls   d,x                     *  E553 30   89 0080  20        leax   TSKSIZ,x  next task  E557 5A                      decb             any        more tasks?  E558 26   E9                 bne    10b                     *  E55A 35   B6                 puls   d,x,y,pc  returnTask       Structure                 14:06:12  Mar 21, 2020   Page   43Terminal   Interrupt Handling Task                                                            *                     * TI_HAN Terminal interrupt handler                     *  E55C 108E 011E     TI_HAN    ldy    #TI_Q     Terminal Interrupt Queue  E560                         seti  E562 FE   0132               ldu    TI_Q_ptr  get current Q ptr  E565 1183 011E               cmpu   #TI_Q     anything in Q?  E569 26   07                 bne    20f       yes - go process it                     *  E56B C6   D8                 ldb    #TIQPRI   wait for something to do  E56D BD   E6E5               jsr    sleep  E570 20   EA                 bra    TI_HAN                     *  E572 E6   C2       20        ldb    ,-u       B = Interrupt #  E574 A6   C2                 lda    ,-u       A = Device #  E576 FF   0132               stu    TI_Q_ptr  update pointer  E579 34   06                 pshs   d         save registers  E57B E6   E4                 ldb    0,s       set up to flush all input for this terminal  E57D BD   E88B               jsr    ttftab  E580 BD   EC41               jsr    flushi  E583                         clri   allow     interrupts  E585 BD   E39B               jsr    FIO_get   get access to FIO  E588 E6   E0                 ldb    ,s+       terminal #  E58A D7   01                 stb    iop_cpu1  E58C E6   E0                 ldb    ,s+       interrupt #  E58E D7   02                 stb    iop_cpu2  E590 C6   0A                 ldb    #R_INTRPT  E592 BD   E347               jsr    fio_msg   send interrupt message  E595 BD   E3B0               jsr    FIO_rel   release access to FIO  E598 20   C2                 bra    TI_HAN    process more if needed                                          *                     * Send_TI - Send a terminal interrupt                     *   B = Interrupt #                     *   X = TTY Table                     *   jsr send_TI                     *  E59A 34   76       send_TI   pshs   d,x,y,u   save registers  E59C FE   0132               ldu    TI_Q_ptr  get Q head  E59F 1183 0132               cmpu   #TI_Q_ptr check for overflow  E5A3 24   09                 bhs    90f       exit if so - sorry                     *  E5A5 A6   0A                 lda    tdevic,x  get terminal #  E5A7 A7   C0                 sta    ,u+       place value in Queue  E5A9 E7   C0                 stb    ,u+  E5AB FF   0132               stu    TI_Q_ptr  update pointer                     *  E5AE 108E 011E     90        ldy    #TI_Q     wake up Queue server  E5B2 BD   E6C1               jsr    wakeup  E5B5 35   F6                 puls   d,x,y,u,pc return                     Task       Structure                 14:06:12  Mar 21, 2020   Page   44Terminal   Interrupt Handling Task                  Task       Structure                 14:06:12  Mar 21, 2020   Page   45History    Entry Procedures                                                                   *                     * H_cpu - Place a transaction from the CPU into                     *         the history Queue.                     *  E5B7 34   16       H_cpu     pshs   d,x  E5B9 BE   027C               ldx    hstptr    get history queue pointer  E5BC 96   04                 lda    cpu_iop  E5BE A7   84                 sta    hst_cmd,x  E5C0 96   05                 lda    cpu_iop1  E5C2 A7   01                 sta    hst_seq,x  E5C4 96   07                 lda    cpu_iop3  E5C6 A7   02                 sta    hst_tty,x  E5C8 96   06                 lda    cpu_iop2  E5CA A7   03                 sta    hst_val,x  E5CC 30   04                 leax   HRECSIZ,x  E5CE 8C   027C               cmpx   #hstptr   end of Queue?  E5D1 25   03                 blo    10f  E5D3 8E   023C               ldx    #hstbuf  E5D6 BF   027C     10        stx    hstptr  E5D9 35   96                 puls   d,x,pc                                          *                     * H_iop - Place a transaction from the IOP into                     *         the history Queue.                     *  E5DB 34   16       H_iop     pshs   d,x  E5DD BE   027C               ldx    hstptr    get history queue pointer  E5E0 96   00                 lda    iop_cpu  E5E2 A7   84                 sta    hst_cmd,x  E5E4 96   01                 lda    iop_cpu1  E5E6 A7   01                 sta    hst_seq,x  E5E8 96   03                 lda    iop_cpu3  E5EA A7   02                 sta    hst_tty,x  E5EC 96   02                 lda    iop_cpu2  E5EE A7   03                 sta    hst_val,x  E5F0 30   04                 leax   HRECSIZ,x  E5F2 8C   027C               cmpx   #hstptr   end of Queue?  E5F5 25   03                 blo    10f  E5F7 8E   023C               ldx    #hstbuf  E5FA BF   027C     10        stx    hstptr  E5FD 35   96                 puls   d,x,pc                     Task       Structure                 14:06:12  Mar 21, 2020   Page   46Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       E5FF BE   0115     change    ldx    utask     point to task table entry >E602 17   006D               lbsr   putrun    put on ready list                     *  E605               rsched    seti   mask      interrupts  E607 BE   0115               ldx    utask     point to current task  E60A 10EF 88 10              sts    umark0,x  save stack pointers  E60E BE   0286               ldx    tsktab    point to task table  E611 8D   23                 bsr    swtchu    switch users  E613 7F   011D               clr    idle      reset idle/running flag                     *  E616 7F   0118     rsche2    clr    chproc    reset change flag >E619 17   0025               lbsr   getjob    get a new task  E61C 26   0C                 bne    rsche3    find one?                                          ***+++                     ***---                       E61E 86   7F       05        lda    #127      set higheset priority  E620 B7   0117               sta    jobpri    set as current  E623                         clri   clear     interrupts                     * idle work could go on here  E625 12                      nop  E626                         seti  E628 20   EC                 bra    rsche2    loop til find a ready one                     *  E62A F7   0117     rsche3    stb    jobpri    set new priority  E62D 8D   07                 bsr    swtchu    switch users top page  E62F BE   0115               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  E632 CC   0001               ldd    #1        return 1 to new task  E635 39                      rts              return    Task       Structure                 14:06:13  Mar 21, 2020   Page   47Scheduler  routines                                                                           *                     * Switch users                     *   X - Task entry for new task                     *  E636 35   20       swtchu    puls   y         get return address  E638 BF   0115               stx    utask     set up new running task  E63B 10EE 88 10              lds    umark0,x  reset stack                                          ***+++                     ***---                       E63F 6E   A4                 jmp    0,y       return to caller                                          ***+++                     ***---                                                                                    ***+++                     ***---                                          Task       Structure                 14:06:13  Mar 21, 2020   Page   48Scheduler  routines                                                                           *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       E641 5F            getjob    clrb             clear      flag  E642 BE   010F               ldx    runlst    point to head of list  E645 27   1F                 beq    getjo6    empty list?                     *  E647 A6   04       getjo1    lda    tsstat,x  get status byte  E649 81   01                 cmpa   #TRUN     is it in run state?  E64B 26   1B                 bne    getjo8                     *  E64D 5D                      tstb             first      in list?  E64E 27   06                 beq    getjo2                     *  E650 EC   84                 ldd    tslink,x  remove from list  E652 ED   A4                 std    tslink,y  E654 20   07                 bra    getjo4                     *  E656 10AE 84       getjo2    ldy    tslink,x  remove from list head  E659 10BF 010F               sty    runlst    set new head                     *  E65D E6   05       getjo4    ldb    tsprir,x  get priority  E65F 6F   84                 clr    tslink,x  zero out link  E661 6F   01                 clr    tslink+1,x so not run list  E663 86   FF                 lda    #$ff      set ne status  E665 39                      rts              return                         *  E666 4F            getjo6    clra             set        eq status  E667 39                      rts                     *  E668 1F   12       getjo8    tfr    x,y       save old pos  E66A AE   84                 ldx    tslink,x  follow link  E66C 27   F8                 beq    getjo6                     *  E66E C6   01                 ldb    #1        set flag  E670 20   D5                 bra    getjo1    repeat loop                     Task       Structure                 14:06:13  Mar 21, 2020   Page   49Scheduler  routines                                                                           *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       E672 34   01       putrun    pshs   cc        save status  E674                         seti   mask      interrupts  E676 10BE 010F               ldy    runlst    point to head  E67A 26   0A                 bne    putru2  E67C BF   010F               stx    runlst    set new head                     *  E67F CC   0000     putru1    ldd    #0        set last link  E682 ED   84                 std    tslink,x  E684 35   81                 puls   cc,pc     return                     *  E686 E6   05       putru2    ldb    tsprir,x  get priority  E688 E1   25                 cmpb   tsprir,y  look for correct prior slot  E68A 2F   08                 ble    putru4                     *  E68C FC   010F               ldd    runlst  E68F BF   010F               stx    runlst    set new head  E692 20   0F                 bra    putru5    link in rest                     *  E694 1F   23       putru4    tfr    y,u       save last look  E696 10AE A4                 ldy    tslink,y  follow link  E699 27   0C                 beq    putru6                     *  E69B E1   25                 cmpb   tsprir,y  check priority  E69D 2F   F5                 ble    putru4                     *  E69F EC   C4                 ldd    tslink,u  link into list here  E6A1 AF   C4                 stx    tslink,u                     *  E6A3 ED   84       putru5    std    tslink,x  E6A5 35   81                 puls   cc,pc     return                     *  E6A7 AF   C4       putru6    stx    tslink,u  E6A9 20   D4                 bra    putru1    go zero last link                     Task       Structure                 14:06:13  Mar 21, 2020   Page   50Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       E6AB 86   01       makrdy    lda    #TRUN     set status  E6AD A7   04                 sta    tsstat,x  E6AF CC   0000               ldd    #0        clear events flag  E6B2 ED   06                 std    tsevnt,x  E6B4 8D   BC                 bsr    putrun    put on ready list  E6B6 E6   05                 ldb    tsprir,x  get priority  E6B8 F1   0117               cmpb   jobpri    higher than current?  E6BB 2F   03                 ble    makrd6                     *  E6BD 7C   0118               inc    chproc    set change flag                     *  E6C0 39            makrd6    rts              return    Task       Structure                 14:06:14  Mar 21, 2020   Page   51Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       E6C1 34   57       wakeup    pshs   cc,d,x,u  save registers  E6C3                         seti   mask      interupts  E6C5 CE   0111               ldu    #slplst  E6C8 AE   42                 ldx    tsslnk,u  point to sleep list  E6CA 27   0B                 beq    wakeu4                     *  E6CC 10AC 06       wakeu2    cmpy   tsevnt,x  check event  E6CF 27   08                 beq    wakeu5  E6D1 33   84                 leau   0,x       mark this entry                     *  E6D3 AE   02       wakeu3    ldx    tsslnk,x  follow chain  E6D5 26   F5                 bne    wakeu2    end of list?                     *  E6D7 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  E6D9 34   70       wakeu5    pshs   x,y,u     save registers  E6DB EC   02                 ldd    tsslnk,x  remove from list  E6DD ED   42                 std    tsslnk,u  E6DF 8D   CA                 bsr    makrdy    put on ready list  E6E1 35   70                 puls   u,x,y  E6E3 20   EE                 bra    wakeu3    repeat                     Task       Structure                 14:06:14  Mar 21, 2020   Page   52Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *                                          ***+++                     ***---                       E6E5 34   51       sleep     pshs   cc,x,u    save registers  E6E7 BE   0115               ldx    utask     point to task                                          ***+++                     ***---                       E6EA 6D   09                 tst    tssgnl,x  any signals waiting?  E6EC 26   1F                 bne    sleep7                     *  E6EE                         seti   mask      ints  E6F0 E7   05                 stb    tsprir,x  set priority  E6F2 10AF 06                 sty    tsevnt,x  set event  E6F5 86   02                 lda    #TSLEEP   set status  E6F7 A7   04                 sta    tsstat,x  E6F9 FC   0113               ldd    slplst+tsslnk get head of list  E6FC ED   02                 std    tsslnk,x  set new link  E6FE BF   0113               stx    slplst+tsslnk set new head  E701 17   FF01               lbsr   rsched    reschedule cpu                                          ***+++                     ***---                       E704 BE   0115     20        ldx    utask     get task entry  E707 6D   09                 tst    tssgnl,x  any signals waiting?  E709 26   02                 bne    sleep7                     *  E70B 35   D1                 puls   cc,x,u,pc return                     *  E70D BE   0115     sleep7    ldx    utask     reset signal  E710 6F   09                 clr    tssgnl,x  E712 EC   88 12              ldd    umark1,x  stack reset point  E715 35   51                 puls   cc,x,u    reset cc and registers  E717 1F   04                 tfr    d,s       change stacks  E719 39                      rts              return    Task       Structure                 14:06:14  Mar 21, 2020   Page   53Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  jsr xmtint                     *  E71A 34   76       xmtint    pshs   d,x,y,u   save registers  E71C A6   04                 lda    tsstat,x  get task state  E71E 81   01                 cmpa   #TRUN     running?  E720 26   06                 bne    10f       no - try something else                     *  E722 86   01                 lda    #1        set signal  E724 A7   09                 sta    tssgnl,x  E726 20   0E                 bra    99f       exit                     *  E728 81   02       10        cmpa   #TSLEEP   task sleeping?  E72A 26   0A                 bne    99f       no - can't send interrupt                     *  E72C 86   01                 lda    #1        set signal  E72E A7   09                 sta    tssgnl,x  E730 10AE 06                 ldy    tsevnt,x  wake task up >E733 17   FF8B               lbsr   wakeup                     *  E736 35   F6       99        puls   d,x,y,u,pc returnTask       Structure                 14:06:14  Mar 21, 2020   Page   54Clist      - Get & Put Char Code                                                              *                     * getc                     *                     * Get a character from a specified character q.                     * The q is pointed to by y upon entry.  The char                     * is returned in b.                     *                       E738 34   15       getc      pshs   x,b,cc    save x  E73A                         seti  E73C AE   21                 ldx    clfst,y   get first pointer  E73E 27   3A                 beq    getc4  E740 E6   80                 ldb    0,x+      get character  E742 E7   61                 stb    1,s  E744 AF   21                 stx    clfst,y   save new ptr  E746 6A   A4                 dec    clcnt,y   dec the count  E748 26   09                 bne    getc1  E74A CC   0000               ldd    #0        zero pointers  E74D ED   21                 std    clfst,y  E74F ED   23                 std    cllst,y  E751 20   0E                 bra    getc2  E753 1F   10       getc1     tfr    x,d  E755 C5   1F                 bitb   #CBSIZE-1 check pointer  E757 26   1C                 bne    getc3  E759 EC   88 E0              ldd    -CBSIZE,x  E75C C3   0002               addd   #2  E75F ED   21                 std    clfst,y   set new first  E761 1F   10       getc2     tfr    x,d  E763 83   0001               subd   #1  E766 C4   E0                 andb   #!(CBSIZE-1) check pointer  E768 1F   01                 tfr    d,x       reset  E76A FC   0119               ldd    cfreel    get free block  E76D ED   84                 std    0,x       set link  E76F BF   0119               stx    cfreel  E772 7A   011B               dec    cbufct    dec the buffer count  E775 35   01       getc3     puls   cc  E777 4F                      clra  E778 35   94                 puls   b,x,pc  E77A 35   01       getc4     puls   cc  E77C 86   FF                 lda    #$ff      set -1  E77E 35   94                 puls   b,x,pc                     Task       Structure                 14:06:15  Mar 21, 2020   Page   55Clist      - Get & Put Char Code                                                              *                     * putc                     *                     * Put a character on the specified q.  The q is                     * pointed to by y upon entry and the character                     * should be in b.                     *                       E780 34   15       putc      pshs   x,b,cc  E782                         seti  E784 AE   23                 ldx    cllst,y   get tail pointer  E786 26   16                 bne    putc1  E788 BE   0119               ldx    cfreel    get free list  E78B 27   43                 beq    putc4  E78D EC   84                 ldd    0,x       pickup pointer  E78F FD   0119               std    cfreel  E792 7C   011B               inc    cbufct    update buffer count  E795 CC   0000               ldd    #0        zero fwd link  E798 ED   81                 std    0,x++  E79A AF   21                 stx    clfst,y   set first  E79C 20   23                 bra    putc2  E79E 1F   10       putc1     tfr    x,d       mask pointer  E7A0 C5   1F                 bitb   #CBSIZE-1  E7A2 26   1D                 bne    putc2  E7A4 34   20                 pshs   y  E7A6 10BE 0119               ldy    cfreel    get free list  E7AA 27   22                 beq    putc3  E7AC EC   A4                 ldd    0,y       get pointer  E7AE FD   0119               std    cfreel    save new head  E7B1 7C   011B               inc    cbufct    update buffer count  E7B4 10AF 88 E0              sty    -CBSIZE,x  E7B8 1F   21                 tfr    y,x  E7BA 35   20                 puls   y  E7BC CC   0000               ldd    #0        clear fwd link  E7BF ED   81                 std    0,x++  E7C1 E6   61       putc2     ldb    1,s       get character  E7C3 E7   80                 stb    0,x+      put in q  E7C5 AF   23                 stx    cllst,y   save last ptr  E7C7 6C   A4                 inc    clcnt,y   update character count  E7C9 35   01                 puls   cc  E7CB 4F                      clra  E7CC 35   94                 puls   b,x,pc    return  E7CE 35   20       putc3     puls   y  E7D0 35   01       putc4     puls   cc  E7D2 86   FF                 lda    #$ff      set error  E7D4 35   94                 puls   b,x,pc                     Task       Structure                 14:06:15  Mar 21, 2020   Page   56Output     Q Handling                                                                         *                     * get_oq                     *                     * Fetch the next character from the output Q                     *   Y - Output Queue Header                     *   jsr get_oq                     *   B - Character                     *   <EQ> if Queue was not empty                     *  E7D6 34   13       get_oq    pshs   cc,a,x    save registers  E7D8                         seti   no        interrupts allowed!  E7DA EC   A4                 ldd    oq_count,y  E7DC 27   16                 beq    20f       Queue empty  E7DE 83   0001               subd   #1  E7E1 ED   A4                 std    oq_count,y update counter  E7E3 AE   26                 ldx    oq_get,y  source pointer  E7E5 E6   80                 ldb    ,x+       get data  E7E7 AC   28                 cmpx   oq_end,y  buffer overflow?  E7E9 25   02                 blo    10f       no - continue  E7EB AE   22                 ldx    oq_buf,y  yes - reset pointer  E7ED AF   26       10        stx    oq_get,y  update pointer  E7EF 35   01                 puls   cc  E7F1 4F                      clra             Queue not empty  E7F2 35   92                 puls   a,x,pc    return  E7F4 35   01       20        puls   cc  E7F6 86   FF                 lda    #$FF      Queue empty  E7F8 35   92                 puls   a,x,pc                     Task       Structure                 14:06:15  Mar 21, 2020   Page   57Output     Q Handling                                                                         *                     * put_oq                     *                     * Put a character into an output Q                     *    Y - Output Q header                     *    B - Character to insert                     *    jsr put_oq                     *  E7FA 34   17       put_oq    pshs   cc,d,x    save registers  E7FC                         seti   no        interrupts  E7FE AE   24                 ldx    oq_put,y  get pointer  E800 E7   80                 stb    ,x+       put data into Q  E802 AC   28                 cmpx   oq_end,y  buffer overflow?  E804 25   02                 blo    10f       no - continue  E806 AE   22                 ldx    oq_buf,y  yes - reset pointer  E808 AF   24       10        stx    oq_put,y  save new pointer  E80A EC   A4                 ldd    oq_count,y update count  E80C C3   0001               addd   #1  E80F ED   A4                 std    oq_count,y  E811 35   97                 puls   cc,d,x,pc returnTask       Structure                 14:06:15  Mar 21, 2020   Page   58Terminal   Drivers                                                                            *                     * The routines in this file make up the main system                     * terminal drivers.  Most of the work is actually                     * performed by other internal routines.                     *                                          *                     * ttopn                     *                     * Open a terminal for use.  On entry, D has                     * the device number.                     *                       E813 34   06       ttopn     pshs   d         save device number  E815 8D   74                 bsr    ttftab    get table address  E817 A6   88 11              lda    tstate,x  get states  E81A 85   04                 bita   #TOPEN    is it already open?  E81C 26   02                 bne    ttopn8  E81E 8D   08                 bsr    ttdopn    do actual open  E820 10AE 06       ttopn8    ldy    taddr,x   point to device  E823 AD   D8 30              jsr    [D_ttenr,u] enable rcv interrupts  E826 35   86                 puls   d,pc      return                                                               *                     * ttdopn                     *                     * Do actual terminal open.  X points to tty entry.                     *                       E828 10AE 06       ttdopn    ldy    taddr,x   get device address  E82B 6F   88 13              clr    tstate3,x  E82E AD   D8 26    10        jsr    [D_ttconf,u] configure the port                     * response of NE implies open OK                                          * if EQ then blocked by CTS if Carry is 0  E831 26   18                 bne    ttdop6    is it ready?  E833 25   0B                 bcs    ttdop5    branch if blocked by DCD  E835 34   31                 pshs   cc,x,y    save regs  E837                         seti   mask      ints  E839 AD   D8 4A              jsr    [D_ttwcts,u] wait for CTS  E83C 35   31                 puls   cc,x,y    reset regs  E83E 20   E8                 bra    ttdopn    repeat open  E840 34   31       ttdop5    pshs   cc,x,y    save regs  E842                         seti   mask      ints  E844 AD   D8 4C              jsr    [D_ttwdcd,u] wait for DCD  E847 35   31                 puls   cc,x,y    reset regs  E849 20   DD                 bra    ttdopn    repeat open  E84B 86   36       ttdop6    lda    #ECHO|XTABS|CRMOD|BSECH  E84D A7   08                 sta    tflags,x  setup initial mode  E84F 86   7F                 lda    #BSPCH    get backspace charTask       Structure                 14:06:16  Mar 21, 2020   Page   59Terminal   Drivers                                    E851 A7   0D                 sta    tbksp,x   save in table  E853 86   18                 lda    #CNCLC    get cancel character  E855 A7   0E                 sta    tcncl,x   save in table  E857 A6   88 11              lda    tstate,x  set OPEN flag  E85A 8A   04                 ora    #TOPEN    set open status  E85C A7   88 11              sta    tstate,x  save in table  E85F 86   01                 lda    #DSR_OK   allow transmitting  E861 A7   88 12              sta    tstate2,x  E864 39                      rts              return                     Task       Structure                 14:06:16  Mar 21, 2020   Page   60Terminal   Drivers                                                                            *                     * ttcls                     *                     * Close the terminal whode device number is in D.                     *                       E865 8D   24       ttcls     bsr    ttftab    find table entry  E867 A6   88 11              lda    tstate,x  was the port actually open?  E86A 85   04                 bita   #TOPEN  E86C 27   0E                 beq    10f       no - skip flush  E86E 84   FB                 anda   #!TOPEN   yes - clear bit  E870 A7   88 11              sta    tstate,x  ... so we don't get hung up ...  E873 17   03A0               lbsr   flusho    flush out buffers  E876 10AE 06                 ldy    taddr,x   get device address  E879 AD   D8 34              jsr    [D_ttenno,u] close down the port  E87C A6   88 11    10        lda    tstate,x  clear state bits  E87F 84   F8                 anda   #PROTOCOL preserve protocol flags  E881 A7   88 11              sta    tstate,x  E884 6F   88 12              clr    tstate2,x  E887 6F   88 13              clr    tstate3,x  E88A 39                      rts                                          *                     * ttftab                     *                     * Find tty table entry associated with device in D.                     * Exit with entry pointed at by X.                     * Also compute device handler table in U.                     *                       E88B 34   06       ttftab    pshs   d  E88D BE   0280               ldx    TTYTABS   point to table  E890 86   1F                 lda    #TTYSIZ   set size up  E892 3D                      mul              calculate  offset  E893 30   8B                 leax   d,x       point to entry  E895 35   06                 puls   d  E897 CE   028E               ldu    #dev_tab  E89A 86   08                 lda    #DEV_SIZE  E89C 3D                      mul  E89D 33   CB                 leau   d,u  E89F EE   42                 ldu    dev_type,u get handler table address  E8A1 39                      rts              return                                          Task       Structure                 14:06:16  Mar 21, 2020   Page   61Terminal   Drivers                                                                            *                     * tintr                     *                     * TTY interrupt handler.  Determine if the interrupt                     * is a receive or transmit one and take appropriate                     * actions.                     *                       E8A2 8D   E7       tintr     bsr    ttftab    calculate table addresses  E8A4 10AE 06                 ldy    taddr,x   get device address  E8A7 34   20       01        pshs   y         save port address  E8A9 EC   64                 ldd    4,s       fetch device status (if present)                       E8AB AD   D8 3E              jsr    [D_tttstb,u] test for break interrupt  E8AE 26   3E                 bne    tintr5                       E8B0 AD   D8 42              jsr    [D_tttstc,u] test drop carrier int  E8B3 26   41                 bne    tintr6                       E8B5 AD   D8 3C              jsr    [D_tttstr,u] test for rcv int  E8B8 26   16                 bne    tintr2                       E8BA AD   D8 40              jsr    [D_tttsts,u] test CTS change interrupt  E8BD 26   5F                 bne    tintr9                       E8BF AD   D8 44              jsr    [D_tttstd,u] test dsr change  E8C2 26   41                 bne    tintr8                       E8C4 AD   D8 38              jsr    [D_tttstx,u] test for xmit int  E8C7 26   0F                 bne    tintr3                       E8C9 AD   D8 46              jsr    [D_tttste,u] test error int  E8CC 26   30                 bne    tintr7    ** should be 7? **                       E8CE 20   4E                 bra    tintr9  E8D0 AD   D8 2A    tintr2    jsr    [D_ttgetc,u] get character from port  E8D3 BD   EAF4               jsr    ttyin     go buffer char  E8D6 20   46                 bra    tintr9  E8D8 BD   E9F0     tintr3    jsr    ttyst     go output another char  E8DB EC   98 04              ldd    [tqout,x] check queue count  E8DE 27   06                 beq    tintr4  E8E0 10B3 0104               cmpd   OQLO      low water mark?  E8E4 26   38                 bne    tintr9  E8E6 10AE 04       tintr4    ldy    tqout,x   get output queue  E8E9 BD   E6C1               jsr    wakeup  E8EC 20   30                 bra    tintr9  E8EE CC   0002     tintr5    ldd    #INTS     set INT interrupt  E8F1 BD   E59A               jsr    send_TI   send interrupt  E8F4 20   28                 bra    tintr9  E8F6 CC   0001     tintr6    ldd    #HANGS    set hangup unt  E8F9 BD   E59A               jsr    send_TI   send interruptTask       Structure                 14:06:16  Mar 21, 2020   Page   62Terminal   Drivers                                    E8FC 20   20                 bra    tintr9  E8FE C6   07       tintr7    ldb    #$07      set bell char  E900 BD   EAF4               jsr    ttyin     go buffer it  E903 20   19                 bra    tintr9    exit  E905 A6   88 12    tintr8    lda    tstate2,x get state  E908 85   01                 bita   #DSR_OK   was it OK to send before?  E90A 27   0A                 beq    85f       no - must be now  E90C 84   FE                 anda   #!DSR_OK  don't allow any sending  E90E A7   88 12              sta    tstate2,x  E911 AD   D8 2E              jsr    [D_ttdisx,u] disable transmitter  E914 20   08                 bra    tintr9    exit  E916 8A   01       85        ora    #DSR_OK   allow transmitting  E918 A7   88 12              sta    tstate2,x  E91B BD   E9D8               jsr    ttyren    restart transmission  E91E 35   20       tintr9    puls   y         restore port address  E920 6E   D8 48              jmp    [D_ttend,u] clean up the port & return                     Task       Structure                 14:06:16  Mar 21, 2020   Page   63Terminal   Drivers                                                                            *                     * ttyset/ttyget                     *                     * Handle the actual get or put of data for ttyset                     * and ttyget.                     *                       E923 17   FF65     ttyset    lbsr   ttftab    get tty table address  E926 17   FA94               lbsr   FIFOgeta  move data from FIFO  E929 E6   08                 ldb    tflags,x  save current flags  E92B A7   08                 sta    tflags,x  set flags  E92D C5   41                 bitb   #RAW|SCHR currently in RAW or Single Character mode?  E92F 26   21                 bne    10f       yes - no change  E931 85   41                 bita   #RAW|SCHR going to one of those modes?  E933 27   1D                 beq    10f       no - continue  E935 6D   94                 tst    [tqin,x]  any unsolicited input?  E937 27   06                 beq    00f       no - continue  E939 6D   0B                 tst    tdel,x    any delimiters?  E93B 27   02                 beq    00f  E93D 6C   0B                 inc    tdel,x    force a delimiter  E93F 85   01       00        bita   #RAW      going into RAW mode?  E941 27   0F                 beq    10f       no  E943 A6   88 11              lda    tstate,x  yes - no HOLD processing in RAW mode  E946 85   02                 bita   #HOLD     currently holding?  E948 27   08                 beq    10f       no - continue  E94A 84   FD                 anda   #!HOLD  E94C A7   88 11              sta    tstate,x  E94F 17   0086               lbsr   ttyren    kick output  E952 17   FA68     10        lbsr   FIFOgeta  move data from FIFO  E955 A7   09                 sta    tdelay,x  set delays  E957 17   FA63               lbsr   FIFOgeta  move data from FIFO  E95A A7   0E                 sta    tcncl,x   set cancel char  E95C 17   FA5E               lbsr   FIFOgeta  move data from FIFO  E95F A7   0D                 sta    tbksp,x   set back space char  E961 17   FA59               lbsr   FIFOgeta  move data from FIFO  E964 84   7F                 anda   #$7F  E966 A7   0F                 sta    tbaud,x   set bauds  E968 17   FA52               lbsr   FIFOgeta  move data from FIFO  E96B 34   02                 pshs   a  E96D 84   F8                 anda   #PROTOCOL save protocol bits  E96F 34   02                 pshs   a  E971 A6   88 11              lda    tstate,x  update state  E974 84   07                 anda   #(!PROTOCOL)&$FF clear current bits  E976 AA   E0                 ora    ,s+       set new bits  E978 A7   88 11              sta    tstate,x  E97B 35   02                 puls   a  E97D 84   0F                 anda   #$0F      get baud rate  E97F 34   02                 pshs   a  E981 A6   88 10              lda    tbaud2,x  update baud rate  E984 84   F0                 anda   #$F0  E986 AA   E0                 ora    ,s+Task       Structure                 14:06:17  Mar 21, 2020   Page   64Terminal   Drivers                                    E988 A7   88 10              sta    tbaud2,x                     * transfer is (already) 8 bytes  E98B 17   FA2F               lbsr   FIFOgeta  move data from FIFO  E98E 17   FA2C               lbsr   FIFOgeta  move data from FIFO                     *  E991 C6   06                 ldb    #R_TTY    return TTYSET OK  E993 39                      rts              return                                            E994 17   FEF4     ttyget    lbsr   ttftab    get table address  E997 A6   08                 lda    tflags,x  get flags byte  E999 17   FA46               lbsr   FIFOputa  put data into FIFO  E99C A6   09                 lda    tdelay,x  get delays  E99E 17   FA41               lbsr   FIFOputa  put data into FIFO  E9A1 A6   0E                 lda    tcncl,x   get cancel char  E9A3 17   FA3C               lbsr   FIFOputa  put data into FIFO  E9A6 A6   0D                 lda    tbksp,x   get b.s. char  E9A8 17   FA37               lbsr   FIFOputa  put data into FIFO  E9AB A6   0F                 lda    tbaud,x   get bauds  E9AD 84   7F                 anda   #$7F  E9AF 6D   0B                 tst    tdel,x    check delimiter count  E9B1 26   05                 bne    ttys45  E9B3 6D   98 02              tst    [tqproc,x] any chars in processed queue?  E9B6 27   02                 beq    ttysg5  E9B8 8A   80       ttys45    ora    #%10000000 set del bit  E9BA 17   FA25     ttysg5    lbsr   FIFOputa  put data into FIFO  E9BD A6   88 11              lda    tstate,x  return protocol bits  E9C0 84   F8                 anda   #PROTOCOL  E9C2 34   02                 pshs   a  E9C4 A6   88 10              lda    tbaud2,x  get baud rate  E9C7 84   0F                 anda   #$0F  E9C9 AA   E0                 ora    ,s+  E9CB 17   FA14               lbsr   FIFOputa  put data into FIFO                     * transfer is (already) 8 bytes  E9CE 4F                      clra  E9CF 17   FA10               lbsr   FIFOputa  put data into FIFO  E9D2 17   FA0D               lbsr   FIFOputa  put data into FIFO                     *  E9D5 C6   06                 ldb    #R_TTY    response = TTYGET = OK  E9D7 39                      rts              returnTask       Structure                 14:06:17  Mar 21, 2020   Page   65TTY        Handlers                                                                           *                     * All code in this section is the common tty handler                     * code.  The device dependent code resides with the                     * drivers.  This handler package requires an ACIA be used                     * for all character type devices.                     *                                                               *                     * ttyren                     *                     * Re-enable the tty output after a timeout operation.                     * Upon entry, x should point to the tty structure.                     *                       E9D8               ttyren  E9D8 A6   88 11              lda    tstate,x  check state  E9DB 85   02                 bita   #HOLD >E9DD 1026 0056               lbne   ttyst9                     *  E9E1 84   FE                 anda   #!TIMOUT  clear time out  E9E3 A7   88 11              sta    tstate,x  reset state  E9E6 10AE 06                 ldy    taddr,x >E9E9 1027 0036               lbeq   ttys55                     *  E9ED AD   D8 2C              jsr    [D_ttenxr,u] enable xmit interrupts                                          Task       Structure                 14:06:17  Mar 21, 2020   Page   66TTY        Handlers                                                                           *                     * ttyst                     *                     * TTY start will output a character to the terminal.                     * Upon entry, x should point to the tty structure in                     * use.  Getc is called for the character.                     *                       E9F0 A6   88 12    ttyst     lda    tstate2,x is it ok to transmit?  E9F3 85   01                 bita   #DSR_OK >E9F5 1027 003E               lbeq   ttyst9    no - wait until it is                     *  E9F9 10AE 06                 ldy    taddr,x   get device address  E9FC 27   25                 beq    ttys55                     *  E9FE AD   D8 36              jsr    [D_ttxbsy,u] test xmit busy?  EA01 27   20                 beq    ttys55                     *  EA03 A6   88 11    ttyst1    lda    tstate,x  EA06 85   01                 bita   #TIMOUT >EA08 1026 002B               lbne   ttyst9                                          ***+++                     ***---                       EA0C               ttyst15  EA0C 10AE 04                 ldy    tqout,x   get out q  EA0F 17   FDC4               lbsr   get_oq    get character  EA12 26   23                 bne    ttyst9    exit if queue empty                                          ***+++                     ***---                       EA14 A6   08                 lda    tflags,x  EA16 85   01                 bita   #RAW      test raw mode  EA18 26   03                 bne    ttyst2                     *  EA1A 5D                      tstb             char       negative?  EA1B 2B   07                 bmi    ttyst6                     *  EA1D 10AE 06       ttyst2    ldy    taddr,x   get device address  EA20 6E   D8 28              jmp    [D_ttputc,u] write characetr                     *  EA23 39            ttys55    rts                     *  EA24 A6   88 11    ttyst6    lda    tstate,x  EA27 85   60                 bita   #XANY|XONXOF HOLD processing enabled?  EA29 26   04                 bne    ttyst65   yes                     *  EA2B 85   80                 bita   #ESCOFF   ESCape HOLD disabled?  EA2D 26   F4                 bne    ttys55    yes - ignore HOLD characterTask       Structure                 14:06:18  Mar 21, 2020   Page   67TTY        Handlers                                                      *  EA2F A6   88 11    ttyst65   lda    tstate,x  get states  EA32 8A   03                 ora    #TIMOUT|HOLD set hold mode  EA34 A7   88 11              sta    tstate,x  reset states                     *  EA37 10AE 06       ttyst9    ldy    taddr,x   get port  EA3A 6E   D8 2E              jmp    [D_ttdisx,u] disable xmit interrupts                     Task       Structure                 14:06:18  Mar 21, 2020   Page   68TTY        Handlers                                                                           *                     * ttyout                     *                     * Put the character in b into the output q.  Upon                     * entry, x should point to the tty structure.  Tab                     * expansions, upper case mapping, and special character                     * handling are all done here.                     *                       EA3D A6   08       ttyout    lda    tflags,x  get flags  EA3F 85   01                 bita   #RAW      raw mode?  EA41 27   11                 beq    ttyo12                     *  EA43 A6   88 11              lda    tstate,x  no hold in RAW mode  EA46 84   FD                 anda   #!HOLD  EA48 A7   88 11              sta    tstate,x  EA4B 10AE 04                 ldy    tqout,x   point to out q  EA4E 17   FDA9               lbsr   put_oq    put char in q  EA51 16   0087               lbra   ttyoue    go finish                     *  EA54 C1   FF       ttyo12    cmpb   #$ff      special hold char?  EA56 27   53                 beq    ttyou6                     *  EA58 C4   7F                 andb   #$7f      mask parity bit  EA5A C1   09                 cmpb   #TABCH  EA5C 26   11                 bne    ttyou2                     *  EA5E A6   08                 lda    tflags,x  check mode  EA60 85   04                 bita   #XTABS    expand tabs?  EA62 27   0B                 beq    ttyou2                     *  EA64 C6   20       ttyo14    ldb    #SPACE  EA66 8D   D5                 bsr    ttyout    output it  EA68 A6   0C                 lda    tcolm,x   check column  EA6A 85   07                 bita   #7  EA6C 26   F6                 bne    ttyo14                     *  EA6E 39                      rts                     *  EA6F A6   08       ttyou2    lda    tflags,x  check mode  EA71 85   08                 bita   #LCASE    lower case mode?  EA73 27   25                 beq    ttyou4                     *  EA75 C1   61                 cmpb   #'a       lower case letter?  EA77 25   08                 blo    ttyo22                     *  EA79 C1   7A                 cmpb   #'z  EA7B 22   04                 bhi    ttyo22                     *  EA7D C0   20                 subb   #$20      make upper  EA7F 20   19                 bra    ttyou4Task       Structure                 14:06:18  Mar 21, 2020   Page   69TTY        Handlers                                                      *  EA81 108E EAE9     ttyo22    ldy    #lcht     point to map                     *  EA85 E1   A1       ttyo23    cmpb   0,y++  EA87 26   0D                 bne    ttyo24                     *  EA89 E6   3F                 ldb    -1,y      get mapped char  EA8B 34   04                 pshs   b  EA8D C6   5C                 ldb    #'\       output escape >EA8F 17   FFAB               lbsr   ttyout  EA92 35   04                 puls   b  EA94 20   15                 bra    ttyou6                     *  EA96 6D   A4       ttyo24    tst    0,y       end of list?  EA98 26   EB                 bne    ttyo23                     *  EA9A C1   0D       ttyou4    cmpb   #CR  EA9C 26   0D                 bne    ttyou6                     *  EA9E A6   08                 lda    tflags,x  check mode  EAA0 85   10                 bita   #CRMOD  EAA2 27   07                 beq    ttyou6                     *  EAA4 C6   0A                 ldb    #NL       convert to NL >EAA6 17   FF94               lbsr   ttyout    output it  EAA9 C6   0D                 ldb    #CR       reset CR                     *  EAAB 10AE 04       ttyou6    ldy    tqout,x   point to out q  EAAE 17   FD49               lbsr   put_oq  EAB1 C1   0D                 cmpb   #CR  EAB3 22   20                 bhi    ttyou8                     *  EAB5 26   02                 bne    ttyo75    is it cr?                     *  EAB7 6F   0C                 clr    tcolm,x   clear out column count!                     *  EAB9 C1   09       ttyo75    cmpb   #9        is it tab character?  EABB 26   0A                 bne    ttyo77                     *  EABD A6   0C                 lda    tcolm,x   get column count  EABF 84   F8                 anda   #!7       mask low 3 bits  EAC1 8B   08                 adda   #8        add in tab  EAC3 A7   0C                 sta    tcolm,x   save new column  EAC5 20   14                 bra    ttyoue                     *  EAC7 C1   08       ttyo77    cmpb   #$08      hardware backspace?  EAC9 25   10                 blo    ttyoue  EACB 26   08                 bne    ttyou8  EACD 6D   0C                 tst    tcolm,x   column zero?  EACF 27   0A                 beq    ttyoue  EAD1 6A   0C                 dec    tcolm,x  EAD3 20   06                 bra    ttyoueTask       Structure                 14:06:18  Mar 21, 2020   Page   70TTY        Handlers                                                      *  EAD5 C1   20       ttyou8    cmpb   #SPACE    is it control char?  EAD7 25   02                 blo    ttyoue                     *  EAD9 6C   0C                 inc    tcolm,x   bump column count                     *  EADB A6   88 11    ttyoue    lda    tstate,x  ** kludge for ACIA **  EADE 85   02                 bita   #HOLD  EAE0 26   06                 bne    ttyoe1                     *  EAE2 10AE 06                 ldy    taddr,x   get device address  EAE5 6E   D8 2C              jmp    [D_ttenxr,u] enable xmit interrupts                     *  EAE8 39            ttyoe1    rts              return                       EAE9 7E 5E 7C 21   lcht      fcc    "~^|!{(})`'"  EAF3 00                      fcb    0Task       Structure                 14:06:18  Mar 21, 2020   Page   71TTY        Handlers                                                                           *                     * ttyin                     *                     * Place the character in b on the input q.                     * Upon entry, x should point to the tty structure.                     * Signal processing and character mapping are                     * performed in this roiutine.                     *                       EAF4               ttyin                                          ***+++                     ***---                       EAF4 A6   08                 lda    tflags,x  raw mode?  EAF6 85   01                 bita   #RAW  EAF8 26   51                 bne    ttyi44                     *  EAFA C4   7F                 andb   #$7f      mask par bit                     *  EAFC C1   20       ttyin0    cmpb   #SPACE    control char?  EAFE 24   4B                 bhs    ttyi44    skip junk if so                     *  EB00 C1   1C       ttyin2    cmpb   #QUITC  EB02 27   09                 beq    ttyi25                     *  EB04 C1   03                 cmpb   #INTRC  EB06 26   0B                 bne    ttyin3                     *  EB08 CC   0002               ldd    #INTS     set signal  EB0B 20   03                 bra    ttyi27                     *  EB0D CC   0003     ttyi25    ldd    #QUITS    set signal                     *  EB10 7E   E59A     ttyi27    jmp    send_TI   send interrupt & get out                     *  EB13 A6   88 11    ttyin3    lda    tstate,x  get state  EB16 C1   1B                 cmpb   #HOLDC    Escape?  EB18 26   10                 bne    ttyi34                     *  EB1A 85   80                 bita   #ESCOFF   escape processing disabled?  EB1C 26   27                 bne    ttyin4    yes - ignore ESC as special character                     *  EB1E 85   02                 bita   #HOLD     holding??  EB20 26   1B                 bne    ttyi36                     *  EB22 8A   03       ttyi33    ora    #TIMOUT|HOLD set HOLDing  EB24 A7   88 11              sta    tstate,x  EB27 7E   E9D8               jmp    ttyren                     *  EB2A 85   40       ttyi34    bita   #XONXOF   doing XON/XOFF processing?Task       Structure                 14:06:19  Mar 21, 2020   Page   72TTY        Handlers                                   EB2C 27   17                 beq    ttyin4    no - don't bother                     *  EB2E C1   13                 cmpb   #XOFFC    XOFF character?  EB30 26   07                 bne    ttyi35    no                     *  EB32 85   02                 bita   #HOLD     already stopped?  EB34 27   EC                 beq    ttyi33    no - stop output                     *  EB36 16   00B4               lbra   ttyin9    ignore XOFF if already stopped!                     *  EB39 C1   11       ttyi35    cmpb   #XONC     XON character  EB3B 26   08                 bne    ttyin4    no - continue                     * -- HOLD off  EB3D 84   FD       ttyi36    anda   #!HOLD    clear hold mode  EB3F A7   88 11              sta    tstate,x  EB42 7E   E9D8               jmp    ttyren                     *  EB45 C1   0D       ttyin4    cmpb   #CR       new line?  EB47 26   02                 bne    ttyi44                     *  EB49 6F   0C                 clr    tcolm,x   clear out column                     *  EB4B A6   88 11    ttyi44    lda    tstate,x  get current state  EB4E 85   20                 bita   #XANY     allow any character to restart?  EB50 27   04                 beq    ttyi46    no - continue on                     *  EB52 85   02                 bita   #HOLD     currently stopped?  EB54 26   E7                 bne    ttyi36    yes - go restart it                     *  EB56 10AE 84       ttyi46    ldy    tqin,x    input Q pointer  EB59 A6   A4                 lda    0,y       check q count                                          ***+++                     ***---                       EB5B 81   FE                 cmpa   #CHRLIM   hit limit?  EB5D 1024 008D               lbhs   flusht    flush this guy!                     *  EB61 B6   011B               lda    cbufct    check buffer count  EB64 B1   011C               cmpa   lcbuf  EB67 1022 0083               lbhi   flusht    if overflow, flush!                     *  EB6B A6   08       49        lda    tflags,x  check mode  EB6D 85   01                 bita   #RAW      raw mode?  EB6F 27   10                 beq    ttyin5                     *  EB71 17   FC0C               lbsr   putc      put char in q  EB74 10AE 84                 ldy    tqin,x    get in q  EB77 34   04                 pshs   b         save char  EB79 17   FB45               lbsr   wakeup    awaken those waiting  EB7C 35   04                 puls   b         get character  EB7E 6C   0B                 inc    tdel,x    bump delimiter countTask       Structure                 14:06:19  Mar 21, 2020   Page   73TTY        Handlers                                   EB80 39                      rts              return                     *  EB81 85   08       ttyin5    bita   #LCASE  EB83 27   0A                 beq    ttyin6                     *  EB85 C1   41                 cmpb   #'A       capital letter?  EB87 25   06                 blo    ttyin6                     *  EB89 C1   5A                 cmpb   #'Z  EB8B 22   02                 bhi    ttyin6                     *  EB8D CB   20                 addb   #$20      make lower case                     *  EB8F 10AE 84       ttyin6    ldy    tqin,x    point to input q  EB92 17   FBEB               lbsr   putc  EB95 A6   08                 lda    tflags,x  check mode  EB97 85   40                 bita   #SCHR     single char mode?  EB99 26   0A                 bne    ttyi65                     *  EB9B C1   0D                 cmpb   #CR  EB9D 22   12                 bhi    ttyin7                     *  EB9F 27   04                 beq    ttyi65                     *  EBA1 C1   04                 cmpb   #EOTCH  EBA3 26   0C                 bne    ttyin7                     *  EBA5 10AE 84       ttyi65    ldy    tqin,x    point to input q  EBA8 34   04                 pshs   b  EBAA 17   FB14               lbsr   wakeup    wake up waiting  EBAD 6C   0B                 inc    tdel,x    bump count                     *  EBAF 35   04       ttyi67    puls   b         reset char                     *  EBB1 E1   0E       ttyin7    cmpb   tcncl,x   kill character?  EBB3 26   18                 bne    ttyin8                     *  EBB5 A6   08                 lda    tflags,x  check mode  EBB7 85   40                 bita   #SCHR     single character?  EBB9 26   12                 bne    ttyin8                     *  EBBB C6   5E                 ldb    #'^       output '^x\n'  EBBD 17   FE7D               lbsr   ttyout  EBC0 C6   78                 ldb    #'x  EBC2 17   FE78               lbsr   ttyout  EBC5 C6   0D                 ldb    #CR  EBC7 17   FE73               lbsr   ttyout  EBCA 7E   E9F0               jmp    ttyst                     *  EBCD A6   08       ttyin8    lda    tflags,x  check mode  EBCF 85   02                 bita   #ECHO  EBD1 27   1A                 beq    ttyin9Task       Structure                 14:06:19  Mar 21, 2020   Page   74TTY        Handlers                                                      *  EBD3 E1   0D                 cmpb   tbksp,x   back space?  EBD5 26   10                 bne    ttyi85                     *  EBD7 85   20                 bita   #BSECH    echo bs?  EBD9 27   0C                 beq    ttyi85                     *  EBDB C6   08                 ldb    #$08      set bs  EBDD 17   FE5D               lbsr   ttyout  EBE0 C6   20                 ldb    #SPACE    set space  EBE2 17   FE58               lbsr   ttyout  EBE5 C6   08                 ldb    #$08      reset char                     *  EBE7 17   FE53     ttyi85    lbsr   ttyout    echo character  EBEA 7E   E9F0               jmp    ttyst     start output                     *  EBED 39            ttyin9    rts              return                     Task       Structure                 14:06:20  Mar 21, 2020   Page   75TTY        Handlers                                                                           *                     * flusht                     *                     * Flush all queues belonging to this terminal.                     *                       EBEE               flusht >EBEE 17   0050               lbsr   flushi    flush Input queues  EBF1 10AE 04                 ldy    tqout,x   point to out q                     *  EBF4 17   FBDF     10        lbsr   get_oq    flush out q  EBF7 2A   FB                 bpl    10b                     *  EBF9 10AE 84                 ldy    tqin,x    get input q  EBFC 17   FAC2               lbsr   wakeup    wakeup input q waiters  EBFF 10AE 04                 ldy    tqout,x   wake up out q waiters  EC02 17   FABC               lbsr   wakeup  EC05 A6   88 11              lda    tstate,x  get states  EC08 84   FC                 anda   #!(HOLD|TIMOUT) clear hold mode  EC0A A7   88 11              sta    tstate,x  EC0D CC   0000               ldd    #0        no pre-sold output  EC10 ED   88 15              std    tsold,x  EC13 7E   E9F0               jmp    ttyst                                          *                     * flusho                     *                     * Flush all this guys queues after waiting for the                     * output q to empty.                     *                       EC16 A6   88 11    flusho    lda    tstate,x  check state  EC19 85   02                 bita   #HOLD     holding?  EC1B 27   08                 beq    fluso1                     *  EC1D 84   FC       fluso0    anda   #!(HOLD|TIMOUT)  EC1F A7   88 11              sta    tstate,x  clear hold  EC22 17   FDB3               lbsr   ttyren    kick output                     *  EC25 EC   98 04    fluso1    ldd    [tqout,x] check char count >EC28 1027 FFC2               lbeq   flusht  EC2C A6   88 11              lda    tstate,x  check for hold  EC2F 85   02                 bita   #HOLD  EC31 26   EA                 bne    fluso0                                          ***+++                     ***---                       EC33 10AE 04                 ldy    tqout,x   point to out q  EC36 C6   EC                 ldb    #TTYOPR   set priority  EC38 34   10                 pshs   x         save xTask       Structure                 14:06:20  Mar 21, 2020   Page   76TTY        Handlers                                   EC3A 17   FAA8               lbsr   sleep  EC3D 35   10                 puls   x  EC3F 20   E4                 bra    fluso1                                          *                     * flushi - Flush input Queues only                     *  EC41               flushi  EC41 10AE 02                 ldy    tqproc,x  get procd q                     *  EC44 17   FAF1     10        lbsr   getc      get character  EC47 2A   FB                 bpl    10b                     *  EC49 10AE 84                 ldy    tqin,x    flush input q                     *  EC4C 17   FAE9     20        lbsr   getc  EC4F 2A   FB                 bpl    20b                     *  EC51 6F   0B                 clr    tdel,x    clear delim count                                          ***+++                     ***---                       EC53 39                      rts                                                                                    *                     * xtprcq                     *                     * Transfer characters from input q to procd q.  If not                     * in raw mode, do escape, backspace, and cancel                     * processing.  Enter with x pointing to tty structure.                     *                       EC54 34   01       xtprcq    pshs   cc        save cc  EC56                         seti   mask      ints  EC58 6D   0B                 tst    tdel,x    delimiters yet?  EC5A 26   10                 bne    xtprc0                                          ***+++                     ***---                       EC5C 10AE 84                 ldy    tqin,x    sleep on input q  EC5F C6   F6                 ldb    #TTYIPR  EC61 34   10                 pshs   x         save x  EC63 17   FA7F               lbsr   sleep  EC66 35   10                 puls   x  EC68 35   01                 puls   cc        reset cc  EC6A 20   E8                 bra    xtprcq                     *  EC6C 35   01       xtprc0    puls   cc        reset ccTask       Structure                 14:06:20  Mar 21, 2020   Page   77TTY        Handlers                                   EC6E 6D   94                 tst    [tqin,x]  input q empty?  EC70 26   04                 bne    xtprc1                     *  EC72 6A   0B                 dec    tdel,x    dec the del count  EC74 20   DE                 bra    xtprcq    repeat test                     *  EC76 108E 013E     xtprc1    ldy    #prcbuf+2 point to buffer  EC7A 5F                      clrb  EC7B 34   24                 pshs   b,y       delimiter flag                     *  EC7D 6D   E4       xtprc2    tst    0,s       delimiter?  EC7F 27   10                 beq    xtpr22                     *  EC81 6F   E4                 clr    0,s       clear del flag  EC83 6D   0B                 tst    tdel,x    check del count  EC85 27   02                 beq    xtpr21    if 0 - skip                     *  EC87 6A   0B                 dec    tdel,x    dec the del count                     *  EC89 A6   08       xtpr21    lda    tflags,x  get flags  EC8B 85   41                 bita   #RAW|SCHR in raw mode?  EC8D 1027 0081               lbeq   xtprc5                     *  EC91 10AE 84       xtpr22    ldy    tqin,x    point to in q  EC94 17   FAA1               lbsr   getc      get a character  EC97 2B   79                 bmi    xtprc5    none left?                     *  EC99 C1   0D                 cmpb   #CR       check for delim  EC9B 27   0C                 beq    xtpr25                     *  EC9D C1   04                 cmpb   #EOTCH  EC9F 26   0A                 bne    xtprc3                     *  ECA1 6C   E4                 inc    0,s       set del flag  ECA3 A6   08                 lda    tflags,x  get flags  ECA5 85   40                 bita   #SCHR     single char mode?  ECA7 26   D4                 bne    xtprc2                     *  ECA9 6C   E4       xtpr25    inc    0,s       set del flag                     *  ECAB A6   08       xtprc3    lda    tflags,x  check mode  ECAD 85   41                 bita   #RAW|SCHR  ECAF 27   04                 beq    xtpr31                     *  ECB1 6C   E4                 inc    0,s       set del flag for each raw char  ECB3 20   4D                 bra    xtpr45                     *  ECB5 10AE 61       xtpr31    ldy    1,s       point to buffer  ECB8 A6   3F                 lda    -1,y      check previous  ECBA 81   5C                 cmpa   #'\       escape?  ECBC 26   13                 bne    xtca32                     *Task       Structure                 14:06:21  Mar 21, 2020   Page   78TTY        Handlers                                   ECBE C1   04                 cmpb   #EOTCH    is it eot?  ECC0 27   08                 beq    xtp315                     *  ECC2 E1   0D                 cmpb   tbksp,x   backspace char?  ECC4 27   04                 beq    xtp315                     *  ECC6 E1   0E                 cmpb   tcncl,x   cancel char?  ECC8 26   07                 bne    xtca32                     *  ECCA 31   3F       xtp315    leay   -1,y      backup over slash  ECCC 10AF 61                 sty    1,s       save new ptr  ECCF 20   31                 bra    xtpr45                     *  ECD1 E1   0D       xtca32    cmpb   tbksp,x   backspace char?  ECD3 26   0D                 bne    xtca33                     *  ECD5 108C 013E               cmpy   #prcbuf+2 buffer begin?  ECD9 27   A2                 beq    xtprc2                     *  ECDB 31   3F                 leay   -1,y      backup pointer  ECDD 10AF 61                 sty    1,s  ECE0 20   9B                 bra    xtprc2                     *  ECE2 C1   04       xtca33    cmpb   #EOTCH    eot char?  ECE4 27   97                 beq    xtprc2                     *  ECE6 E1   0E                 cmpb   tcncl,x   cancel char?  ECE8 26   04                 bne    xtprc4                     *  ECEA 35   24                 puls   b,y       -- caution (order)  ECEC 20   88                 bra    xtprc1    repeat all                     *  ECEE C1   20       xtprc4    cmpb   #$20      check for control char  ECF0 24   10                 bhs    xtpr45                     *  ECF2 C1   0D                 cmpb   #CR       is it cr?  ECF4 27   0C                 beq    xtpr45                     *  ECF6 C1   09                 cmpb   #9        is it tab char?  ECF8 27   08                 beq    xtpr45                     *  ECFA A6   08                 lda    tflags,x  get flags  ECFC 85   80                 bita   #CNTRL    control char ignore?  ECFE 1026 FF7B               lbne   xtprc2                     *  ED02 10AE 61       xtpr45    ldy    1,s       get pointer  ED05 E7   A0                 stb    0,y+      transfer char  ED07 10AF 61                 sty    1,s       save pointer  ED0A 108C 023C               cmpy   #prcbuf+PRCSIZ overflow??  ED0E 1025 FF6B               lblo   xtprc2                     *  ED12 35   04       xtprc5    puls   b         remove del flag from stackTask       Structure                 14:06:21  Mar 21, 2020   Page   79TTY        Handlers                                   ED14 10AE 02                 ldy    tqproc,x  get procd q  ED17 34   10                 pshs   x  ED19 8E   013E               ldx    #prcbuf+2 point to processed buf                     *  ED1C AC   62       xtprc6    cmpx   2,s       end of buffer?  ED1E 24   07                 bhs    xtprc7                     *  ED20 E6   80                 ldb    0,x+      get character  ED22 17   FA5B               lbsr   putc  ED25 20   F5                 bra    xtprc6                     *  ED27               xtprc7                                          ***+++                     ***---                       ED27 CC   FFFF               ldd    #-1       set good  ED2A 35   B0                 puls   x,y,pc    return                                          ***+++                     ***---                     Task       Structure                 14:06:21  Mar 21, 2020   Page   80TTY        Handlers                                                                           *                     * req_read - CPU has informed us he wants to read                     * Tell him when some data is available.                     *  ED2C 17   FB5C     req_read  lbsr   ttftab    get TTY table address  ED2F A6   98 02              lda    [tqproc,x] anything available?  ED32 26   03                 bne    00f       yes - go use it                     *  ED34 17   FF1D               lbsr   xtprcq    go process input (wait if none there)                     *  ED37 A6   98 02    00        lda    [tqproc,x] get input processed count  ED3A 27   0A                 beq    05f       jump for EOF detected                     *  ED3C 81   01                 cmpa   #1        special case for single character  ED3E 27   09                 beq    10f                     *  ED40 E6   08                 ldb    tflags,x  single character & RAW always return 1 char  ED42 C5   41                 bitb   #RAW|SCHR  ED44 26   03                 bne    10f                     *  ED46 C6   07       05        ldb    #R_RDOK   inform CPU data now available  ED48 39                      rts                     *  ED49 10AE 02       10        ldy    tqproc,x  go fetch character  ED4C 17   F9E9               lbsr   getc  ED4F 86   09                 lda    #R_RD1C   inform CPU single character returned  ED51 1E   89                 exg    a,b  ED53 39                      rts                                          *                     * read_data - CPU wants IOP to send data                     *  Max # chars to move in transaction speicific value                     *  ED54 17   FB34     read_data lbsr   ttftab    get TTY table address  ED57 FE   0115               ldu    utask     see how many chars to send  ED5A 10AE 02                 ldy    tqproc,x  input queue pointer  ED5D 6F   E2                 clr    ,-s       set FIFO counter                     *  ED5F A6   A4       10        lda    0,y       any more characters?  ED61 27   0C                 beq    20f       no - done                     *  ED63 17   F9D2               lbsr   getc      fetch character  ED66 17   F681               lbsr   FIFO_put  put into FIFO  ED69 6C   E4                 inc    0,s       bump FIFO count  ED6B 6A   4D                 dec    tstval,u  does the guy want more?  ED6D 26   F0                 bne    10b                     *  ED6F A6   E0       20        lda    ,s+       get # chars in FIFO  ED71 C6   08                 ldb    #R_SNDNC  data now available in FIFO  ED73 6D   A4                 tst    0,y       any more data in case guy wants it?  ED75 27   02                 beq    30fTask       Structure                 14:06:21  Mar 21, 2020   Page   81TTY        Handlers                                                      *  ED77 C6   0B                 ldb    #R_SNDMC  yes - special response                     *  ED79 39            30        rtsTask       Structure                 14:06:21  Mar 21, 2020   Page   82TTY        Handlers                                                                           *                     * ttywrt                     *                     * The main terminal write routine.  Control is passed                     * to here from the device driver routine which calculates                     * the ttys structure location and passes it in x.                     *                       ED7A D6   08       ttywrt    ldb    fifo_cnt  get FIFO input length  ED7C C1   00                 cmpb   #0        anything in FIFO?  ED7E 27   0E                 beq    90f       no - exit                     *  ED80 34   04                 pshs   b         save input length                     *  ED82 17   F641     10        lbsr   FIFO_get  fetch character  ED85 17   FCB5               lbsr   ttyout    output it  ED88 6A   E4                 dec    0,s       decrement count  ED8A 26   F6                 bne    10b       repeat                     *  ED8C 35   02                 puls   a         clean up stack                     *  ED8E 34   01       90        pshs   cc        save cc  ED90                         seti   mask      ints  ED92 17   FC5B               lbsr   ttyst     give output a kick  ED95 35   81                 puls   cc,pc     return                                          *                     * open_tty - Perform device open                     *  ED97               open_tty  ED97 BD   E813               jsr    ttopn     perform tty open                                          ***+++                     ***---                       ED9A C6   02       10        ldb    #R_OPEN  ED9C 39                      rts                                          *                     * close_tty - Perform device close                     *  ED9D               close_tty  ED9D BD   E865               jsr    ttcls     perform tty close                                          ***+++                     ***---                       EDA0 C6   03       10        ldb    #R_CLOSE  EDA2 39                      rts                                          *Task       Structure                 14:06:22  Mar 21, 2020   Page   83TTY        Handlers                                                      * req_write - Request permission to write data                     *  EDA3               req_write  EDA3 BD   E88B               jsr    ttftab    get TTY table                                          ***+++                     ***---                       EDA6 34   01       05        pshs   cc        mask interrupts while fiddling                     *  EDA8               10        seti  EDAA 10AE 04                 ldy    tqout,x   get output queue pointer  EDAD EC   A4                 ldd    oq_count,y get queue length  EDAF E3   88 15              addd   tsold,x   include any space already sold  EDB2 C3   0080               addd   #FIFO_SIZE and assume the CPU will send this many more  EDB5 10B3 0102               cmpd   OQHI      space available?  EDB9 2F   16                 ble    20f       yes - OK                     *  EDBB A6   09                 lda    tdelay,x  special flush bit?  EDBD 85   40                 bita   #$40  EDBF 27   05                 beq    15f       no - go to sleep                     *  EDC1 BD   EC16               jsr    flusho    yes - flush output  EDC4 20   E2                 bra    10b       try again                     *  EDC6 34   76       15        pshs   d,x,y,u   no - save registers  EDC8 C6   E2                 ldb    #TTYSPR  EDCA BD   E6E5               jsr    sleep  EDCD 35   76                 puls   d,x,y,u   restore registers  EDCF 20   D7                 bra    10b       try again                     *  EDD1 10BE 0115     20        ldy    utask     am I supposed to be dead?  EDD5 6D   29                 tst    tssgnl,y  EDD7 26   0D                 bne    30f       yes - abort                     *  EDD9 EC   88 15              ldd    tsold,x   update amount pre-sold  EDDC C3   0080               addd   #FIFO_SIZE -- assume entire FIFO load  EDDF ED   88 15              std    tsold,x  EDE2 C6   04                 ldb    #R_REQOK  request granted code  EDE4 35   81                 puls   cc,pc     return                     *  EDE6 35   01       30        puls   cc        clean up stack  EDE8 32   62                 leas   2,s       -- pop normal return  EDEA 39                      rts              abnormal   I/O completion (no response)                                          *                     * write_data - Write data to a terminal                     *  EDEB               write_data  EDEB BD   E88B               jsr    ttftab    get tty table pointer >EDEE BD   ED7A               jsr    ttywrt    go consume data  EDF1 34   01                 pshs   cc        save interrupt stateTask       Structure                 14:06:22  Mar 21, 2020   Page   84TTY        Handlers                                   EDF3                         seti   mask      interrupts  EDF5 EC   88 15              ldd    tsold,x  EDF8 83   0080               subd   #FIFO_SIZE  EDFB 2A   03                 bpl    00f                     *  EDFD CC   0000               ldd    #0        don't screw up!                     *  EE00 ED   88 15    00        std    tsold,x   update count  EE03 10AE 04                 ldy    tqout,x   wake up anybody waiting for space                                          ***+++                     ***---                       EE06 BD   E6C1     10        jsr    wakeup  EE09 C6   05                 ldb    #R_WRITE  EE0B 35   81                 puls   cc,pc     return                     *  EE0D 0D 46 49 46   00        fcc    $d,'FIFO consumed, wakeup at $',0                                          *                     * Write single character                     *  -- Character passed via transaction message                     *  EE29 34   01       wrt_sc    pshs   cc        save interrupt state  EE2B BD   E88B               jsr    ttftab    compute tty table address                     *  EE2E 10AE 04       00        ldy    tqout,x   output Q pointer  EE31 EC   A4                 ldd    oq_count,y check for overrun  EE33 10B3 0102               cmpd   OQHI  EE37 23   12                 bls    10f       jump if space                     *  EE39 A6   09                 lda    tdelay,x  special flush bit?  EE3B 85   40                 bita   #$40  EE3D 27   05                 beq    05f       no - wait for space                     *  EE3F BD   EC16               jsr    flusho    yes - make space!  EE42 20   EA                 bra    00b                     *  EE44 C6   EC       05        ldb    #TTYOPR   wait a while  EE46 BD   E6E5               jsr    sleep  EE49 20   E3                 bra    00b       try again                     *  EE4B 10BE 0115     10        ldy    utask     fetch character  EE4F E6   2D                 ldb    tstval,y  EE51 BD   EA3D               jsr    ttyout    send to output queue  EE54                         seti   mask      interrupts  EE56 BD   E9F0               jsr    ttyst     kick output - make sure it starts  EE59 C6   05                 ldb    #R_WRITE  EE5B 35   81                 puls   cc,pc     return                                          *                     * send_int - Interrupt all tasks associated with a terminalTask       Structure                 14:06:22  Mar 21, 2020   Page   85TTY        Handlers                                                      *  EE5D 34   76       send_int  pshs   d,x,y,u  EE5F BD   E88B               jsr    ttftab    get TTY table address  EE62 BD   EBEE               jsr    flusht    flush terminal buffers  EE65 A6   61                 lda    1,s       get terminal #  EE67 BD   E536               jsr    int_all   interrupt all associated tasks  EE6A BE   0115               ldx    utask     also interrupt current task if appropriate  EE6D A6   61                 lda    1,s  EE6F A1   08                 cmpa   tsdev,x  EE71 26   03                 bne    10f                     *  EE73 BD   E71A               jsr    xmtint                     *  EE76 35   F6       10        puls   d,x,y,u,pc clean up stack & return                                          ***+++                     ***----                     Task       Structure                 14:06:23  Mar 21, 2020   Page   86ACIA       interface routines                                                                 * The routines in this file are specific to an ACIA (6850).                     * They are called from the "ttyhan" and "ttydrv" files.                                          *                     * 6850 Device table                     *  EE78               DEV_6850  EE78 E455                    fdb    bad_cmd   0 -  EE7A ED97                    fdb    open_tty  1 -  EE7C ED9D                    fdb    close_tty 2 -  EE7E E923                    fdb    ttyset    3 -  EE80 E994                    fdb    ttyget    4 -  EE82 EDA3                    fdb    req_write 5 -  EE84 EDEB                    fdb    write_data 6 -  EE86 EE29                    fdb    wrt_sc    7 -  EE88 ED2C                    fdb    req_read  8 -  EE8A ED54                    fdb    read_data 9 -  EE8C E455                    fdb    bad_cmd   10 -  EE8E E455                    fdb    bad_cmd   11 -  EE90 E455                    fdb    bad_cmd   12 -  EE92 E455                    fdb    bad_cmd   13 -  EE94 E455                    fdb    bad_cmd   14 -  EE96 E455                    fdb    bad_cmd   15 -  * clock_on  EE98 EECE                    fdb    SR4_IRQ  EE9A EEE8                    fdb    SR4_init  EE9C EEF6                    fdb    SR4_test                     *  EE9E EF73                    fdb    SR4ttconf  EEA0 EF9B                    fdb    SR4ttputc  EEA2 EF9E                    fdb    SR4ttgetc  EEA4 EFA1                    fdb    SR4ttnxr  EEA6 EFA8                    fdb    SR4ttdisx  EEA8 EFAF                    fdb    SR4ttnr  EEAA EFB6                    fdb    SR4ttnx  EEAC EFBD                    fdb    SR4ttnno  EEAE EFC4                    fdb    SR4ttxbsy  EEB0 EFC9                    fdb    SR4ttstx  EEB2 EFD1                    fdb    SR4ttiscts  EEB4 EFDD                    fdb    SR4ttstr  EEB6 EFE5                    fdb    SR4ttstb  EEB8 EFF4                    fdb    SR4ttsts  EEBA EFF6                    fdb    SR4ttstc  EEBC F004                    fdb    SR4ttstd  EEBE EFFF                    fdb    SR4ttste  EEC0 F007                    fdb    SR4ttnd  EEC2 F008                    fdb    SR4ttwcts  EEC4 F012                    fdb    SR4ttwdcd                     *                     * preset table for baudrates at each port                     *                     * baudrate latch backup bytes, for 2 acia's eachTask       Structure                 14:06:23  Mar 21, 2020   Page   87ACIA       interface routines                                            *                     * CB B2 B1 B0 CA A2 A1 A0       C=/CTS override, 0 = active                     * X2 X1 X0 are baudrate select bits 0K3/0K6/1K2/2K4/4K8/9K6/19K2/38K4                     * 111 is highest baudrate, 000 is lowest.                     *  EEC6 77            brbupr    fcb    $77       acia 0 and 1 board 1  EEC7 77                      fcb    $77       acia 2 and 3  EEC8 77                      fcb    $77       acia 4 and 5 board 2  EEC9 77                      fcb    $77       acia 6 and 7  EECA 77                      fcb    $77       acia 8 and 9 board3  EECB 77                      fcb    $77       acia 10 and 11  EECC 77                      fcb    $77       acia 12 and 13 board 4  EECD 77                      fcb    $77       acia 14 and 15               0008  BRTBSIZ   equ    *-brbupr                                          *                     * Check for and process an ACIA interrupt                     *  D - Device #                     *  X - Device address                     *  EECE 34   76       SR4_IRQ   pshs   d,x,y,u   save registers just in case  EED0 A6   84                 lda    csr,x     check for interrupt  EED2 85   80                 bita   #AS_IRQ  EED4 27   0E                 beq    10f       jump if no interrupt                     *  EED6 5F                      clrb  EED7 34   06                 pshs   d                     *  EED9 EC   62                 ldd    2,s       restore device #  EEDB BD   E8A2               jsr    tintr     go process interrupt  EEDE 32   62                 leas   2,s       remove device status  EEE0 1A   01                 sec              --         interrupt processed  EEE2 20   02                 bra    99f                     *  EEE4 1C   FE       10        clc              --         no interrupt processed                     *  EEE6 35   F6       99        puls   d,x,y,u,pc                                          *                     * Initialize ACIA port                     *   B - Device #                     *   X - Device address                     *  EEE8 34   76       SR4_init  pshs   d,x,y,u  EEEA 6F   02                 clr    2,x       init baudrate latch  EEEC 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  EEEE A7   84                 sta    0,x       reset acia  EEF0 34   06                 pshs   d         delay  EEF2 35   06                 puls   d  EEF4 35   F6                 puls   d,x,y,u,pc                                          *Task       Structure                 14:06:23  Mar 21, 2020   Page   88ACIA       interface routines                                            * Determine if CPU09SR4 ACIA board is present                     *  D - ACIA port address                     *  Y - Device table address                     *  <CS> if present & ACIA                     *  EEF6 34   56       SR4_test  pshs   d,x,u  EEF8 1F   03                 tfr    d,u  EEFA 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  EEFC A7   C4                 sta    0,u       reset acia  EEFE 34   06                 pshs   d         delay  EF00 35   06                 puls   d  EF02 A6   C4                 lda    0,u       check response  EF04 27   08                 beq    00f                     *  EF06 84   F3                 anda   #%11110011 todo: bit names  EF08 27   04                 beq    00f                     *  EF0A 1C   FE                 clc              --         not an 6350  EF0C 20   63                 bra    99f                     *                     * found an ACIA, fill in the port info                     *  EF0E 96   FB       00        lda    NUM_TRM   compute device table address  EF10 C6   08                 ldb    #DEV_SIZE  EF12 3D                      mul  EF13 108E 028E               ldy    #dev_tab  EF17 31   AB                 leay   d,y  EF19 96   FB                 lda    NUM_TRM  EF1B 46                      rora             2 ports for each baudrate backup  EF1C CE   02BA               ldu    #brbutb   address of table  EF1F 33   C6                 leau   a,u                     * account for 4 ports CPU09SR4  EF21 D6   FB                 ldb    NUM_TRM  EF23 CB   04                 addb   #4  EF25 D7   FB                 stb    NUM_TRM                     *  EF27 EC   E4                 ldd    0,s       port address  EF29 8E   EE78               ldx    #DEV_6850  EF2C ED   A4                 std    dev_addr,y device address  EF2E AF   22                 stx    dev_type,y handler dispatch table                     *         stu     dev_brbu,y   baudrate latch backup  EF30 34   02                 pshs   a  EF32 86   0F                 lda    #%00001111                     *         sta     dev_brmk,y   baudrate latch mask  EF34 A6   C9 EC0C            lda    (brbupr-brbutb),u get rom preset                     *         sta     0,u  EF38 35   02                 puls   a  EF3A 31   28                 leay   DEV_SIZE,y  EF3C C3   0004               addd   #4        offset to next ACIA  EF3F ED   A4                 std    dev_addr,y  EF41 AF   22                 stx    dev_type,y                     *         stu     dev_brbu,yTask       Structure                 14:06:24  Mar 21, 2020   Page   89ACIA       interface routines                         EF43 34   02                 pshs   a  EF45 86   F0                 lda    #%11110000                     *         sta     dev_brmk,y   baudrate latch mask  EF47 35   02                 puls   a  EF49 31   28                 leay   DEV_SIZE,y  EF4B C3   0004               addd   #4  EF4E 33   41                 leau   1,u       next backup location  EF50 ED   A4                 std    dev_addr,y  EF52 AF   22                 stx    dev_type,y                     *         stu     dev_brbu,y  EF54 34   02                 pshs   a  EF56 86   0F                 lda    #%00001111                     *         sta     dev_brmk,y   baudrate latch mask  EF58 A6   C9 EC0C            lda    (brbupr-brbutb),u get rom preset                     *         sta     0,u  EF5C 35   02                 puls   a  EF5E 31   28                 leay   DEV_SIZE,y  EF60 C3   0004               addd   #4  EF63 ED   A4                 std    dev_addr,y  EF65 AF   22                 stx    dev_type,y                     *         stu     dev_brbu,y  EF67 34   02                 pshs   a  EF69 86   F0                 lda    #%11110000                     *         sta     dev_brmk,y   baudrate latch mask  EF6B 35   02                 puls   a  EF6D 31   28                 leay   DEV_SIZE,y  EF6F 1A   01                 sec  EF71 35   D6       99        puls   d,x,u,pc                                                               *                     * ttconf                     *                     * Configure the port pointed at by the Y register.  The X                     * register is pointing to the terminal table.  All registers                     * except D should be preserved.                     *                       EF73 86   03       SR4ttconf lda    #AC_MRES  reset the acia  EF75 A7   A4                 sta    csr,y  EF77 34   06                 pshs   d         delay some here  EF79 35   06                 puls   d  EF7B A6   A4                 lda    csr,y     get status - see if acia is really here  EF7D 27   04                 beq    2f        if 0 status - then ok                     *  EF7F 85   F3                 bita   #$f3      see if funny status is ok  todo: bit names  EF81 26   10                 bne    4f                     *  EF83 A6   0F       2         lda    tbaud,x   get configuration word from table                                            EF85 8A   01                 ora    #AC_DV16  set up full configurationTask       Structure                 14:06:24  Mar 21, 2020   Page   90ACIA       interface routines                         EF87 A7   A4                 sta    csr,y     (no ints enabled & RTS brought high)                     *  EF89 86   77                 lda    #$77      *!*!*!*  tbaud2,x  EF8B A7   22                 sta    brr,y     baudrate latch                     *  EF8D A6   A4                 lda    csr,y     get new status  EF8F 85   08                 bita   #AS_NCTS  is CTS ok?  EF91 27   05                 beq    6f                     *  EF93 1A   04       4         sez              set        false status  EF95 1C   FE                 clc              show       wait for CTS  EF97 39                      rts              return                     *  EF98 1C   FB       6         clz              set        true status  EF9A 39                      rts              return                                                               *                     * ttputc                     *                     * Send the character in the B register to the ACIA.  All                     * registers should be preserved.  Y points to the device.                     *                       EF9B E7   21       SR4ttputc stb    dbuf,y    send character  EF9D 39                      rts              return                                                               *                     * ttgetc                     *                     * Get the character from the device and return in the B                     * register.  Y points to the device and all registers                     * should be preserved.                     *                       EF9E E6   21       SR4ttgetc ldb    dbuf,y    get the character  EFA0 39                      rts              return                                                               *                     * ttenxr                     *                     * Enable the transmit interrupts and leave the receive                     * interrupt enabled (it is enabled upon routine entry).                     * Y points to the device and X points to to the terminal                     * table entry.  Preserve all registers but D.                     *                     *                       EFA1 A6   0F       SR4ttnxr  lda    tbaud,x   get configuration  EFA3 8A   A1                 ora    #AC_TEIN+AC_REIN+AC_DV16 enable int bitsTask       Structure                 14:06:24  Mar 21, 2020   Page   91ACIA       interface routines                         EFA5 A7   A4                 sta    csr,y     send to acia  EFA7 39                      rts              return                                                               *                     * ttdisx                     *                     * Disable the transmit interrupt and leave the receive                     * interrupt enabled.  Y points to the device and X points                     * to the terminal table entry.  Preserve all but D.                     *                       EFA8 A6   0F       SR4ttdisx lda    tbaud,x   get configuration word  EFAA 8A   81                 ora    #AC_REIN+AC_DV16 set bits  EFAC A7   A4                 sta    csr,y     send to acia  EFAE 39                      rts              return                                                               *                     * ttenr                     *                     * Enable the receive interrupts only.  The transmit                     * interrupts should be turned off.  Y points to the device                     * and X point to the terminal table entry.  Preserve all                     * but the D register.                     *                       EFAF A6   0F       SR4ttnr   lda    tbaud,x   get configuration word  EFB1 8A   81                 ora    #AC_REIN+AC_DV16 set bits  EFB3 A7   A4                 sta    csr,y     send to acia  EFB5 39                      rts              return                                                               *                     * ttenx                     *                     * Enable the transmit interrupts only.  The receive                     * interrupts should be left disabled.  Y points to the                     * device and X points to the terminal table entry.                     * All registers but D shoud be preserved.                     *                       EFB6 A6   0F       SR4ttnx   lda    tbaud,x   get configuration word  EFB8 8A   21                 ora    #AC_TEIN+AC_DV16 set bits  EFBA A7   A4                 sta    csr,y     send to acia  EFBC 39                      rts              return                                                               *                     * ttenno                     *                     * Disable all interrupts from device and drop the RTSTask       Structure                 14:06:25  Mar 21, 2020   Page   92ACIA       interface routines                                            * line.  Y points to the device and X points to the                     * terminal table entry.  Preserve all but D register.                     *                       EFBD A6   0F       SR4ttnno  lda    tbaud,x   get configuration word  EFBF 8A   41                 ora    #AC_DRTS+AC_DV16 set bits  EFC1 A7   A4                 sta    csr,y     send to acia  EFC3 39                      rts              return                                                               *                     * ttxbsy                     *                     * Test if the transmit buffer is empty.  Return TRUE if                     * it is empty (N.E. status). Y points to the device and                     * all but A needs preserved.                     *                       EFC4 A6   A4       SR4ttxbsy lda    csr,y     get status  EFC6 85   02                 bita   #AS_TDRE  is it busy?  EFC8 39                      rts              return                                                               *                     * tttstx                     *                     * Test device pointed at by Y for a transmit interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       EFC9 A6   A4       SR4ttstx  lda    csr,y     get status  EFCB 85   02                 bita   #AS_TDRE  EFCD 26   08                 bne    SR4true  EFCF 20   09                 bra    SR4false                                                               *                     * ttiscts                     *                     * Test device pointed at by X for "Clear to Send"                     * -- Return TRUE (not equal) if yes                     *  EFD1 A6   A4       SR4ttiscts lda   csr,y     check for CTS  EFD3 85   08                 bita   #AS_NCTS  is CTS down?  EFD5 26   03                 bne    SR4false  EFD7 1C   FB       SR4true   clz              no         - return TRUE  EFD9 39                      rts  EFDA 1A   04       SR4false  sez              yes        - return FALSE  EFDC 39                      rts                                          Task       Structure                 14:06:25  Mar 21, 2020   Page   93ACIA       interface routines                                            *                     * tttstr                     *                     * Test device pointed at by Y for a receive interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       EFDD A6   A4       SR4ttstr  lda    csr,y  EFDF 85   01                 bita   #AS_RDRF  EFE1 26   F4                 bne    SR4true  EFE3 20   F5                 bra    SR4false                                                               *                     * tttstb                     *                     * Test device pointed at by Y for a "break" condition.                     * Return TRUE if found.  Preserve all registers but A                     * and return NULL in B (for break character).                     *                       EFE5 85   30       SR4ttstb  bita   #AS_OVRN+AS_FRME check for break condition  EFE7 27   0A                 beq    2f                     *  EFE9 E6   21                 ldb    dbuf,y    get character from acia  EFEB 34   76                 pshs   d,x,y,u   delay some here  EFED 35   76                 puls   d,x,y,u  EFEF A6   21                 lda    dbuf,y    get next garbage char if any  EFF1 1C   FB                 clz              set        true                     *  EFF3 39            2         rts              return                                                               *                     * tttsts                     *                     * Test device for "CTS" interrupt.                     *                       EFF4 20   E4       SR4ttsts  bra    SR4false  not currently implemented                                                               *                     * tttstc                     *                     * Test device pointed at by Y for drop "Carrier Detect"                     * type interrupt.  Return TRUE if so.  Preserve all registers                     * but A.                     *                       EFF6 85   04       SR4ttstc  bita   #AS_NDCD  check for carrier dropTask       Structure                 14:06:25  Mar 21, 2020   Page   94ACIA       interface routines                         EFF8 27   04                 beq    1f        jump if no error                     *  EFFA E6   21                 ldb    dbuf,y    read reg to reset status  EFFC 1C   FB                 clz              return     true                     *  EFFE 39            1         rts              return                                                               *                     * tttste                     *                     * Test device pointed at by Y for error conditions.                     * Handle all errors local to this routine - no status                     * returned.  Preserve all but A.                     *                       EFFF A6   21       SR4ttste  lda    dbuf,y    read data register to clear any interrupt conditions  F001 1A   04                 sez              return false clz     return     true  F003 39                      rts              return                                          *                     * tttstd - Test for drop in DTR                     *  F004 1A   04       SR4ttstd  sez              --         not supported by hardware  F006 39                      rts                                                               *                     * ttend                     *                     * Terminate i/o operation for device pointed at by Y.                     * Preserve all but D.                     *                       F007 39            SR4ttnd   rts              return     (nothing for acia)                                                               *                     * ttwcts                     *                     * Wait for CTS to go high (sleep on it).                     *                       F008 8D   AC       SR4ttwcts bsr    SR4ttnx   enable xmit ints only  F00A C6   EC                 ldb    #TTYOPR   set priority  F00C 10AE 04                 ldy    tqout,x   point to output q  F00F 7E   E6E5               jmp    sleep     sleep on CTS                                                               *                     * ttwdcd                     *Task       Structure                 14:06:25  Mar 21, 2020   Page   95ACIA       interface routines                                            * Wait for DCD to go high (sleep on it).                     *                       F012 39            SR4ttwdcd rts              currently  not implementedTask       Structure                 14:06:25  Mar 21, 2020   Page   96Debug Interface Routines                                                   F013               DB_main  F013 8D   4F                 bsr    DB_test   see if debug routines present  F015 6E   9F C002            jmp    [DEBUGROM+2]  F019               DB_pdata  F019 8D   49                 bsr    DB_test   see if debug routines present  F01B 6E   9F C004            jmp    [DEBUGROM+4]  F01F               DB_phex  F01F 8D   43                 bsr    DB_test   see if debug routines present  F021 6E   9F C006            jmp    [DEBUGROM+6]  F025               DB_phex2  F025 8D   3D                 bsr    DB_test   see if debug routines present  F027 6E   9F C008            jmp    [DEBUGROM+8]  F02B               DB_pcrlf  F02B 8D   37                 bsr    DB_test   see if debug routines present  F02D 6E   9F C00A            jmp    [DEBUGROM+10]  F031               DB_check  F031 8D   31                 bsr    DB_test   see if debug routines present  F033 6E   9F C00C            jmp    [DEBUGROM+12]  F037               DB_config  F037 8D   2B                 bsr    DB_test   see if debug routines present  F039 6E   9F C00E            jmp    [DEBUGROM+14]  F03D 34   17       DB_msg    pshs   cc,d,x  F03F AE   65                 ldx    1+2+2,s   get return address  F041 EC   81                 ldd    ,x++      get mask word  F043 B4   010D               anda   DB_cntrl  F046 F4   010E               andb   DB_cntrl+1  F049 34   04                 pshs   b  F04B AA   E0                 ora    ,s+  F04D 27   04                 beq    10f       jump if flag not set  F04F 30   02                 leax   2,x       skip over false address & fall through  F051 20   02                 bra    20f  F053 AE   84       10        ldx    ,x        get false branch label  F055 AF   65       20        stx    1+2+2,s   fix up return address  F057 35   97                 puls   cc,d,x,pc return                     *  F059               DB_pspace  F059               DB_outsp  F059 34   16                 pshs   d,x  F05B 8E   F062               ldx    #00f  F05E 8D   B9                 bsr    DB_pdata  F060 35   96                 puls   d,x,pc  F062 20 00         00        fcc    ' ',0                       F064 34   07       DB_test   pshs   cc,d  F066 FC   C000               ldd    DEBUGROM  Debug rom present?  F069 1083 1234               cmpd   #$1234    special marker  F06D 27   05                 beq    99f       yes - exit  F06F 35   07                 puls   cc,d      no - abort DB_xx function  F071 32   62                 leas   2,s  F073 39                      rts  F074 35   87       99        puls   cc,d,pc   returnTask       Structure                 14:06:26  Mar 21, 2020   Page   97Debug Interface Routines                                                                                                     endTask       Structure                 14:06:26  Mar 21, 2020   Page   98Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AC_8N1   0014   AC_DIV0  0001   AC_DIV1  0002   AC_DRTS  0040   AC_DV16  0001   AC_MRES  0003   AC_REIN  0080   AC_SET   0015   AC_TEIN  0020   AC_WS0   0004   AC_WS1   0008   AC_WS2   0010   AS_FRME  0010   AS_IRQ   0080   AS_NCTS  0008   AS_NDCD  0004   AS_OVRN  0020   AS_PERR  0040   AS_RDRF  0001   AS_TDRE  0002   B        0009   BASE_SLO 8000   BRTBSIZ  0008   BSECH    0020   BSPCH    007F   CBSIZE   0020   CC       000A   CHRLIM   00FE   CLISTS   027E   CLOCK    8070   CLOCKI   8071   CLOCKPR  FFC4   CNCLC    0018   CNTRL    0080   CPU_down E03D   CPUtraps FFF0   CR       000D   CRMOD    0010   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check F031   DB_cntrl 010D   DB_confi F037   DB_iflg  010C   DB_main  F013   DB_msg   F03D   DB_outsp F059   DB_pcrlf F02B   DB_pdata F019   DB_phex  F01F   DB_phex2 F025   DB_pspac F059   DB_test  F064   DBmsg00  E000   DBmsg01  E009   DBmsg02  E029   DEBUG    0D04   DEBUGROM C000   DEBUG_CO 0000   DEV_6850 EE78   DEV_BAD  E458   DEV_SIZE 0008   DLE      0010   DLE_GOT  0040   DLE_SENT 0020   DO_HISTO 0001   DO_IXON  0000   DP       000B   DSR_OK   0001   D_CLOCK  001E   D_CLOSE  0004   D_END    0026   D_INTRPT 0014   D_OPEN   0002   D_RQRD   0010   D_RQWR   000A   D_SEND   0012   D_TTYG   0008   D_TTYS   0006   D_WRC    000E   D_WRITE  000C   D_init   0022   D_inthan 0020   D_test   0024   D_ttconf 0026   D_ttdisx 002E   D_ttend  0048   D_ttenno 0034   D_ttenr  0030   D_ttenx  0032   D_ttenxr 002C   D_ttgetc 002A   D_ttisct 003A   D_ttputc 0028   D_tttstb 003E   D_tttstc 0042   D_tttstd 0044   D_tttste 0046   D_tttstr 003C   D_tttsts 0040   D_tttstx 0038   D_ttwcts 004A   D_ttwdcd 004C   D_ttxbsy 0036   E        000E   ECHO     0002   EOTCH    0004   ESCOFF   0080   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SYSBSY 0082   F        000F   FF       0040   FIFO_SIZ 0080   FIFO_get E3C6   FIFO_put E3EA   FIFOgeta E3BD   FIFOputa E3E2   FIOPRI   FFCE   FIO_get  E39B   FIO_lock 0134   FIO_rel  E3B0   HANGS    0001   HOLD     0002   HOLDC    001B   HRECSIZ  0004   H_cpu    E5B7   H_iop    E5DB   IF       0010   INTRC    0003   INTS     0002   IO_end   E43C   IO_han   E401   IRQ_han  E47B   IRQmsg10 E51E   IXONXOF  0010   LCASE    0008   MAXHIST  0010   MAX_CL   007C   MAX_DEV  0005   MAX_NEC  0000   MAX_OB   0400   MAX_PPR  0000   MAX_TI   000A   MAX_TRAN 0018   MAX_TSK  0028   MAX_TTY  0004   MIN_OB   0120   MIN_TSK  0020   MOD_SIZE 0004   NECADR   02B8   NEC_IQ   02B6   NECstr   028C   NEXT_SLO 0010   NL       000A   NUM_CL   00FA   NUM_NEC  00FC   NUM_PPR  00FD   NUM_TRM  00FB   NUM_TSK  00F9   OBUFRS   0284   OBUF_SIZ 0100   OQHI     0102   OQH_SIZE 000A   OQLO     0104   O_BAUDR  00B0   O_BAUDW  00C0   O_CLOSE  0020   O_INTRPT 00A0   O_OPEN   0010   O_RQRD   0080   O_RQWR   0050   O_SEND   0090   O_TTYG   0040   O_TTYS   0030   O_WRC    0070   O_WRITE  0060   PC       0005   PPstr    028A   PRCSIZ   0100   PROTOCOL 00F8   QH_SIZE  0005   QUITC    001C   QUITS    0003   RAMend   6FFF   RAMorg   0100   RAMscrat 7000   RAMscren 7F00   RAW      0001   REJECT   0080   ROMLOorg E000   ROM_ERR  E0B4   ROM_VERS 0012   ROMstack 7FFF   RUNPRI   0046   R_BAUD   000D   R_CLOCK  000C   R_CLOSE  0003   R_INTRPT 000A   R_OPEN   0002   R_RD1C   0009   R_RDOK   0007   R_REQOK  0004   R_RESET  0001   R_SNDMC  000B   R_SNDNC  0008   R_TTY    0006   R_WRITE  0005   Task       Structure                 14:06:27  Mar 21, 2020   Page   99Debug Interface Routines                            S        0004   SCHR     0040   SEND_DLE 0008   SEND_XOF 0004   SEND_XON 0002   SPACE    0020   SR4_IRQ  EECE   SR4_SLOT 0003   SR4_init EEE8   SR4_name E30D   SR4_test EEF6   SR4false EFDA   SR4true  EFD7   SR4ttcon EF73   SR4ttdis EFA8   SR4ttget EF9E   SR4ttisc EFD1   SR4ttnd  F007   SR4ttnno EFBD   SR4ttnr  EFAF   SR4ttnx  EFB6   SR4ttnxr EFA1   SR4ttput EF9B   SR4ttstb EFE5   SR4ttstc EFF6   SR4ttstd F004   SR4ttste EFFF   SR4ttstr EFDD   SR4ttsts EFF4   SR4ttstx EFC9   SR4ttwct F008   SR4ttwdc F012   SR4ttxbs EFC4   SYS_ACIA 8000   SYS_TABS 02BC   TABCH    0009   TFREE    0004   TIMOUT   0001   TIQPRI   FFD8   TI_HAN   E55C   TI_Q     011E   TI_Q_ptr 0132   TOPEN    0004   TOPWOC   0010   TRANSPNT 0008   TRUN     0001   TSKSIZ   0080   TSLEEP   0002   TSYS     0005   TTYIPR   FFF6   TTYLOCK  FFDD   TTYOPR   FFEC   TTYQS    0282   TTYSIZ   001F   TTYSPR   FFE2   TTYTABS  0280   TWAIT    0003   U        0003   USTSIZ   006C   V        0007   W        0006   X        0001   XANY     0020   XOFFC    0013   XOF_SENT 0010   XONC     0011   XONXOF   0040   XTABS    0004   Y        0002   bad_cmd  E455   bad_dev  E478   brbupr   EEC6   brbutb   02BA   brr      0002   cbchrs   0002   cbstrt   0000   cbufct   011B   cfreel   0119   change   E5FF   chproc   0118   clcnt    0000   clfst    0001   clini2   E24A   clinit   E242   cllst    0003   clock_ti 013B   close_tt ED9D   cpu_iop  0004   cpu_iop1 0005   cpu_iop2 0006   cpu_iop3 0007   cpu_iopF 00FF   csr      0000   dbuf     0001   dev_addr 0000   dev_brbu 0004   dev_brmk 0006   dev_spar 0007   dev_tab  028E   dev_type 0002   end_vars 6FFF   fifo     0010   fifo_cnt 0008   fifo_get 0009   fifo_put 000B   fio_msg  E347   fio_rese E316   fio_resp E385   fio_star E07C   fio_wait E32A   flushi   EC41   flusho   EC16   flusht   EBEE   fluso0   EC1D   fluso1   EC25   get_oq   E7D6   getc     E738   getc1    E753   getc2    E761   getc3    E775   getc4    E77A   getjo1   E647   getjo2   E656   getjo4   E65D   getjo6   E666   getjo8   E668   getjob   E641   hst_cmd  0000   hst_seq  0001   hst_tty  0002   hst_val  0003   hstbuf   023C   hstptr   027C   idle     011D   int_all  E536   int_buf  0135   int_ptr  0139   iop_cpu  0000   iop_cpu1 0001   iop_cpu2 0002   iop_cpu3 0003   iop_cpuF 00FE   jobpri   0117   lcbuf    011C   lcht     EAE9   makrd6   E6C0   makrdy   E6AB   mod_name 0002   mod_tbl  E307   mod_type 0000   no_dev   E22D   open_tty ED97   oq_buf   0002   oq_count 0000   oq_end   0008   oq_get   0006   oq_put   0004   prcbuf   013C   put_oq   E7FA   putc     E780   putc1    E79E   putc2    E7C1   putc3    E7CE   putc4    E7D0   putru1   E67F   putru2   E686   putru4   E694   putru5   E6A3   putru6   E6A7   putrun   E672   read_dat ED54   req_read ED2C   req_writ EDA3   rom_bad  E0B2   rom_firq E085   rom_init E05A   rom_int  E0A7   rom_nmi  E07F   rom_swi  E08C   rom_swi2 E092   rom_swi3 E099   rom_trap E0A0   rsche2   E616   rsche3   E62A   rsched   E605   runlst   010F   send_TI  E59A   send_int EE5D   set_tabl E0F6   sleep    E6E5   sleep7   E70D   slot_tbl 0106   slplst   0111   stbinit  E0C1   sto_chk  E234   swtchu   E636   sys_vars 0100   taddr    0006   tbaud    000F   tbaud2   0010   tbksp    000D   tcncl    000E   tcolm    000C   tdel     000B   tdelay   0009   tdevic   000A   tflags   0008   tintr    E8A2   tintr2   E8D0   tintr3   E8D8   tintr4   E8E6   tintr5   E8EE   tintr6   E8F6   tintr7   E8FE   tintr8   E905   tintr9   E91E   tlock    0014   tqin     0000   tqout    0004   tqproc   0002   tregs    0017   tscmd    000A   tsdev    0008   tsevnt   0006   tskend   0288   tskinit  E2B3   tsktab   0286   tslink   0000   tsold    0015   tsprir   0005   tsseq    000B   tssgnl   0009   tsslnk   0002   tsstat   0004   tstate   0011   tstate2  0012   tstate3  0013   tstval   000D   ttcls    E865   ttdop5   E840   ttdop6   E84B   ttdopn   E828   ttftab   E88B   ttopn    E813   ttopn8   E820   ttyget   E994   ttyi25   EB0D   ttyi27   EB10   ttyi33   EB22   ttyi34   EB2A   ttyi35   EB39   ttyi36   EB3D   ttyi44   EB4B   ttyi46   EB56   ttyi65   EBA5   ttyi67   EBAF   ttyi85   EBE7   ttyin    EAF4   ttyin0   EAFC   ttyin2   EB00   Task       Structure                 14:06:27  Mar 21, 2020   Page  100Debug Interface Routines                            ttyin3   EB13   ttyin4   EB45   ttyin5   EB81   ttyin6   EB8F   ttyin7   EBB1   ttyin8   EBCD   ttyin9   EBED   ttyinit  E264   ttyo12   EA54   ttyo14   EA64   ttyo22   EA81   ttyo23   EA85   ttyo24   EA96   ttyo75   EAB9   ttyo77   EAC7   ttyoe1   EAE8   ttyou2   EA6F   ttyou4   EA9A   ttyou6   EAAB   ttyou8   EAD5   ttyoue   EADB   ttyout   EA3D   ttyren   E9D8   ttys45   E9B8   ttys55   EA23   ttyset   E923   ttysg5   E9BA   ttyst    E9F0   ttyst1   EA03   ttyst15  EA0C   ttyst2   EA1D   ttyst6   EA24   ttyst65  EA2F   ttyst9   EA37   ttywrt   ED7A   umark0   0010   umark1   0012   usp      000E   utask    0115   wakeu2   E6CC   wakeu3   E6D3   wakeu4   E6D7   wakeu5   E6D9   wakeup   E6C1   write_da EDEB   wrt_sc   EE29   xmtint   E71A   xtca32   ECD1   xtca33   ECE2   xtp315   ECCA   xtpr21   EC89   xtpr22   EC91   xtpr25   ECA9   xtpr31   ECB5   xtpr45   ED02   xtprc0   EC6C   xtprc1   EC76   xtprc2   EC7D   xtprc3   ECAB   xtprc4   ECEE   xtprc5   ED12   xtprc6   ED1C   xtprc7   ED27   xtprcq   EC54   