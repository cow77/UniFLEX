        lib     ../include/flpdrvr.h        lib     ../include/blktab.h        lib     ./gendrvr.h        if      (FLP=1)        sttl     Floppy Drivers        pag        name    flpdrvr        global  flpopen,flpclos,flpio,flpirq        global  flopen,flclos,flread,flwrit,flspcl        global  flpdt,flpchb* Device Tables** dtdfl rmb     2       device buffer fwd link* dtdbl rmb     2       device buffer bwd link* dtqfl rmb     2       device io queue fwd link* dtqbl rmb     2       device io queue bwd link* dtbusy        rmb     1       device busy flag* dtrtry        rmb     1       device error retry count* dtspr rmb     2       device spare byteflpdt   rzb     DVTSIZ          device table* buffer header for character deviceflpchb  rzb     HDRSIZ          buffer header*FDtable fdb     0               Block Device Table addressflpopt  fcb     0,0,0,0        flp open tableflpcur  fcb     0** open the flp disk drive - insure the device is online, etc.* B contains device minor*flpopen pshs    d        ldx     #flpopt        lda     b,x        beq     flpop2        inc     b,x        bra     flprtsflpop2        jsr     flopen          do character open stuff        lda     #1        sta     flpdpr+flnwop  new open        stb     flpdpr+fldriv        ldd     0,s        bsr     frdsir          read SIR        bne     flpop3        pshs    y               save buffer        ldx     0,s             bug ptr        ldy     #flpdpr+flttyp  data location        ldu     #sdenf          offset in SIR        ldd     #2              2 bytes(ttyget/set)        jsr     cpybts        puls    y        jsr     freebf        puls    d,pcflpop3  lda     #EIO        sta     uerrorflprts  puls    d,pc* flp closeflpclos        ldx     #flpopt        dec     b,x             dec open counter        bpl     flpcl1        clr     b,x             clear open statusflpcl1  rts                     return** frdsir, read floppy SIR into a buffer*frdsir  ldx     #1        ldy     #0        jsr     rdbuf        lda     bfflag,y        bita    #BFERR        rts** fire up FLP operation to initiate transfer*flpio   stx     FDtable         save Block Device Table address        inc     flpdt+dtbusy    mark busy        ldb     bfdvn+1,y       get device #        ldu     #flpdpr*        ldd     bfxfc,y         get transfer count        cmpd    #512            is it regular block transfer?        bne     01f*        std     fltsiz,u        size        lda     #1              set func        sta     flpdt+dtrtry        sty     flbfhdr,u       ref        lda     bfflag,y        R/W        ora     #%01000000      make result always non-zero        sta     flrwflg,u        anda    #BFRWF        bne     02f             read=1** write, transfer data to FIFO*        pshs    b,x,y,u        tfr     y,x             map buffer and        jsr     mapbpt          X points now to SBUFFER @ OFFSET        ldwi    512             size        leau    flpfifo,u        tfm1    X,U            transfer data from buffer to system space        puls    b,x,y,u*02      lda     bfblch,y        BLOCK# H/M/L        sta     flblkh,u        ldd     bfblck,y        std     flblkm,u*        lda     #$ff        sta     flptel,u        rts*01      lda    #EBDEV        sta    uerror        lda    bfflag,y        ora     #BFERR        sta   bfflag,y*flpfin  clr     flpdt+dtrtry    erase function        rts*flpirq  equ     *        ldu     #flpdpr        clr     flpint,u          set we saw it*        ldy     flpdt+dtqfl     get last transaction        beq     flpfin        ldb     flstat,u             result        bmi     flprr1*        lda     bfflag,y        bita    #BFRWF          read=1        beq     03f** interrupt context, be careful, buffer may be in use*        ldb     DATBOX+SBUF     save DAT setting        pshs    b,x,y,u        tfr     y,x             map buffer and        jsr     mapbpt          X points now to SBUFFER @ OFFSET        ldwi    512             size        leau    flpfifo,u        tfm1    U,X            transfer data from system to buffer        puls    b,x,y,u        stb     DATBOX+SBUF    restore DAT setting*03      bra     flpdonflprr1  andb    #%01111111        stb     bfstat,y        lda     bfflag,y        ora     #BFERR        sta     bfflag,y*flpdon  clr     flpdt+dtbusy    set unbusy        clr     flpdt+dtrtry    clear funtion        ldx     FDtable        jmp     BDioend**  character open*flopen  equ     *        ldx     #flpopt        cmpb    #0        bhi     flchop4        inc     b,x        bra     flchop5*flchop4 lda     #EBARG        sta     uerrorflchop5 rts** character close*flclos  jmp     flpclos** flchrd*flread  equ     *        pshs    d       save device number        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure buffer        tst     uerror  OK?        beq     fchrd4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchrd4  pshs    a       save task mode byte        orb     #BFRWF  set read        stb     bfflag,y save        bra     fchio** flchwr*flwrit  equ     *        pshs    d       save device info        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure        tst     uerror  OK        beq     fchwr4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchwr4  pshs    a       save task mode bytefchio   ldb     #FLmajor        jmp     blkcio** fchcn** Configure the buffer header pointed at by Y.* This routine sets up the character device info* from the user block and puts it in the buffer* header such that the device drivers can use* the informationfor the transfer* this routine is specific for the floppy driver*fchcn   std     bfdvn,y save device info        ldd     uicnt   xfr count        std     bfxfc,y        cmpd    #128    check valid numbers        beq     fcnch4        cmpd    #256        beq     fcnch4        cmpd    #512        beq     fcnch4        cmpd    #1024        beq     fcnch4** above are valid sector sizes*        cmpd    #3050   track 5" SD        beq     fcnch2        cmpd    #5100   track 8" SD        beq     fcnch2        cmpd    #6100   track 5" DD        beq     fcnch2        cmpd    #10200  track 8" DD        beq     fcnch2        cmpd    #12200  track HD        beq     fcnch2  if not, error*fcnch8  lda     #EBARG  set error        sta     uerror        rts*fcnch2  lda     bfflag,y        ora     #BFSPC  special bit for drivers        sta     bfflag,y*fcnch4  jmp     blkcnf*** flspcl*flspcl        tfr     x,y        ldu     #flpdpr        cmpy    #0        bne     01f        ldd     usarg0        std     flttyp,u        rts01      ldd     flttyp,u        std     0,x        endif        end