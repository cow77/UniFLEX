** GPPFLPDRV, ROM code for CPU09GPP with 09FLP add-on** supports:  read block 128,256,512 byte size*            write block 128,256,512 byte size*            read track 125kBit, 250kBit, 500 kBit rate*            write track 125kBit, 250 kBit, 500 kBit rate**            supports 8", 5.25" and 3.5" in single /*            double side and single / double / high density***            runs with Interrupts disabled**        lib     gppflpdrv.h        org     RAMBASEside    rmb     1       intermediate datalside   rmb     1       latch sidetrack   rmb     1sector  rmb     1latch   rmb     1lstdrv  rmb     1       last selected drivetrktab  rmb     2       track numbers / driveunbias  rmb     1       unbiased sectors*step    rmb     1       debug for progresswrkprm  rmb     2       pointer to drive info table entryretry   rmb     1       retry count        rmb     STACKSZromstck equ     *RAMEND  equ     *        org     BUFFERtrkbuf  rmb     12500           track buffer        org     ROMBASE** configuration constants*steprt  fcb     0               step rate modifierrretry  fcb     4drvsel  fcb     LA_DS0,LA_DS1 driver select bytesparstab fcb     CMDRSC,0        fdb     do_rdsc        fcb     CMDWSC,0        fdb     do_wrsc        fcb     CMDRTK,0        fdb     do_rdtk        fcb     CMDWTK,0        fdb     do_wrtk        fdb     0,0             end of table** cold start*reset   equ     *        seti        lds     #romstck*        ldx     #flpdpr         go clear the Dual Port Ram        clrd01      std     0,x++        cmpx    #flpdpr+flptel        blo     01b*        ldx     #RAMBASE02      std     0,x++        cmpx    #RAMEND        blo     02b        ldx     #flpdfl        stx     wrkprm          set pointer** normally the driver loops here*warm    equ     *        seti        lds     #romstck*01      jsr     flpcmd        beq     01b             wait*        ldy     #fdcbas         floppy HW base address        ldb     flpdpr+fldriv   get drive        ldx     #drvsel        abx        ldb     latch        andb    #$f0            leave these intact        pshs    b        ldb     0,x        orb     0,s+        stb     latch           clean higher bits* update other information        lda     flpdpr+fltden        clr     unbias        bita    #%00000010      unbiased?        beq     setd6        inc     unbias        incasetd6   bita    #%00000001      DD?        bne     setd7        oime    LA_SDN,latch      set SD        bra     setd0setd7   aime    255-LA_SDN,latch  set DD (latch bit = 0)*setd0   lda     flpdpr+fltsid        anda    #%00000011       DS / UNBIASED        sta     side             set side capabilities*setd1   lda     flpdpr+fltsid        bita    #%01000000      5/8" select        beq     setd2        oime    LA_8_5,latch        bra     setd3*setd2   aime    255-LA_8_5,latch  set 8" (latch bit = 0)setd3   ldb     latch        stb     fo4lat,y        set latch*        jsr     chkrdy          see if drive is on-line        tsta        bne     flerr*        lda     flpdpr+flnwop   new open?        beq     04f             yes, skip forced restore** retry loops here*skretry jsr     restore         restore drive        anda    #%10010101        cmpa    #%00000100      should be there        bne     flerr*04      clr     flpdpr+flnwop   remove flag*        ldb     #1              set progress        stb     step*        clr     flpdpr+flstat   initialize error status*        ldb     latch        stb     fo4lat,y        jsr     chkrdy          drive still ready?        tsta        bne     flerr*06      jsr     srchpm          scan drive table*        ldb     #2        stb     step        lda     flpdpr+flrflg   check command for valid        anda    #CMDMSK        ldx     #parstab        search function21      cmpa    0,x        beq     20f        leax    4,x        tst     0,x        bne     21b*        lda     #FD_ERR+63        bra     flerr*20      jsr     [2,x]*flerr   sta     flpdpr+flstat*fend    ldb     #7        stb     step        tsta                    error        beq     fend1        ldb     retry        eorb    #1        stb     retry        lbne    skretryfend1   nop        bsr     flpack*        jmp     warm**  write POSTBOX to other CPU I'm done*flpack  ldb     #6        stb     step        clr     flpdpr+flptel   acknowledge main CPU        lda     #$ff        sta     flpdpr+flpint   tell him I'am done        rts** flpcmd, test POSTBOX for new data from main CPU*flpcmd  lda     flpdpr+flptel   command present?        rts** Y = fdcbase*do_rdsc equ     *        ldb     #3        stb     step*        jsr     clcpos          block# -> trk/sec/sid        tsta        bne     frder           error*        ldb     #4        stb     step        jsr     fseek        tsta        bne     frder*        ldb     #5        stb     step        ldu     #flpdpr+flpfifo        ldx     flpdpr+fltsiz        lda     #FD_SRD        jsr     frdblk*frder   rts** Y = fdcbase*do_wrsc equ     *        ldb     #3        stb     step*        jsr     clcpos          block# -> trk/sec/sid        tsta        bne     fwder           error*        ldb     #4        stb     step        jsr     fseek        tsta        bne     fwder*        ldb     #5        stb     step        ldu     #flpdpr+flpfifo        ldx     flpdpr+fltsiz        lda     #FD_SWR        jsr     fwrblk*fwder   rts**TODO*do_rdtk equ     *        ldu     #trkbuf        ldy     flpdpr+fltsiz        lda     #FD_RTR        jsr     frdblk        jsr     flpack        rts** We arrive here when the DPR contains the first BUFSIZ* bytes of the track image*do_wrtk equ     *        pshs    x,y,u        ldx     #trkbuf* copy DPR data to trkbuf03      nop        ldu     #flpdpr+flpfifo        ldwi    BUFSIZ        tfm1    U,X        ldd     flpdpr+fltxfr        cmpd    flpdpr+fltsiz   we have all        bhs     02f        clra        jsr     flpack          tell hime I took it*01      tst     fo4sta,y        keep motor running        jsr     flpcmd          wait for next data        beq     01b             postbox empty        bra     03b             loop until all* all data present02      nop                     TRAP        ldx     0,s             old X        ldb     #3        stb     step*        lda     flpdpr+flblkl   track address << 1 + side bit        clrb        lsra                    strip side bit        bcc     08f        incb08      stb     lside*        sta     track        lda     #1        sta     sector*        ldb     #4        stb     step        jsr     fseek        tsta        bne     10f** restore the registers for the write*        ldb     #5        stb     step        ldu     #trkbuf        ldx     flpdpr+fltsiz        lda     #FD_WTR        jsr     fwrblk*10      puls    x,y,u,pc** code routine, to read one dataset from FDC* U = buffer address,* Y = base address hardware* X = count* A = command** can read sector or track* drive select, density and such alreay set up* time out from INT fdc*frdblk  equ     *        pshs    x,y,u*        eora    #EOR4FDC        sta     fo2cmd,y*01      orcc    #$50            disable ints        bra     03f* loop here02      lda     fo2dat,y         get data        eora    #EOR4FDC        sta     0,u+             transfer* poll fdc for DRQ03      lda     fo4sta,y        bmi     02b        bita    #ST_INT         INT        beq     03b*        lda     fo2cmd,y        read status        eora    #EOR4FDC*99      puls    x,y,u,pc** code routine, to write one dataset to the FDC* U = buffer address* Y = hardware base* X = count* A = command** drive select, density and such alreay set up* time out from INT fdc*fwrblk  equ     *        pshs    x,y,u*        eora    #EOR4FDC        sta     fo2cmd,y*01      orcc    #$50            disable ints        bra     03f02      lda     0,u+        eora    #EOR4FDC        sta     fo2dat,y        put data*03      lda     fo4sta,y        bmi     02b        bita    #ST_INT         INT        beq     03b*        lda     fo2cmd,y        read status        eora    #EOR4FDC*99      puls    x,y,u,pc** clcpos, transfer block# into track/sector/side** Y = fdcbase*clcpos  equ     *        pshs    x,y,u        clr     lside           result side of calc*        ldx     wrkprm          fresh copy of drive params        ldd     flpdpr+flblkm   block no M/L*        ldy     flpdpr+fltsiz   check transfer size* calculate00      clr     0,-s            track = 0*02      subd    3,x             sec/trk        bmi     01f*        inc     0,s             up track #        bra     02b*01      addd    3,x             adjust* sector in B, track# on stack        tst     side            is double sided?        beq     05f             no*        lsr     0,s            track# / 2        bcc     05f            even track* odd track, add bias        inc     lside* TEST Biased here! TODO        tst     unbias        bne     05f             no        addb    4,x            biased sector#*05      incb                    1 relative        stb     sector          set sector#*        puls    a               track# from stack        sta     track           set track#08      cmpa    2,x             test against max**!!    bhi     91f        clra                    set OK        puls    x,y,u,pc* errors91      lda     #FS_SKER        track > max        puls    x,y,u,pc*** fseek, move head to track#, set registers* Y = hardware base*fseek   equ     *        pshs    x,y,u        oime    $80,latch        tst     lside        beq     lsk1        oime    LA_SID,latch     1 = side 1        bra     lsk2lsk1    aime    255-LA_SID,latch 0 = side 0lsk2    lda     latch        sta     fo4lat,y*        lda     sector         set sector number        eora    #EOR4FDC        sta     fo2sec,y*        lda     track        eora    #EOR4FDC        cmpa    fo2trk,y**!!    beq     04f*        sta     fo2dat,y        lda     #FD_SEK        ora     steprt          update steprate        eora    #EOR4FDC        sta     fo2cmd,y*01      lda     fo4sta,y        bita    #ST_INT        beq     01b*04      lda     latch        sta     fo4lat,y        lda     fo2cmd,y        eora    #EOR4FDC        anda    #!(FS_TRK0|FS_IDX|FS_HLD)    remove these from status* check if we need to pass write protect        ldb     flpdpr+flrflg        bitb    #%00010000           command is read        beq     02f        anda    #!FS_WRP02      puls    x,y,u,pc** chkrdy, check if drive is ready* Y = fdcbase*chkrdy  ldb     #7              multiply*10      ldx     #$7fff          long delay*11      lda     fo2cmd,y        eora    #EOR4FDC        bpl     12f*        lda     latch        sta     fo4lat,y        leax    -1,x            decrement counter        bne     11b*        decb                    multiply        bne     10b*        lda     #FS_NRDY*12      anda    #%10000000      only ready is of interest        rts** restore, set drive at track 0* Y = fdcbase*restore clrb19      lda     #FD_RST        ora     steprt          adjust        eora    #EOR4FDC        sta     fo2cmd,y20      lda     fo4sta,y        tst     fo4lat,y       ??        bita    #ST_INT        beq     20b        clr     track           update info        lda     fo2cmd,y        eora    #EOR4FDC        bita    #FS_SKER        beq     21f        tstb        bne     21f        incb        bra     19b*21      rts** srchpm, search drive param table, used for track/sector calculations* Y = fdcbase*srchpm  pshs    x,y,u        ldx     #fltabl         start table        ldd     flpdpr+fltsid   get ttyset/ttyget bytes        anda    #%01000000      side bits        bitb    #%00000010      non bias?        beq     33f        incb33      andb    #%11000001      dens bits31      cmpd    0,x        beq     30f        leax    6,x             size of entry        tst     2,x        bne     31b        ldx     #flpdfl*30      stx     wrkprm        puls    x,y,u,pcfltabl  equ     *flpdfl  fcb     $00,$00,76,0,8,0      FD-XS        fcb     $00,$01,76,0,16,0     FD-DX        fcb     $40,$00,79,0,5,0      F5-SX        fcb     $40,$01,79,0,9,0      F5-XD        fcb     $40,$41,79,0,10,0     F5-XDE        fcb     $00,$81,79,0,18,0     F3-XD        fcb     $00,$c1,79,0,20,0     F3-XH        fcb     0,0,0,0,0,0* all process registers stackednmihnd  equ     *        if      (DBG=1)        rti        endif** signal any interrupt at location in DPR*rtiend  lda     #$55        sta     flpdpr+$03f8    give warning in DPR        rti        org     VECTORS        fdb     rtiend        fdb     rtiend        fdb     rtiend        fdb     rtiend        fdb     rtiend        fdb     rtiend        fdb     nmihnd        fdb     reset        end