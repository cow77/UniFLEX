               0001  NET       set    1                               opt    exp  0000                         absSWTPc      Intelligent I/O Proce     13:54:15  Jan 06, 2024   Page    1Hardware   Definitions                                                                                                                  *       lib ../include/sysdefs.h                     *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100                     *EBUG_CONTROL set     %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0001  DO_HISTORY set   1         Include transaction history mechanism                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFD8  SIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIO               FFC4  SKPRI     equ    -60       Waiting for socket interrupt               FFBA  POLPRI    equ    -70       poliing priority                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)                                          * -- Configuration constants                                    0009  MAX_TI    equ    9         # Queued terminal interrupts                     *               0001  MAX_DEV   equ    1                     *                     SWTPc      Intelligent I/O Proce     13:54:16  Jan 06, 2024   Page    2Macro Definitions                                                                             *                     * This file contains all the standard macro definitions                     * used in the system.                     *                                    0040  FF        equ    %01000000 FIRQ interrupt mask               0010  IF        equ    %00010000 IRQ interrupt mask                                          * register references               0000  D         equ    0               0001  X         equ    1               0002  Y         equ    2               0003  U         equ    3               0004  S         equ    4               0005  PC        equ    5               0006  W         equ    6               0007  V         equ    7               0008  A         equ    8               0009  B         equ    9               000A  CC        equ    10               000B  DP        equ    11               000E  E         equ    14               000F  F         equ    15                                          * indexed addressing in macro's               0000  IX        equ    0               0001  IY        equ    1               0002  IU        equ    2               0003  IS        equ    3                                                               *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #FF|IF                               endm                                          *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(FF|IF)                               endm                     SWTPc      Intelligent I/O Proce     13:54:16  Jan 06, 2024   Page    3Macro Definitions                                                                                                  *                     * debug macro                     *                                          *dbugm macro output_character                     * lda #'&1                     * lbsr syspch                     * endm                                          *                     * HD6309 MACRO's                     *                                          ldmd      macro                               fdb    $113d                               fcb    &1                               endm                                          * load W immediate                     ldwi      macro                               fdb    $1086                               fdb    &1                               endm                                          * load W direct                     *ldwd    macro                     *        fdb     $1096                     *        fcb     &1&0xff                     *        endm                                          * load W indexed                     ldwx      macro                               fdb    $10A6                               doindx &1,&2                               endm                                          * load W extended                     *ldwe    macro                     *        fdb     $10b6                     *        fdb     &1                     *        endm                                          * load E indexed                     ldex      macro                               fdb    $11a6                               doindx &1                               endm                                          ordx      macro                               fdb    $10aaSWTPc      Intelligent I/O Proce     13:54:16  Jan 06, 2024   Page    4Macro Definitions                                                                  doindx &1,&2                               endm                                          doindx    macro                               if     (&1=0)                               fcb    $84+(&2<<5)                               else                               if     (&1<16)                               fcb    (&2<<5)+(&1&$0f)                               else                               if     (&1>-16)                               fcb    (&2<<5)+($10)+(&1&$0f)                               else                               if     (&1<128)                               fcb    $88+(&2<<5),(&1&$7f)                               endif                               endif                               endif                               endif                               endm                                          * push W on system stack                     pshsw     macro                               fdb    $1038                               endm                                          * pull W from sytemstack                     pulsw     macro                               fdb    $1039                               endm                                          * memory move ++,++                     tfm1      macro                               fdb    $1138                               fcb    &1<<4|&2                               endm                                          * move memory++ to location                     tfm3      macro                               fdb    $113a                               fcb    &1<<4|&2                               endm                                          * move location to memory++                     tfm4      macro                               fdb    $113b                               fcb    &1<<4|&2                               endm                                          * logical shift left D                     lsld      macro                               fdb    $1048SWTPc      Intelligent I/O Proce     13:54:16  Jan 06, 2024   Page    5Macro Definitions                                                                  endm                                          * logical shift right D                     lsrd      macro                               fdb    $1044                               endm                                          * arithmetic shift right D                     *asrd    macro                     *        fdb     $1047                     *        endm                                          * negate D                     negd      macro                               fdb    $1040                               endm                                          * ex-or registers                     eorr      macro                               fdb    $1036                               fcb    &1<<4|&2                               endm                                          * add with carry D immediate                     adcdi     macro                               fdb    $1089                               fdb    &1                               endm                                          * increment D                     incd      macro                               fdb    $104c                               endm                                          * decrement D                     decd      macro                               fdb    $104a                               endm                                          * clear D                     clrd      macro                               fdb    $104f                               endm                                          * complement D                     comd      macro                               fdb    $1043                               endm                                          * and D immediate                     anddi     macro                               fdb    $1084SWTPc      Intelligent I/O Proce     13:54:16  Jan 06, 2024   Page    6Macro Definitions                                                                  fdb    &1                               endm                                          * bit D immediate                     bitdi     macro                               fdb    $1085                               fdb    &1                               endm                                          *                     * trfr, transfer registers, allow ALL registers                     *                     trfr      macro                               fcb    $1f                               fcb    &1<<4|&2                               endm                                          * exchange, allow ALL registers                     excg      macro                               fcb    $1e                               fcb    &1<<4|&2                               endm                                          * add registers                     *                     * addr, add reg0 + reg1 => reg1                     *                     addr      macro                               fdb    $1030                               fcb    &1<<4|&2                               endm                                          * subtract registers                     subr      macro                               fdb    $1032                               fcb    &1<<4|&2                               endm                                          * extended addressing mode                     aime      macro                               fcb    $72                               fcb    &1                               fdb    &2                               endm                                          * extended addressing mode                     oime      macro                               fcb    $71                               fcb    &1                               fdb    &2                               endm                     SWTPc      Intelligent I/O Proce     13:54:17  Jan 06, 2024   Page    7Macro Definitions                                                        * extended addressing mode                     eime      macro                               fcb    $75                               fcb    &1                               fdb    &2                               endm                                          * test immediate memory                     *timex   macro                     *        fcb     $7b                     *        fcb     &1                     *        fdb     &2                     *        endm                                          * put a LED in LIGHTS on                     LEDON     macro                               fcb    $71                               fcb    &1                               fdb    LIGHTS                               endm                                          * put a LED in LIGHTS off                     LEDOFF    macro                               fcb    $72                               fcb    255-&1                               fdb    LIGHTS                               endmSWTPc      Intelligent I/O Proce     13:54:17  Jan 06, 2024   Page    8Device     Table Structure                                                                    *                     * Possible module types table                     *                       0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *                       0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table  0004               dev_brbu  rmb    2         baudrate backup loc                     *  0006               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device, indexed by fifo cmnd >>3                     * should match nwp_codes.h  and MAX_S_NUM                     * wzsockdev.t                     *  0000                         org    $0000  0000               D_func0   rmb    2         0  Bad Command  0002               D_func1   rmb    2         1  0004               D_func2   rmb    2         2  0006               D_func3   rmb    2         3  0008               D_func4   rmb    2         4  000A               D_func5   rmb    2         5  000C               D_func6   rmb    2         6  000E               D_func7   rmb    2         7  0010               D_func8   rmb    2         8  0012               D_func9   rmb    2         9  0014               D_funcA   rmb    2         A  0016               D_funcB   rmb    2         B  0018               D_funcC   rmb    2         C  001A               D_funcD   rmb    2         D  001C               D_funcE   rmb    2         E  001E               D_funcF   rmb    2         F                     *  0020               D_func10  rmb    2         10  0022               D_func11  rmb    2         11  0024               D_func12  rmb    2         12  0026               D_func13  rmb    2         13                     *  0028               D_inthan  rmb    2         14 Interrupt poller/handlerSWTPc      Intelligent I/O Proce     13:54:17  Jan 06, 2024   Page    9Device     Table Structure                            002A               D_init    rmb    2         15 Device initialization  002C               D_test    rmb    2         16 Test for device present                     *  002E               D_END     rmb    0         End of common handlers                     SWTPc      Intelligent I/O Proce     13:54:17  Jan 06, 2024   Page   10History Queue Record Structure                                             0000                         org    0  0000               hst_cmd   rmb    1         Command  0001               hst_seq   rmb    1         Sequence #  0002               hst_tty   rmb    1         TTY #  0003               hst_val   rmb    1         Message dependent data                     *  0004               HRECSIZ   rmb    0                                          *                     * Number of history records supported                     *               0010  MAXHIST   equ    16                     SWTPc      Intelligent I/O Proce     13:54:17  Jan 06, 2024   Page   11IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0400  RAMorg    equ    $0400     28K of RAM - Thru $6FFF               3EFF  RAMend    equ    $3EFF     $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7E00  RAMscrend equ    $7E00               7FE0  ROMstack  equ    $7FE0     High end of ROM Stack                     * BGDB uses 7FF0               4000  ROMLOorg  equ    $4000     $E000      8K of ROM - $E000-$FFFF               6000  DEBUGROM  equ    $6000     IN RAM  $C000      8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, w5500 socket device                     *Task       Structure                 13:54:17  Jan 06, 2024   Page   12IOP        Memory Layout                                                 *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    00C0  USTSIZ    equ    192       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tssgnl    rmb    1         Signal waiting for task                     *  0009               tscmd     rmb    1         Saved mailbox command  000A               tsseq     rmb    2         Saved message sequence #  000C               tstval    rmb    1         Saved transaction value  000D               tsdev     rmb    2         Device for task is servicing  000F               tsagin    rmb    2         return pointer                     *  0011               usp       rmb    2         Saved User Stack Pointer  0013               umark0    rmb    2         Stack Frame Markers  0015               umark1    rmb    2  0017                         rmb    USTSIZ    space for per/process stack                                    00D7  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system task                     *                     * definition of wz5500 variables                     *                     * [*] items are initialized by the IO CPU                     * others are zeroed out                     *                                          * [*] are setup by GPP CPU                                          *                     * wzfsta bits                     *               0001  WZSLCK    equ    %00000001 sock is locked (equal to fdn)               0002  WZSKIO    equ    %00000010 io modeTask       Structure                 13:54:18  Jan 06, 2024   Page   13IOP        Memory Layout                                           0004  WZSKIS    equ    %00000100 sock is sending               0010  WZWLCK    equ    %00010000 sock task is waiting lock (equal to fdn)               0040  WZSKIP    equ    %01000000 sock interrupt pending               0080  WZBUSY    equ    %10000000 sock is busy                                                               *                     * wzcmd values (w5500), private for IOP                     *               0001  WCOPEN    equ    1         open command               0002  WCLIST    equ    2         list command               0004  WCCONN    equ    4         connect command               0008  WCDISC    equ    8         disconnect               0010  WCCLOS    equ    16        close               0020  WCSEND    equ    32        send               0021  WCSNAC    equ    33        send mac               0022  WCSKEP    equ    34        send keep               0040  WCRECV    equ    64        receive               0080  WCSPEC    equ    128       special, combined commands               0081  WCRRQD    equ    128+1     read request data               0082  WCXMDR    equ    128+2     write data in fifo                                    0085  WCBIND    equ    128+5     bind  CPU<=>GPP               0086  WCACCP    equ    128+6     accpet CPU<=>GPP                     *                     * wzstat values                     *               0000  WSCLSD    equ    $00       sock closed               0013  WSINIT    equ    $13       sock init               0014  WSLIST    equ    $14       sock listen               0017  WSESTB    equ    $17       sock established               001C  WSCLWT    equ    $1c       sock close wait               0022  WSUDP     equ    $22       sock UDP               0042  WSMCRW    equ    $42       sock mac raw               0015  WSSYNS    equ    $15       sock syn sent               0016  WSSYNR    equ    $16       sock syn received               0018  WSFWAI    equ    $18       sock fin wiat               001A  WSCLSG    equ    $1a       sock closing               001B  WSTIMW    equ    $1b       sock time wait               001D  WSLACK    equ    $1d       sock last ack               001E  WSRNBL    equ    $1e       sock read non block               001F  WSWNBL    equ    $1f       sock write non block               0080  WSSPEC    equ    $80       special combined commands               0081  WSRRQF    equ    $80+1     read request data in fifo               0082  WSXMDD    equ    $80+2     xmit data taken from fifo                                          *                     * miscellaneous                     *               0080  PACK_FIRST equ   $80       in non TCP packet start to receive               0001  PACK_REMAI equ   $01       in non TCP packet received               0000  PACK_COMPL equ   $00       in non TCP complete toe receiveTask       Structure                 13:54:18  Jan 06, 2024   Page   14IOP        Memory Layout                                                                0001  WFNBLK    equ    $01       in socket() call(wztype << 8)                       0000                         org    $0                     *                     * per wzsocket process and socket data                     *  0000               wzenum    rmb    1         [*] (pre=enum)  0001                         rmb    1         [*] (pre= $00)  sock has fifo allocated  0002               wzfsta    rmb    1         (pre= $00) status bits (SAME POS!! as in fdn)  0003               wzflg     rmb    1         [*] flasgs, i.e. bind                     *  0004               wzcmnd    rmb    1         command byte copy  0005               wzstat    rmb    1         status byte copy  0006               wzupkt    rmb    1         UDP packet flag  0007               wzerr     rmb    1         error code passing                     *  0008               wzxfer    rmb    2         transfer size  000A               wzrqln    rmb    2         requested size                     *  000C               wzdma1    rmb    2         if split xfer, first part  000E               wzdma2    rmb    2         if split xfer, second part                     *                     * unix socket call info                     *  0010               wzsprt    rmb    2         source port  0012               wzdprt    rmb    2         destination port  0014               wzipad    rmb    4         dest IP address  0018               wzsflg    rmb    2         flags                     *                     * udp header info                     *  001A               wzuipa    rmb    4         ip address from UDP header  001E               wzuprt    rmb    2         port number from UDP header  0020               wzurms    rmb    2         socket remained size                     *                     * open parameters                     *  0022               wzfaml    rmb    2         family            for check AF_  0024               wztype    rmb    2         type              for check SOCK_  0026               wzprot    rmb    2         protocol          for check IPPROTO_                                    0028  WZSIZE    equ    *-wzenum                       0000                         org    $0                     *                     * holds the local IP info, wzdev  net0                     * ipad, mask, gwad, macad                     *  0000               wzmyip    rmb    4         Device IP address  0004               wzsbnm    rmb    4         Subnet mask bits  0008               wzgwad    rmb    4         Gateway IP addressTask       Structure                 13:54:18  Jan 06, 2024   Page   15IOP        Memory Layout                              000C               wzhwad    rmb    6         Device Hardware address                     *  0012               wzdsta    rmb    1         up/down status  0013                         rmb    3                                    0016  WZLCSZ    equ    *-wzmyip                     *                     * this is (an attempt) to implement the Berkely                     * socket interface into the UniFLEX 6309 kernel (no 6809)                     *  0000                         org    0                                          * struct sockaddr  0000               sa_fam    rmb    2         address family  0002               sa_dat    rmb    14        protocol address               0010  SKADLN    equ    *                                          * struct sockaddr_in  0010               sin_fam   rmb    2         AF_INET  0012               sin_port  rmb    2         16 bit port  0014               sin_addr  rmb    4         32 bit netid/hostid                                          * address families               0000  AF_UNSP   equ    0         AF_UNSPEC               0001  AF_UNIX   equ    1         AF_UNIX               0002  AF_INET   equ    2         AF_INET                                          * socket types               0001  SK_STRM   equ    1         socket stream               0002  SK_DGRM   equ    2         datagram, conn less               0003  SK_RAW    equ    3         raw socket                                          * protocol families               0001  PF_UNIX   equ    AF_UNIX   same as address families               0002  PF_INET   equ    AF_INET                                          *               05C0  MAX_UDP   equ    1472      max size of UDP packet                                          FIO Simulation Structure             13:54:18  Jan 06, 2024   Page   16IOP        Memory Layout                                                                      *                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     *                       0000                         org    $0000     absolute addressed                                          ************************************************************                     * the first 32 bytes of a fifo/DPR area are the same                     * for ALL applications                     ************************************************************  0000               cpu_fio   rmb    1         Command code  0001               cpu_fio1  rmb    2         Task ID/sequence  0003               cpu_fio2  rmb    1         Message specific data  0004               cpu_fio3  rmb    2         Device designator  0006               cpu_fio4  rmb    2         UIO  0008               cpu_fio5  rmb    1         UIO                     ************************************************************  0009               fio_cpu   rmb    1         Response code  000A               fio_cpu1  rmb    2         Task ID /sequence  000C               fio_cpu2  rmb    1         Transaction specific value  000D               fio_cpu3  rmb    2         --  000F               fio_cpu4  rmb    2         UIO  0011               fio_cpu5  rmb    1         UIO                     ************************************************************                     *  0012               fifo_cnt  rmb    2         Count of data in FIFO  0014               fifo_get  rmb    2         retrieval ponter  0016               fifo_put  rmb    2         storage pointer                     *                     * these values are initialized by the IO CPU                     *  0018               fifo_us0  rmb    2         FIFO offset to application data                     *  001A               fifo_us1  rmb    2         FIFO offset to user specific area2  001C               fifo_us2  rmb    2         FIFO offset to user specific area2  001E               fifo_us3  rmb    2         FIFO offset to user specific area3                     *  0020                         rmb    32-(*-cpu_fio) ** Filler **                     * end of defined area                                          ************************************************************  0020               fifo      rmb    1                     * the size of the fifo is defined in the parameter block                     ************************************************************                                          ************************************************************                     * the top 4 locations are also fixed and shared on all applications                     ************************************************************FIO Simulation Structure             13:54:19  Jan 06, 2024   Page   17IOP        Memory Layout                              0021               DEV2CPU   rmb    1         debug data from IOP/GPP  0022               CPU2DEV   rmb    1         debug data to IOP/GPP                     * should end up at the two top locations in the DUALPORT RAM  0023               fio_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  0024               cpu_fioF  rmb    1         INT + non-zero   contains info AND set FIO IRQ when written                     **************************************************************FIO Simulation Structure             13:54:19  Jan 06, 2024   Page   18Dual_Port RAM Structure                                                                                            *                     * this is an OVERLAY on a 1Kx8 FIFO in DPR                     *                     * the primary fifo definitions are not touched                     *                     * some locations may be re-used for this purpose                     *               0000  DPR_BASE  equ    $0000     GPP DPR at this address (GPP)  0000                         org    DPR_BASE  -- Dual port RAM address                                          *               0000  nwp_strt  equ    *         first address  of DPR RAM                     *                     ******************************************************  0000                         rmb    32        defined in fio.h                       0020                         rmb    512       fifo space                     ******************************************************               0220  WZSKOFF   equ    *                     ******************************************************  0220               wzsk8     rmb    WZSIZE    sock structure  0248               wzsk7     rmb    WZSIZE    sock  0270               wzsk6     rmb    WZSIZE    sock  0298               wzsk5     rmb    WZSIZE    sock  02C0               wzsk4     rmb    WZSIZE    sock  02E8               wzsk3     rmb    WZSIZE    sock  0310               wzsk2     rmb    WZSIZE    sock  0338               wzsk1     rmb    WZSIZE    sock                     ******************************************************               0360  WZNETOF   equ    *  0360               wlocip    rmb    WZLCSZ    network device                     ******************************************************                     *                     * fifo top                     * specified in fio.h                     *                     ******************************************************                     *                     * IOP ROM Version #                     *               0030  ROM_VERSION equ  $30       Major/Minor Version of IOP ROM                                          *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)FIO Simulation Structure             13:54:19  Jan 06, 2024   Page   19Dual_Port RAM Structure                                            0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some sort of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   set    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)               00C0  E_SOCKET  equ    REJECT+$40 generic socket error, actual is passed                                          *                     * Normal responses                     * error is with bit 7 set, A contains error code                     *               0001  R_OPEN    equ    $01       [S]  Device open successful               0002  R_CLOSE   equ    $02       [S]  Device close successful               0003  R_RQWR    equ    $03       [S]  request for write               0004  R_WRITE   equ    $04       [S]  write data via fifo to net               0005  R_RQRD    equ    $05       [S]  request for read data               0006  R_READ    equ    $06       [S]  read data via fifo from net               0007  R_INTRPT  set    $07       [S]  Interrupt complete               0008  R_CONNECT equ    $08       [S]  connect ok               0009  R_BIND    equ    $09       [S]  bind call ok               000A  R_LISTEN  equ    $0A       [S]  listen call ok               000B  R_ACCEPT  equ    $0B       [S]  accept call ok               000C  R_DISCON  equ    $0C       [S]  disconnect happened               000D  R_SNDMAC  equ    $0D       [S]  send mac done               000E  R_SNDKEP  equ    $0E       [S]  send keep alive done               000F  R_SPCL    equ    $0F       [S]  special call ok               0015  R_RQRDNB  equ    $15       [S]  non block return read               0013  R_RQWRNB  equ    $13       [S]  non block return write                     *               0021  R_RDFRM   equ    $21       [S]  request for data readfrom               0022  R_RRDFD   equ    $22       [S]  read data readfrom next packet               0023  R_RSNDTO  equ    $23       [S]  request write sendto               0024  R_WSNDTO  equ    $24       [S]  write data sendto                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     * Socket functions                     *               0008  S_OPEN    equ    $08       Open socket               0010  S_CLOSE   equ    $10       Close socket               0018  S_RQWR    equ    $18       request write to socket               0020  S_WRITE   equ    $20       Write data to socket               0028  S_RQRD    equ    $28       Request read data from socket               0030  S_READ    equ    $30       Read data from socket               0038  S_INTRPT  equ    $38       Interrupt socket               0038  O_INTRPT  set    S_INTRPT               0040  S_CONNECT equ    $40       Connect socket               0048  S_BIND    equ    $48       Bind socket               0050  S_LISTEN  equ    $50       Listen on socket               0058  S_ACCEPT  equ    $58       Accept connection on socket               0060  S_DISCON  equ    $60       Disconnect socket               0068  S_SNDMAC  equ    $68       Send to mac               0070  S_SNDKEP  equ    $70       Send keep aliveFIO Simulation Structure             13:54:19  Jan 06, 2024   Page   20Dual_Port RAM Structure                                            0078  S_SPCL    equ    $78       Special. i.e set network device                     *               0080  S_RRDFRM  equ    $80       request read readfrom               0088  S_RREAD   equ    $88       read data readfrom               0090  S_WRQSTO  equ    $90       request send ssendto               0098  S_WSNDTO  equ    $98       send data sendto                     *               0014  MAX_S_NUM equ    20        # of supported functions (incl 0)                     *                     * definition of all interrupts in the W5500                     *                                          *                     * interrupts per socket (Socket registers)                     *               0001  SI_CON    equ    %00000001 Sn_IR(CON)               0002  SI_DIS    equ    %00000010 Sn_IR(DISCON)               0004  SI_RCV    equ    %00000100 Sn_IR(RECV)               0008  SI_TIM    equ    %00001000 Sn_IR(TIMEOUT)               0010  SI_SOK    equ    %00010000 Sn_IR(SEND_OK)                                          *                     * common interrupts  (Common registers)                     *               0010  CI_MP     equ    %00010000 Magic Packet               0020  CI_POC    equ    %00100000 PPoE Close               0040  CI_UNR    equ    %01000000 UNREACH               0080  CI_CFL    equ    %10000000 IP ConflictFIO Simulation Structure             13:54:20  Jan 06, 2024   Page   21Variable   Space                                                           0400                         org    RAMorg                       0400               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"                       0400               DB_iflg   rmb    1         Debug terminal initialized  0401               DB_cntrl  rmb    2         Debug control flags                     *  0403               runlst    rmb    2         Pointer to active tasks  0405               slplst    rmb    4         Pointer to waiting tasks  0409               utask     rmb    2         Currently executing task  040B               jobpri    rmb    1         Current job priority (for scheduling)  040C               chproc    rmb    1         Set if must switch users of CPU (reschedule)                     *  040D               idle      rmb    1         idle loop flag for scheduler  040E               SI_Q      rmb    6*MAX_TI  Max Terminal Interrupts  0444               SI_Q_ptr  rmb    2         current Q pointer  0446               FIO_lock  rmb    1         FIO in use lock  0447               int_buf   rmb    12        Current Message in  0453               int_ptr   rmb    2         Message in pointer  0455               clock_tick rmb   1         Clock tick counter  0456               spiint    rmb    1         Interrupt flag from w5500  0457               wzanyp    rmb    2         Source Port  0459               NUM_TSK   rmb    1         max tasks                       045A               hstbuf    rmb    HRECSIZ*MAXHIST  049A               hstptr    rmb    2         next "put" pointer in history queue                                          * Pointers to system tables - configuration dependent  049C               tsktab    rmb    2         Task Control Tables  049E               tskend    rmb    2         End of task table  04A0               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table                     *  04A6                         rmb    32                       04C6               SYS_TABS  rmb    0         Start of dynamic system tables                                    04C6  lstram    equ    *               3EFF  end_vars  equ    RAMend    End of System Variables                                          FIO Simulation Structure             13:54:20  Jan 06, 2024   Page   22CPU        Vectors                                                         FFF0                         org    CPUtraps                       FFF0 40A1                    fdb    rom_trap  Unused  FFF2 409A                    fdb    rom_swi3  SWI3  FFF4 4093                    fdb    rom_swi2  SWI2  FFF6 4086                    fdb    rom_firq  FIRQ  FFF8 4395                    fdb    IRQ_han   IRQ  FFFA 408D                    fdb    rom_swi   SWI  FFFC 4080                    fdb    rom_nmi   Background debug  FFFE 405F                    fdb    rom_init  Reset                     FIO Simulation Structure             13:54:20  Jan 06, 2024   Page   23System     RESET Code                                                      4000                         org    ROMLOorg                       4000 0D 4E 57 50   DBmsg00   fcc    $d,'NWP ROM',0  4009 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  4029 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  403D 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          * share settings with kernel driver code               405A  fio_fsz   equ    *         device fifo size               405C  fio_dsz   equ    *+2       device RAM size               405E  max_trn   equ    *+4       max transactions                     *                     * share specific DUAL PORT RAM device initialization                     * between UniFLEX kernel and NWP CPU                     *  405A 0200                    fdb    512       fio_fsz FIFO SIZE  405C 0400                    fdb    1024      fio_dsz DEVICE SIZE  405E 08                      fcb    8         fio_mxtrn MAX_TRANSACTIONS                     *                     * declaration of offsets and settings                     *               0008  MAX_WZ    equ    8         # of sockets in w5500                                                               *                     * System RESET code                     *  405F 10CE 7FE0     rom_init  lds    #ROMstack initialize stack pointer  4063                         ldmd   3  4063 113D                    fdb    $113d  4065 03                      fcb    3                               endm                                          *                     * for background debugger                     *                     **        lda     #$15                     **        sta     ACIAC         init debug acia                     **        clr     bdbsta        echo on                                            4066 8E   4395               ldx    #IRQ_han  IRQ  4069 BF   7F00               stx    $7f00     GPPMON vector                                           >406C 17   0053     20        lbsr   stbinit   go initialize system memory                       406F 10FE 049C     30        lds    tsktab    Task 0 Stack  4073 32   E9 00D7            leas   TSKSIZ,s  4077 17   0152               lbsr   fio_reset  407A 17   012C               lbsr   timerinFIO Simulation Structure             13:54:20  Jan 06, 2024   Page   24System     RESET Code                                                    *                     * Initialization complete - Start executing commands                     *  407D               fio_start  407D 7E   449A     10        jmp    rsched                                          FIO Simulation Structure             13:54:20  Jan 06, 2024   Page   25ROM        Interrupt Fielders                                              4080 8D   26       rom_nmi   bsr    rom_int  4082 4E 4D 49 00             fcc    'NMI',0  4086 8D   20       rom_firq  bsr    rom_int  4088 46 49 52 51             fcc    'FIRQ',0  408D 8D   19       rom_swi   bsr    rom_int  408F 53 57 49 00             fcc    'SWI',0  4093 8D   13       rom_swi2  bsr    rom_int  4095 53 57 49 32             fcc    'SWI2',0  409A 8D   0C       rom_swi3  bsr    rom_int  409C 53 57 49 33             fcc    'SWI3',0  40A1 8D   05       rom_trap  bsr    rom_int  40A3 54 52 41 50             fcc    'TRAP',0                       40A8 8E   40B5     rom_int   ldx    #ROM_ERR  40AB BD   518D               jsr    DB_pdata  40AE 35   10                 puls   x  40B0 BD   518D               jsr    DB_pdata  40B3 20   FE       rom_bad   bra    *                     *  40B5 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0FIO Simulation Structure             13:54:21  Jan 06, 2024   Page   26Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  40C2 8E   0000     stbinit   ldx    #0        s  clear all variables  40C5 CC   0000               ldd    #0  40C8 ED   81       10        std    ,x++  40CA 8C   3EFF               cmpx   #end_vars done yet?  40CD 25   F9                 blo    10b                       40CF CC   0D04               ldd    #DEBUG  40D2 FD   0401               std    DB_cntrl                                            40D5 B6   405E               lda    max_trn   shared with main CPU  40D8 48                      asla             *2  40D9 8B   04                 adda   #4        fixed system tasks  40DB B7   0459               sta    NUM_TSK                     * >40DE 17   0013               lbsr   set_tables go figure out configuration, tables, etc                                          * Initialize Socket Interrupt Queue  40E1 8E   040E     15        ldx    #SI_Q     set queue empty  40E4 BF   0444               stx    SI_Q_ptr  40E7 8E   0447               ldx    #int_buf  reset message in pointer  40EA BF   0453               stx    int_ptr                      >40ED 17   0061     17        lbsr   tskinit   initialize tasks                       40F0 17   10B8     18        lbsr   DB_config display configuration  40F3 39                      rts                                          *                     * Set up system tables                     *  40F4               set_tables  40F4 108E 04A0               ldy    #dev_tab  40F8 8E   45CD               ldx    #DEV_SOCK  40FB AF   22                 stx    dev_type,y  40FD AD   98 2A              jsr    [D_init,x]                                          * Compute configuration  4100 CE   41BB               ldu    #mod_tbl  tables with module refs  4103 AE   C4       12        ldx    mod_type,u  4105 27   09                 beq    20f       jump if end of module table  4107 AD   98 2C              jsr    [D_test,x] check for device  410A 25   04                 bcs    15f       jump if found  410C 33   44                 leau   MOD_SIZE,u  410E 20   F3                 bra    12b                     *FIO Simulation Structure             13:54:21  Jan 06, 2024   Page   27Table      Initialization                             4110               15  4110               20                     * -- All done setting up configuration                       4110 CC   04C6               ldd    #SYS_TABS start of system tables  4113 1F   03                 tfr    d,u                     * -- Task table  4115 86   D7                 lda    #TSKSIZ  4117 F6   0459               ldb    NUM_TSK  411A 3D                      mul  411B FF   049C               stu    tsktab >411E 17   0022               lbsr   sto_chk   check for system table space overflow  4121 FF   049E               stu    tskend                     *                     * -- All done  4124 39            90        rts                     *  4125 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  413C 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                                                    *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  4143 33   CB       sto_chk   leau   d,u       compute new end pointer  4145 1183 3EFF               cmpu   #end_vars overflow?  4149 22   03                 bhi    10f       yes - return error  414B 1C   FE                 clc              no         - return OK  414D 39                      rts  414E 1A   01       10        sec              ..         bad owies  4150 39                      rts                                          *                     * tskinit - Initialize all tasks                     *  4151 BE   049C     tskinit   ldx    tsktab  4154 BF   0409               stx    utask  4157 F6   0459               ldb    NUM_TSK   # tasks in system  415A 34   04                 pshs   b  415C 10BE 049C               ldy    tsktab    task 1  4160 31   A9 00D7            leay   TSKSIZ,y  4164               10                                            4164 86   04       11        lda    #TFREE    mark all tasks free  4166 BC   049C               cmpx   tsktab    is this the system task?FIO Simulation Structure             13:54:21  Jan 06, 2024   Page   28Table      Initialization                             4169 26   02                 bne    15f  416B 86   05                 lda    #TSYS     the system task is never free  416D A7   04       15        sta    tsstat,x  416F 86   FF                 lda    #$FF      not associated with a terminal  4171 A7   0D                 sta    tsdev,x  4173 A7   0E                 sta    tsdev+1,x  4175 33   89 00D7            leau   TSKSIZ,x  initialize stack  4179 CC   4319               ldd    #IO_han  417C 34   20                 pshs   y  417E AC   E1                 cmpx   ,s++      task 1?  4180 26   03                 bne    20f       no - normal I/O handling task  4182 CC   43E9               ldd    #SI_HAN   yes - special terminal interrupt handling task  4185 36   06       20        pshu   d  4187 EF   88 11              stu    usp,x  418A EF   88 13              stu    umark0,x  418D 30   89 00D7            leax   TSKSIZ,x  4191 6A   E4                 dec    0,s       done?  4193 26   CF                 bne    10b  4195 32   61                 leas   1,s       clean up stack  4197 CC   0000               ldd    #0        nothing running or sleeping  419A FD   0403               std    runlst  419D FD   0405               std    slplst  41A0 FD   0407               std    slplst+tsslnk  41A3 30   A4                 leax   0,y       start interrupt handling task  41A5 BD   4540               jsr    makrdy  41A8 39                      rts                                                               *                     * GPP interrupt timer                     *               8400  tim_base  equ    $8400               8401  tim_rest  equ    $8401                       41A9 86   00       timerin   lda    #%00000000 D0      (OFF!)  41AB B7   8400               sta    tim_base  interrupt enable  41AE 39                      rts                                                         41AF  timerack  equ    *  41AF 86   01                 lda    #1  41B1 B7   8401               sta    tim_rest  reset interrupt  41B4 39                      rts                       41B5 B6   8400     timerchk  lda    tim_base  41B8 84   80                 anda   #%10000000 interrupt flag  41BA 39                      rtsFIO Simulation Structure             13:54:21  Jan 06, 2024   Page   29IOP        Configuration                                                                      *                     * define which type of boards are present                     *               41BB  mod_tbl   equ    *  41BB 45CD 41C1               fdb    DEV_SOCK,WZ5_name  41BF 0000                    fdb    0                     *  41C1 57 35 35 30   WZ5_name  fcc    'W5500_SOCK',0FIO Simulation Structure             13:54:22  Jan 06, 2024   Page   30FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     * it is assumed that the FIO (DPR) sits at $0000                     *  41CC               fio_reset                     * when here, all storage locations have been erased already                     *  41CC 8E   0000               ldx    #0  41CF 9F   14                 stx    fifo_get  set Q pointers  41D1 9F   16                 stx    fifo_put  41D3 8E   0360               ldx    #WZNETOF  41D6 9F   1A                 stx    fifo_us1  41D8 8E   0220               ldx    #WZSKOFF  41DB 9F   18                 stx    fifo_us0  so that kernel CPU can see it                     * init the 8 SOCK structs  41DD 86   08                 lda    #8  41DF A7   84       01        sta    wzenum,x  41E1 30   88 28              leax   WZSIZE,x  to next  41E4 4A                      deca  41E5 26   F8                 bne    01b                     *  41E7 BE   405C               ldx    fio_dsz  41EA 30   1E                 leax   -2,x      one from top  41EC CE   0400               ldu    #1024     -- Reset Time-Out value                     *  41EF C6   FF       fio_wait  ldb    #255      Spin counter                     *  41F1               00  41F1 6D   84                 tst    0,x       fio_cpuF  41F3 27   16                 beq    10f                     *  41F5 5A                      decb  41F6 26   F9                 bne    00b       jump back if not ready                     *  41F8 33   5F                 leau   -1,u  41FA 1183 0000               cmpu   #0  41FE 26   EF                 bne    fio_wait  4200 8E   403D               ldx    #CPU_down  4203 17   0F87               lbsr   DB_pdata  4206 17   0F7E               lbsr   DB_main  4209 20   C1                 bra    fio_reset                     * reset OK  420B 39            10        rts                                                               *                     * FIO interrupt handler, called when IRQ was set (interrupt context)                     *  420C BE   0453     fio_irq   ldx    int_ptr   input message pointer  420F 96   00                 lda    cpu_fio   move REQUEST  4211 A7   80                 sta    ,x+FIO Simulation Structure             13:54:22  Jan 06, 2024   Page   31FIO        Simulation Routines                        4213 DC   01                 ldd    cpu_fio1  sequence # TASK ID  4215 ED   81                 std    ,x++  4217 96   03                 lda    cpu_fio2  specific DATA  4219 A7   80                 sta    ,x+  421B DC   04                 ldd    cpu_fio3  device major/minor  421D ED   81                 std    ,x++                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     *  421F FE   405C               ldu    fio_dsz  4222 33   5F                 leau   -1,u  4224 6F   C4                 clr    0,u       cpu_fioF indicate message consumed                     *  4226 BF   0453               stx    int_ptr   update pointer  4229 108E 0447               ldy    #int_buf  get message from buffer  422D A6   A4                 lda    0,y       -- Send interrupt command?  422F 81   38                 cmpa   #S_INTRPT  4231 26   0D                 bne    30f                     *                     * special case OOB signal                     *  4233 10BF 0453               sty    int_ptr   reset pointer  4237 E6   23                 ldb    3,y       signal  4239 AE   24                 ldx    4,y       SOCK reference                     *  423B BD   4619               jsr    sdev_sig  send device signal  423E 20   35                 bra    fiointe   exit                     *                     * normal command                     * acquire free task slot                     *  4240 BE   049C     30        ldx    tsktab    search for an available task  4243 F6   0459               ldb    NUM_TSK   Number of tasks in system                     *  4246 A6   04       32        lda    tsstat,x  4248 81   04                 cmpa   #TFREE    looking for a "free" task  424A 27   0E                 beq    40f                     *  424C 30   89 00D7            leax   TSKSIZ,x  4250 5A                      decb  4251 26   F3                 bne    32b                     *  4253 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated! >4255 BD   4276               jsr    fio_msg  4258 20   1B                 bra    fiointe   exit                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     * move data over into task struct                     *  425A 108E 0447     40        ldy    #int_buf  get message from buffer  425E 10BF 0453               sty    int_ptr   reset pointer  4262 E6   A0                 ldb    ,y+       command byte  REQUESTFIO Simulation Structure             13:54:22  Jan 06, 2024   Page   32FIO        Simulation Routines                        4264 E7   09                 stb    tscmd,x   save for task  4266 EC   A1                 ldd    ,y++      sequence #    task ID  4268 ED   0A                 std    tsseq,x  426A E6   A0                 ldb    ,y+       command specific DATA  426C E7   0C                 stb    tstval,x  426E EC   A1                 ldd    ,y++      associate with terminal major/minor  4270 ED   0D                 std    tsdev,x  4272 BD   4540               jsr    makrdy    make task ready to run                     *  4275 39            fiointe   rts              exit                                          *                     * fio_msg - Send a message via the FIO Mailbox                     * it is assumed that the FIO (DPR) sits at $0000                     *   B - Message code to send (one byte)                     *   fio_cpu1..3 already set up                     *  4276 34   54       fio_msg   pshs   b,x,u     save register  4278 FE   405C               ldu    fio_dsz  427B 33   5E                 leau   -2,u      one off top  427D D7   09                 stb    fio_cpu   set up mailbox value                       427F 86   FF       5         lda    #$FF      tell CPU mailbox full  4281 A7   C4                 sta    0,u       fio_cpuF  4283 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  4286 A6   C4       10        lda    0,u       fio_cpuF   wait till value consumed  4288 27   06                 beq    20f       jump if consumed                     *  428A 30   1F                 leax   -1,x      time-out yet?  428C 26   F8                 bne    10b                     *  428E 20   F3                 bra    05b       try again                     *  4290 35   D4       20        puls   b,x,u,pc                     *                                          *                     * this is the normal way the IOP sends data to the host CPU                     * fio_response - Return a response code/sequence #                     * it is assumed that the FIO (DPR) sits at $0000                     *    X = utask,                     *    B - Response code                     *    A - Transaction specific value                     *  4292 34   16       fio_response pshs d,x  4294 8D   18                 bsr    FIO_get   access FIO  4296 BE   0409               ldx    utask     task ID  4299 EC   0A                 ldd    tsseq,x  429B DD   0A                 std    fio_cpu1  429D EC   0D                 ldd    tsdev,x   device info  429F DD   0D                 std    fio_cpu3FIO Simulation Structure             13:54:22  Jan 06, 2024   Page   33FIO        Simulation Routines                        42A1 A6   E4                 lda    0,s       get transaction specific value (i.e. error code)  42A3 97   0C                 sta    fio_cpu2  42A5 E6   61                 ldb    1,s       is RESPONSE code >42A7 BD   4276               jsr    fio_msg  42AA 8D   17                 bsr    FIO_rel   release FIO  42AC 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *  42AE 34   76       FIO_get   pshs   d,x,y,u   save registers  42B0 108E 0446     10        ldy    #FIO_lock is the device locked  42B4 6D   A4                 tst    0,y  42B6 27   07                 beq    20f       no - go get it                     *  42B8 C6   CE                 ldb    #FIOPRI   waiting for the FIO  42BA BD   457A               jsr    sleep  42BD 20   F1                 bra    10b       try again                     *  42BF 6C   A4       20        inc    0,y       mark in use  42C1 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  42C3 34   76       FIO_rel   pshs   d,x,y,u  42C5 108E 0446               ldy    #FIO_lock  42C9 6F   A4                 clr    0,y  42CB BD   4556               jsr    wakeup  42CE 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  42D0 34   04       FIFOgeta  pshs   b  42D2 8D   05                 bsr    FIFO_get  42D4 35   02                 puls   a  42D6 1E   89                 exg    a,b  42D8 39                      rts                     *  42D9 34   12       FIFO_get  pshs   a,x  42DB DC   12                 ldd    fifo_cnt  any data?  42DD 27   15                 beq    99f       no - exit                     *  42DF                         decd   yes       - adjust count  42DF 104A                    fdb    $104a                               endm  42E1 DD   12                 std    fifo_cnt  42E3 9E   14                 ldx    fifo_get  get consumer pointer  42E5 E6   88 20              ldb    fifo,x    fetch byteFIO Simulation Structure             13:54:23  Jan 06, 2024   Page   34FIO        Simulation Routines                        42E8 30   01                 leax   1,x       bump pointer  42EA BC   405A               cmpx   fio_fsz   end of fifo?  42ED 26   03                 bne    10f                     *  42EF 8E   0000               ldx    #0        reset pointer                     *  42F2 9F   14       10        stx    fifo_get                     *  42F4 35   92       99        puls   a,x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  42F6 34   04       FIFOputa  pshs   b  42F8 1F   89                 tfr    a,b  42FA 8D   02                 bsr    FIFO_put  42FC 35   84                 puls   b,pc                     *  42FE 34   16       FIFO_put  pshs   d,x  4300 9E   16                 ldx    fifo_put  get consumer pointer  4302 E7   88 20              stb    fifo,x    store byte  4305 30   01                 leax   1,x       bump pointer  4307 BC   405A               cmpx   fio_fsz   end of FIFO?  430A 26   03                 bne    10f                     *  430C 8E   0000               ldx    #0        reset pointer  430F 9F   16       10        stx    fifo_put                     *  4311 DC   12                 ldd    fifo_cnt  4313                         incd  4313 104C                    fdb    $104c                               endm  4315 DD   12                 std    fifo_cnt  4317 35   96       99        puls   d,x,pcFIO Simulation Structure             13:54:23  Jan 06, 2024   Page   35IO         Command Handler                                               *                     *                     * IO_han - I/O Command Handler                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *  4319               IO_han    seti   block     interrupts  4319 1A   50                 orcc   #FF|IF                               endm                     *                     * we execute the task belonging to the transaction                     *  431B               10        clri  431B 1C   AF                 andcc  #!(FF|IF)                               endm  431D BE   0409               ldx    utask     get task control block address  4320 A6   09                 lda    tscmd,x   get I/O command                     *                     * The command byte is shifted and used as an index                     * in a DEV_XXXX tab                     *  4322 44                      lsra             isolate    command  4323 44                      lsra  4324 44                      lsra                     **        lsra  4325 81   14                 cmpa   #MAX_S_NUM  4327 22   69                 bhi    bad_cmd                     *  4329 48                      lsla             --   word index on command  432A 34   10                 pshs   x  432C 8E   04A0               ldx    #dev_tab  432F AE   02                 ldx    dev_type,x get handler table address  4331 10AE 86                 ldy    a,x       get processor address  4334 35   10                 puls   x  4336 34   20                 pshs   y  4338 10AE 0F                 ldy    tsagin,x  if 0, d nothing  433B 27   0A                 beq    05f       else it is target ponter  433D 10AF E4                 sty    0,s  4340 108E 0000               ldy    #0  4344 10AF 0F                 sty    tsagin,x  reset pointer  4347 35   20       05        puls   y         change address  4349 4F                      clra                     *  434A 8E   4377               ldx    #IO_end   interrupt handler address  434D 34   10                 pshs   x  434F BE   0409               ldx    utask     task pointer  4352 10EF 88 15              sts    umark1,x  4356 EE   0D                 ldu    tsdev,x   get sock refernceFIO Simulation Structure             13:54:23  Jan 06, 2024   Page   36IO         Command Handler                            4358 1E   03                 exg    d,u  435A 84   07                 anda   #%00000111 mask off address bits  435C 1E   03                 exg    d,u                     *                     * CALL HANDLER: X=utask, Y=handler address, U=sock address                     *  435E AD   A4                 jsr    0,y       perform operation & return status  4360 32   62                 leas   2,s       clean up stack                     *                     * on return, Y= flag. -1 is resched, else end task                     *  4362 BE   0409               ldx    utask     restore task pointer  4365 108C FFFF               cmpy   #$ffff  4369 26   09                 bne    20f                     * task is NOT done yet  436B 86   BA                 lda    #POLPRI  436D A7   05                 sta    tsprir,x  at lower prio  436F BD   4494               jsr    change  4372 20   1B                 bra    91f       just escape (and come back)                     *                     * A=transaction value, B=response code, U=device reference                     * X = task pointer                     * in fio_response the task ID is added as sequence reference                     * SEND the response to the host CPU                     *                     *  4374 BD   4292     20        jsr    fio_response                     *                     * task is done                     *  4377               IO_end    seti   mask      interrupts  4377 1A   50                 orcc   #FF|IF                               endm  4379 BE   0409               ldx    utask     restore task control block address  437C A7   0C                 sta    tstval,x  remember transaction value sent  437E E7   09                 stb    tscmd,x   and command response  4380 86   04                 lda    #TFREE    mark task "terminated & free"  4382 A7   04                 sta    tsstat,x  4384 86   FF                 lda    #$FF      disassociate from any terminal  4386 A7   0D                 sta    tsdev,x  4388 A7   0E                 sta    tsdev+1,x  438A 6F   08                 clr    tssgnl,x  no waiting signals                     *                     * exit here to rescheduling                     *  438C BD   449A     90        jsr    rsched    run other tasks >438F 16   FF87     91        lbra   IO_han                                          *                     * Illegal command                     *  4392               bad_cmdFIO Simulation Structure             13:54:23  Jan 06, 2024   Page   37IO         Command Handler                            4392 C6   81                 ldb    #E_BADCMD error code  4394 39                      rtsFIO Simulation Structure             13:54:23  Jan 06, 2024   Page   38Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                     *               4395  IRQ_han   equ    *                     *                     * Check for FIO Mailbox interrupt                     *  4395 BE   405C     10        ldx    fio_dsz  4398 30   1F                 leax   -1,x  439A A6   84                 lda    0,x       cpu_fioF   see if mailbox interrupt  439C 27   03                 beq    99f       no - move on  439E BD   420C               jsr    fio_irq   call fio interrupt handler                     *                     *         lbsr    DB_main                     *  43A1 3B            99        rti              return from interrupt                     *  43A2 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  43AD 2D 2D 20 4E   00        fcc    '-- No tasks!',0FIO Simulation Structure             13:54:24  Jan 06, 2024   Page   39Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   A - Device #                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  43BA 34   36       int_all   pshs   d,x,y  43BC F6   0459               ldb    NUM_TSK  43BF C0   02                 subb   #2  43C1 34   04                 pshs   b  43C3 BE   049C               ldx    tsktab  43C6 30   89 01AE            leax   2*TSKSIZ,x                     *  43CA EC   61       10        ldd    1,s  43CC 10A3 0D                 cmpd   tsdev,x   is this guy associated with the device?  43CF 26   0C                 bne    20f                     *  43D1 BC   0409               cmpx   utask     make sure I don't get blown away  43D4 27   07                 beq    20f                     *  43D6 34   16                 pshs   d,x  43D8 BD   45AF               jsr    xmtint    interrupt task  43DB 35   16                 puls   d,x                     *  43DD 30   89 00D7  20        leax   TSKSIZ,x  next task  43E1 6A   E4                 dec    0,s       more tasks?  43E3 26   E5                 bne    10b  43E5 32   61                 leas   1,s                     *  43E7 35   B6                 puls   d,x,y,pc  returnFIO Simulation Structure             13:54:24  Jan 06, 2024   Page   40Terminal   Interrupt Handling Task                                                            *                     * SI_HAN Socket interrupt handler                     *  43E9 108E 040E     SI_HAN    ldy    #SI_Q     Terminal Interrupt Queue  43ED                         seti  43ED 1A   50                 orcc   #FF|IF                               endm  43EF FE   0444               ldu    SI_Q_ptr  get current Q ptr  43F2 1183 040E               cmpu   #SI_Q     anything in Q?  43F6 26   07                 bne    20f       yes - go process it                     *  43F8 C6   D8                 ldb    #SIQPRI   wait for something to do  43FA BD   457A               jsr    sleep  43FD 20   EA                 bra    SI_HAN                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *  43FF E6   C2       20        ldb    0,-u      B = Interrupt #  4401 34   04                 pshs   b  4403 EC   C3                 ldd    0,--u     A = Device #  4405 34   06                 pshs   d  4407 EC   C3                 ldd    0,--u     task ID  4409 34   06                 pshs   d         save registers  440B FF   0444               stu    SI_Q_ptr  update pointer                     *                     * S[0][1]=task,U[2][3]=dev,U[4]=response                     *  440E E6   63                 ldb    3,s       set up to flush all input for this terminal                     **!       jsr     ttftab     X=ttytab, U=device table                     **!       jsr     flushi  4410                         clri   allow     interrupts  4410 1C   AF                 andcc  #!(FF|IF)                               endm                     *  4412 BD   42AE               jsr    FIO_get   get access to FIO  4415 EC   E1                 ldd    0,s++     task ID  4417 DD   0A                 std    fio_cpu1  4419 EC   E1                 ldd    ,s++      terminal #  441B DD   0D                 std    fio_cpu3  terminal  441D E6   E0                 ldb    ,s+       interrupt #  441F D7   0C                 stb    fio_cpu2  signal  4421 C6   07                 ldb    #R_INTRPT  4423 BD   4276               jsr    fio_msg   send interrupt message  4426 BD   42C3               jsr    FIO_rel   release access to FIO  4429 20   BE                 bra    SI_HAN    process more if needed                                          *                     * Send_SI - Send a socket interrupt                     *   B = Interrupt #                     *   X = SOCK address                     *   jsr send_SIFIO Simulation Structure             13:54:24  Jan 06, 2024   Page   41Terminal   Interrupt Handling Task                                       *  442B 34   76       send_SI   pshs   d,x,y,u   save registers  442D FE   0444               ldu    SI_Q_ptr  get Q head  4430 1183 0444               cmpu   #SI_Q_ptr check for overflow  4434 24   0D                 bhs    90f       exit if so - sorry                     *  4436 34   04                 pshs   b                     **!       ldd     ttask,x    task id  4438 ED   C1                 std    0,u++                     **!       ldd     tdevic,x   get terminal #  443A ED   C1                 std    0,u++     place value in Queue  443C 35   04                 puls   b  443E E7   C0                 stb    0,u+  4440 FF   0444               stu    SI_Q_ptr  update pointer                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *                     *  4443 108E 040E     90        ldy    #SI_Q     wake up Queue server  4447 BD   4556               jsr    wakeup  444A 35   F6                 puls   d,x,y,u,pc return                     FIO Simulation Structure             13:54:24  Jan 06, 2024   Page   42History    Entry Procedures                                                                   *                     * H_cpu - Place a transaction from the CPU into                     *         the history Queue.                     *  444C 34   16       H_cpu     pshs   d,x  444E BE   049A               ldx    hstptr    get history queue pointer  4451 96   00                 lda    cpu_fio  4453 A7   84                 sta    hst_cmd,x  4455 96   01                 lda    cpu_fio1  4457 A7   01                 sta    hst_seq,x  4459 96   04                 lda    cpu_fio3  445B A7   02                 sta    hst_tty,x  445D 96   03                 lda    cpu_fio2  445F A7   03                 sta    hst_val,x  4461 30   04                 leax   HRECSIZ,x  4463 8C   049A               cmpx   #hstptr   end of Queue?  4466 25   03                 blo    10f  4468 8E   045A               ldx    #hstbuf  446B BF   049A     10        stx    hstptr  446E 35   96                 puls   d,x,pc                                          *                     * H_fio - Place a transaction from the IOP into                     *         the history Queue.                     *  4470 34   16       H_fio     pshs   d,x  4472 BE   049A               ldx    hstptr    get history queue pointer  4475 96   09                 lda    fio_cpu  4477 A7   84                 sta    hst_cmd,x  4479 96   0A                 lda    fio_cpu1  447B A7   01                 sta    hst_seq,x  447D 96   0D                 lda    fio_cpu3  447F A7   02                 sta    hst_tty,x  4481 96   0C                 lda    fio_cpu2  4483 A7   03                 sta    hst_val,x  4485 30   04                 leax   HRECSIZ,x  4487 8C   049A               cmpx   #hstptr   end of Queue?  448A 25   03                 blo    10f  448C 8E   045A               ldx    #hstbuf  448F BF   049A     10        stx    hstptr  4492 35   96                 puls   d,x,pcFIO Simulation Structure             13:54:25  Jan 06, 2024   Page   43Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       4494 BE   0409     change    ldx    utask     point to task table entry >4497 17   006D               lbsr   putrun    put on ready list                     *  449A               rsched    seti   mask      interrupts  449A 1A   50                 orcc   #FF|IF                               endm  449C BE   0409               ldx    utask     point to current task  449F 10EF 88 13              sts    umark0,x  save stack pointers  44A3 BE   049C               ldx    tsktab    point to task table  44A6 8D   23                 bsr    swtchu    switch users  44A8 7F   040D               clr    idle      reset idle/running flag                     *  44AB 7F   040C     rsche2    clr    chproc    reset change flag >44AE 17   0025               lbsr   getjob    get a new task  44B1 26   0C                 bne    rsche3    find one?                                          ***+++                     ***---                       44B3 86   7F       05        lda    #127      set higheset priority  44B5 B7   040B               sta    jobpri    set as current  44B8                         clri   clear     interrupts  44B8 1C   AF                 andcc  #!(FF|IF)                               endm                     * idle work could go on here  44BA 12                      nop  44BB                         seti  44BB 1A   50                 orcc   #FF|IF                               endm  44BD 20   EC                 bra    rsche2    loop til find a ready one                     *  44BF F7   040B     rsche3    stb    jobpri    set new priority  44C2 8D   07                 bsr    swtchu    switch users top pageFIO Simulation Structure             13:54:25  Jan 06, 2024   Page   44Scheduler  routines                                   44C4 BE   0409               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  44C7 CC   0001               ldd    #1        return 1 to new task  44CA 39                      rts              return                                              *                     * Switch users                     *   X - Task entry for new task                     *  44CB 35   20       swtchu    puls   y         get return address  44CD BF   0409               stx    utask     set up new running task  44D0 10EE 88 13              lds    umark0,x  reset stack                                          ***+++                     ***---                       44D4 6E   A4                 jmp    0,y       return to caller                                          ***+++                     ***---                                                                                    ***+++                     ***---                                          FIO Simulation Structure             13:54:25  Jan 06, 2024   Page   45Scheduler  routines                                                                           *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       44D6 5F            getjob    clrb             clear      flag  44D7 BE   0403               ldx    runlst    point to head of list  44DA 27   1F                 beq    getjo6    empty list?                     *  44DC A6   04       getjo1    lda    tsstat,x  get status byte  44DE 81   01                 cmpa   #TRUN     is it in run state?  44E0 26   1B                 bne    getjo8                     *  44E2 5D                      tstb             first      in list?  44E3 27   06                 beq    getjo2                     *  44E5 EC   84                 ldd    tslink,x  remove from list  44E7 ED   A4                 std    tslink,y  44E9 20   07                 bra    getjo4                     *  44EB 10AE 84       getjo2    ldy    tslink,x  remove from list head  44EE 10BF 0403               sty    runlst    set new head                     *  44F2 E6   05       getjo4    ldb    tsprir,x  get priority  44F4 6F   84                 clr    tslink,x  zero out link  44F6 6F   01                 clr    tslink+1,x so not run list  44F8 86   FF                 lda    #$ff      set ne status  44FA 39                      rts              return                         *  44FB 4F            getjo6    clra             set        eq status  44FC 39                      rts                     *  44FD 1F   12       getjo8    tfr    x,y       save old pos  44FF AE   84                 ldx    tslink,x  follow link  4501 27   F8                 beq    getjo6                     *  4503 C6   01                 ldb    #1        set flag  4505 20   D5                 bra    getjo1    repeat loop                     FIO Simulation Structure             13:54:26  Jan 06, 2024   Page   46Scheduler  routines                                                                           *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       4507 34   01       putrun    pshs   cc        save status  4509                         seti   mask      interrupts  4509 1A   50                 orcc   #FF|IF                               endm  450B 10BE 0403               ldy    runlst    point to head  450F 26   0A                 bne    putru2  4511 BF   0403               stx    runlst    set new head                     *  4514 CC   0000     putru1    ldd    #0        set last link  4517 ED   84                 std    tslink,x  4519 35   81                 puls   cc,pc     return                     *  451B E6   05       putru2    ldb    tsprir,x  get priority  451D E1   25                 cmpb   tsprir,y  look for correct prior slot  451F 2F   08                 ble    putru4                     *  4521 FC   0403               ldd    runlst  4524 BF   0403               stx    runlst    set new head  4527 20   0F                 bra    putru5    link in rest                     *  4529 1F   23       putru4    tfr    y,u       save last look  452B 10AE A4                 ldy    tslink,y  follow link  452E 27   0C                 beq    putru6                     *  4530 E1   25                 cmpb   tsprir,y  check priority  4532 2F   F5                 ble    putru4                     *  4534 EC   C4                 ldd    tslink,u  link into list here  4536 AF   C4                 stx    tslink,u                     *  4538 ED   84       putru5    std    tslink,x  453A 35   81                 puls   cc,pc     return                     *  453C AF   C4       putru6    stx    tslink,u  453E 20   D4                 bra    putru1    go zero last link                     FIO Simulation Structure             13:54:26  Jan 06, 2024   Page   47Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       4540 86   01       makrdy    lda    #TRUN     set status  4542 A7   04                 sta    tsstat,x  4544 CC   0000               ldd    #0        clear events flag  4547 ED   06                 std    tsevnt,x  4549 8D   BC                 bsr    putrun    put on ready list  454B E6   05                 ldb    tsprir,x  get priority  454D F1   040B               cmpb   jobpri    higher than current?  4550 2F   03                 ble    makrd6                     *  4552 7C   040C               inc    chproc    set change flag                     *  4555 39            makrd6    rts              return    FIO Simulation Structure             13:54:26  Jan 06, 2024   Page   48Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       4556 34   57       wakeup    pshs   cc,d,x,u  save registers  4558                         seti   mask      interupts  4558 1A   50                 orcc   #FF|IF                               endm  455A CE   0405               ldu    #slplst  455D AE   42                 ldx    tsslnk,u  point to sleep list  455F 27   0B                 beq    wakeu4                     *  4561 10AC 06       wakeu2    cmpy   tsevnt,x  check event  4564 27   08                 beq    wakeu5  4566 33   84                 leau   0,x       mark this entry                     *  4568 AE   02       wakeu3    ldx    tsslnk,x  follow chain  456A 26   F5                 bne    wakeu2    end of list?                     *  456C 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  456E 34   70       wakeu5    pshs   x,y,u     save registers  4570 EC   02                 ldd    tsslnk,x  remove from list  4572 ED   42                 std    tsslnk,u  4574 8D   CA                 bsr    makrdy    put on ready list  4576 35   70                 puls   u,x,y  4578 20   EE                 bra    wakeu3    repeat                     FIO Simulation Structure             13:54:26  Jan 06, 2024   Page   49Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *  457A 34   51       sleep     pshs   cc,x,u    save registers  457C BE   0409               ldx    utask     point to task  457F 6D   08                 tst    tssgnl,x  any signals waiting?  4581 26   1F                 bne    sleep7                     *  4583                         seti   mask      ints  4583 1A   50                 orcc   #FF|IF                               endm  4585 E7   05                 stb    tsprir,x  set priority  4587 10AF 06                 sty    tsevnt,x  set event  458A 86   02                 lda    #TSLEEP   set status  458C A7   04                 sta    tsstat,x  458E FC   0407               ldd    slplst+tsslnk get head of list  4591 ED   02                 std    tsslnk,x  set new link  4593 BF   0407               stx    slplst+tsslnk set new head  4596 17   FF01               lbsr   rsched    reschedule cpu                       4599 BE   0409     20        ldx    utask     get task entry  459C 6D   08                 tst    tssgnl,x  any signals waiting?  459E 26   02                 bne    sleep7                     *  45A0 35   D1                 puls   cc,x,u,pc return                     *  45A2 BE   0409     sleep7    ldx    utask     reset signal  45A5 6F   08                 clr    tssgnl,x  45A7 EC   88 15              ldd    umark1,x  stack reset point  45AA 35   51                 puls   cc,x,u    reset cc and registers  45AC 1F   04                 tfr    d,s       change stacks  45AE 39                      rts              returnFIO Simulation Structure             13:54:26  Jan 06, 2024   Page   50Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  jsr xmtint                     *  45AF 34   76       xmtint    pshs   d,x,y,u   save registers  45B1 A6   04                 lda    tsstat,x  get task state  45B3 81   01                 cmpa   #TRUN     running?  45B5 26   06                 bne    10f       no - try something else                     *  45B7 86   01                 lda    #1        set signal  45B9 A7   08                 sta    tssgnl,x  45BB 20   0E                 bra    99f       exit                     *  45BD 81   02       10        cmpa   #TSLEEP   task sleeping?  45BF 26   0A                 bne    99f       no - can't send interrupt                     *  45C1 86   01                 lda    #1        set signal  45C3 A7   08                 sta    tssgnl,x  45C5 10AE 06                 ldy    tsevnt,x  wake task up >45C8 17   FF8B               lbsr   wakeup                     *  45CB 35   F6       99        puls   d,x,y,u,pc returnFIO Simulation Structure             13:54:27  Jan 06, 2024   Page   51Sleep      and Wakeup routines                                                                *                     * the routines in this file are specific                     * for the W5500 socket device                     * they are called from "wskhan" and "wskdrv" files                     *                     * wzsocket device table                     *  45CD               DEV_SOCK  45CD 4392                    fdb    bad_cmd   0  45CF 4651                    fdb    skopen    S_OPEN    1 open socket  45D1 46CA                    fdb    skclos    S_CLOSE   2 close socket  45D3 48C5                    fdb    skreqwr   S_RQWR    3 request write to socket  45D5 4906                    fdb    sksend    S_SEND    4 write data to socket  45D7 485B                    fdb    skreqrd   S_RQRD    5 request read data from socket  45D9 48A3                    fdb    skrecv    S_RECV    6 read data from socket  45DB 4B4E                    fdb    skintrp   S_INTRPT  7 interrupt socket  45DD 4717                    fdb    skconn    S_CONNECT 8 connect socket  45DF 47AD                    fdb    skbind    S_BIND    9 bind socket  45E1 47F2                    fdb    sklist    S_LISTEN  10 listen on socket  45E3 4824                    fdb    skacpt    S_ACCEPT  11 accept connection  45E5 4B4E                    fdb    skdisc    S_DISCON  12 disconnect socket  45E7 4B4E                    fdb    sksmac    S_SNDMAC  13 send mac  45E9 4B4E                    fdb    skskep    S_SNDKEP  14 send keep alive  45EB 4A96                    fdb    skspcl    S_SPCL    15 special command  45ED 4928                    fdb    skurrdf   S_RRDFRM  16 request read readfrom  45EF 49A9                    fdb    skurrd    S_RREAD   17 read data readfrom  45F1 49D3                    fdb    skurwt    S_WRQSTO  18 request write sendto  45F3 4A6A                    fdb    skusnt    S_WSNDTO  19 write data sendto                     *  45F5 4618                    fdb    skinthan  16 socket interrupt handler  45F7 45FB                    fdb    skinit    17 socket initialization  45F9 4615                    fdb    sktest    18 test device present                     *                     *                     * this file contains all socket handlers                     *                     * when a wzsocket is opened, all locations are effectively                     * cleared to zero, with exception of the enumeration byte                     *                                          *                     * do everything to init the system                     *               45FB  skinit    equ    *  45FB BD   4B55               jsr    spinit    set SPI  45FE C6   80                 ldb    #%10000000 software reset  4600 BD   4C25               jsr    PCRMR  4603 BD   4C16     01        jsr    GCRMR  4606 5D                      tstb  4607 2B   FA                 bmi    01b  4609 C6   78                 ldb    #%01111000 power upFIO Simulation Structure             13:54:27  Jan 06, 2024   Page   52wz socket interface routines                          460B BD   4E03               jsr    PCRPHY    set the PHY part  460E CC   8000               ldd    #32768  4611 FD   0457               std    wzanyp    set value for Source port  4614 39                      rts                                          *                     * test if device is present                     *  4615 1A   01       sktest    sec              yes  4617 39                      rts                                          *                     * skinthan, fromddevice table                     *               4618  skinthan  equ    *  4618 39                      rts                                          *                     * device signal handle                     *               4619  sdev_sig  equ    *  4619 39                      rts                                          *                     * get a new source port                     *  461A FC   0457     sknewp    ldd    wzanyp    else create one  461D                         incd  461D 104C                    fdb    $104c                               endm  461F 1083 FFF0               cmpd   #$FFF0  4623 25   03                 blo    03f  4625 CC   8000               ldd    #$8000  4628 FD   0457     03        std    wzanyp  462B 39                      rts                                                               *                     * wzdevt, device test, return Z if running, NZ if not                     *  462C 34   22       wzdevt    pshs   a,y  462E 109E 1A                 ldy    fifo_us1  device info  4631 A6   A8 12              lda    wzdsta,y  4634 81   FF                 cmpa   #$ff      open  4636 35   A2                 puls   a,y,pc                                          *                     * skfres, socket restore info                     *  4638 A6   C4       skfres    lda    wzenum,u  socket #, is remembered  463A                         trfr   A,E  463A 1F                      fcb    $1fFIO Simulation Structure             13:54:27  Jan 06, 2024   Page   53wz socket interface routines                          463B 8E                      fcb    A<<4|E                               endm  463C 6F   47                 clr    wzerr,u   init result  463E 39                      rts                                          *                     * skctcp, check if in TCP mode                     * return zero if in TCP mode, non-zero if not                     * U = wzsock                     *  463F 34   06       skctcp    pshs   d  4641 EC   C8 24              ldd    wztype,u  SOCK_STREAM  4644 C1   01                 cmpb   #SK_STRM  is TCP  4646 35   86                 puls   d,pc                                          *                     * skcudp, check if in UDP mode                     * return zero if in UDP mode, non-zero if not                     * U = wzsock                     *  4648 34   06       skcudp    pshs   d  464A EC   C8 24              ldd    wztype,u  SOCK_DGRAM  464D C1   02                 cmpb   #SK_DGRM  is UDP  464F 35   86                 puls   d,pc                                          ****************************************************************                     *                     * here the socket is opened                     * X hold the TASK table                     * U holds the sock address                     *               4651  skopen    equ    * >4651 BD   4638               jsr    skfres                     *                     * check if DEVICE is active                     * >4654 BD   462C               jsr    wzdevt  4657 27   06                 beq    11f  4659 BD   46E5               jsr    skclin    NO, close internal and don't start >465C 16   003D     04        lbra   skoper1                     *                     * retry, we do all things                     *  465F A6   42       11        lda    wzfsta,u  check if allocated by OS  4661 2A   F9                 bpl    04b       no, do nothing                     *                     * check socket() call arguments                     *  4663 6F   43                 clr    wzflg,u   erase flags  4665 EC   C8 22              ldd    wzfaml,u  4668 C1   02                 cmpb   #AF_INET  466A 26   F0                 bne    04b       not supportedFIO Simulation Structure             13:54:28  Jan 06, 2024   Page   54wz socket interface routines                                             * wztype holds socket type AND socket flags (hibyte)  466C EC   C8 24              ldd    wztype,u  466F C1   01                 cmpb   #SK_STRM  SOCK_STREAM  4671 27   10                 beq    01f  4673 C1   02                 cmpb   #SK_DGRM  SOCK_DGRAM  4675 27   08                 beq    21f  4677 C1   03                 cmpb   #SK_RAW   SOCK_RAW  4679 26   25                 bne    skoper2                     * raw socket  467B C6   04                 ldb    #%00000100 MACRAW  467D 20   06                 bra    07f                     * dgram  467F C6   02       21        ldb    #%00000010 UDP  4681 20   02                 bra    07f                     * TCP socket  4683 C6   01       01        ldb    #%00000001 TCP set source port in connect                     *                     * set socket mode register                     *  4685 BD   4E30     07        jsr    PSRMR     set socket mode register                     *                     * here do the real OPEN,                     *  4688 C6   01                 ldb    #WCOPEN   open the device  468A E7   44                 stb    wzcmnd,u  copy command  468C BD   4E4E               jsr    PSRCR                     *                     * interrupts not expected for 'open'                     *  468F BD   4E82     21        jsr    GSRSR     get status  4692 E7   45                 stb    wzstat,u  4694 C1   00                 cmpb   #WSCLSD  4696 27   F7                 beq    21b       wait until updated                     *  4698 4F                      clra  4699 C6   01                 ldb    #R_OPEN   response  469B 39            99        rts                     *  469C 86   01       skoper1   lda    #1        device not initialized  469E 20   02                 bra    12f  46A0 86   02       skoper2   lda    #2        type error  46A2 C6   C0       12        ldb    #E_SOCKET  46A4 20   F5                 bra    99b                                          *                     * convert number in bit position                     * B = enum, B=bit                     *  46A6 34   10       num2bt    pshs   x  46A8 8E   46C1               ldx    #bittab  46AB 3A                      abx  46AC E6   84                 ldb    0,xFIO Simulation Structure             13:54:28  Jan 06, 2024   Page   55wz socket interface routines                          46AE 35   90                 puls   x,pc                                          *                     * bit to nummer, offset byt one, entry should NOT be 0                     *  46B0 34   10       bt2num    pshs   x  46B2 8E   46C1               ldx    #bittab  46B5 6F   E2                 clr    0,-s  46B7 E1   80       02        cmpb   0,x+  46B9 27   04                 beq    01f  46BB 6C   E4                 inc    0,s  46BD 20   F8                 bra    02b  46BF 35   94       01        puls   b,x,pc                                          * table  46C1 00            bittab    fcb    0  46C2 01 02 04 08             fcb    %00000001,%00000010,%00000100,%00001000  46C6 10 20 40 80             fcb    %00010000,%00100000,%01000000,%10000000                                          ***************************************************************                     *                     * close the socket                     * X hold the task table                     * U holds the sock address                     *               46CA  skclos    equ    *  46CA BD   4638               jsr    skfres  46CD C6   08                 ldb    #WCDISC  46CF E7   44                 stb    wzcmnd,u  46D1 BD   4E4E               jsr    PSRCR     send disconnect                     *  46D4 8D   0F                 bsr    skclin  46D6                         clrd  46D6 104F                    fdb    $104f                               endm  46D8 ED   C8 22              std    wzfaml,u  46DB ED   C8 24              std    wztype,u  46DE ED   C8 26              std    wzprot,u                     *  46E1 4F                      clra  46E2 C6   02                 ldb    #R_CLOSE  response  46E4 39                      rts                                          *                     * wzclin, close interal                     *  46E5 34   06       skclin    pshs   d  46E7 C6   10                 ldb    #WCCLOS   do close  46E9 E7   44                 stb    wzcmnd,u  46EB BD   4E4E               jsr    PSRCR                     *                     * erase registers in deviceFIO Simulation Structure             13:54:28  Jan 06, 2024   Page   56wz socket interface routines                                             *  46EE CC   0000               ldd    #0  46F1 BD   4EA0               jsr    PSRPORT   source port                     *  46F4 A6   42                 lda    wzfsta,u  46F6 84   F9                 anda   #!(WZSKIO+WZSKIS) reset io mode and is sending  46F8 A7   42                 sta    wzfsta,u  46FA CC   0000               ldd    #0  46FD ED   48                 std    wzxfer,u  clear remaining size                     *  46FF BD   4E82     91        jsr    GSRSR  4702 E7   45                 stb    wzstat,u  stat = 0 (closed)                     *  4704 CC   0000               ldd    #0  4707 ED   C8 10              std    wzsprt,u  erase old info  470A ED   C8 14              std    wzipad,u  470D ED   C8 16              std    wzipad+2,u  4710 ED   C8 12              std    wzdprt,u  4713 E7   43                 stb    wzflg,u   clear flags                     *  4715 35   86                 puls   d,pc                                          ***************************************************************                     *                     * connect socket                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               4717  skconn    equ    *  4717 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  471A BD   462C               jsr    wzdevt  471D 27   06                 beq    01f >471F BD   46CA               jsr    skclos    NO, don't start >4722 16   007A     02        lbra   skcner4  4725 BD   463F     01        jsr    skctcp    not in tcp, illegal  4728 26   F8                 bne    02b                     *                     * check if socket has been set up                     *  472A BD   4E82     11        jsr    GSRSR     status  472D E7   45                 stb    wzstat,u  check if properly setup  472F C1   13                 cmpb   #WSINIT   SHOULD BE >4731 1026 005F               lbne   skcner6                     *                     * check the info from the connect call                     *  4735 EC   C8 14              ldd    wzipad,u  check if dest IP == null  4738                         ordx   wzipad+2,IUFIO Simulation Structure             13:54:28  Jan 06, 2024   Page   57wz socket interface routines                          4738 10AA                    fdb    $10aa  473A                         doindx wzipad+2,IU  473A C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm  473C 27   65                 beq    skcner1   IP address == NULL                     * IP address = 0000  473E EC   C8 14              ldd    wzipad,u  or FFFFFFFF  4741                         incd  4741 104C                    fdb    $104c                               endm  4743 26   07                 bne    01f  4745 EC   C8 16              ldd    wzipad+2,u  4748                         incd  4748 104C                    fdb    $104c                               endm  474A 27   57                 beq    skcner1   IP address = FFFFFFFF                     *                     * valid IP                     *  474C EC   C8 12    01        ldd    wzdprt,u  check destination port  474F 27   4A                 beq    skcner5   is not set, error                     *  4751 BD   4F2A               jsr    PSRDPOR   set destination port  4754 31   C8 14              leay   wzipad,u  load socket  4757 BD   4F04               jsr    PSRDIP    set destination IP                     *                     * source port, create one, always unique                     *  475A BD   461A               jsr    sknewp    get new  475D ED   C8 10              std    wzsprt,u  tell us what you took  4760 BD   4EA0               jsr    PSRPORT   source port                     *                     * do the CONNECT here                     *  4763 C6   04                 ldb    #WCCONN  4765 E7   44                 stb    wzcmnd,u  4767 BD   4E4E               jsr    PSRCR     do connect                     *                     *                     *  476A BD   4638     conlb1    jsr    skfres  476D BD   4E82               jsr    GSRSR     update status  4770 E7   45                 stb    wzstat,u  4772 C1   17                 cmpb   #WSESTB  4774 27   0A                 beq    90f  4776 C1   00                 cmpb   #WSCLSD  4778 27   16                 beq    skcner2  477A 108E 476A               ldy    #conlb1  477E 20   04                 bra    polext                     *  4780 4F            90        clraFIO Simulation Structure             13:54:29  Jan 06, 2024   Page   58wz socket interface routines                          4781 C6   08                 ldb    #R_CONNECT  4783 39            99        rts                                          *                     * polexit, Y=where to return                     *  4784 10AF 0F       polext    sty    tsagin,x  here to restart  4787 C6   BA                 ldb    #POLPRI  4789 E7   05                 stb    tsprir,x  478B 108E FFFF               ldy    #$ffFF  478F 39                      rts                       4790 C6   0C       skcner2   ldb    #R_DISCON  4792 20   EF                 bra    99b                       4794 BD   46E5     skcner6   jsr    skclin    reset open  4797 86   0F                 lda    #15       not properly setup  4799 20   0E                 bra    09f  479B 86   0E       skcner5   lda    #14       destination port not set  479D 20   0A                 bra    09f  479F 86   0A       skcner4   lda    #10       device not initialized  47A1 20   06                 bra    09f  47A3 86   0B       skcner1   lda    #11       IP address invalid  47A5 20   02                 bra    09f  47A7 86   0D       skcner3   lda    #13  47A9 C6   C0       09        ldb    #E_SOCKET  47AB 20   D6                 bra    99b                                          ***************************************************************                     *                     * bind request                     * X hold the task table                     * U holds the sock address                     * bindt() call fills in info in the sock structure                     *               47AD  skbind    equ    *  47AD BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  47B0 BD   462C               jsr    wzdevt  47B3 1026 00E7               lbne   rdrqer1  47B7 BD   463F               jsr    skctcp    check TCP  47BA 27   12                 beq    01f  47BC BD   4648               jsr    skcudp    check UDP >47BF 1026 FFD1               lbne   skcner6                     *                     * go on                     *                     *  47C3 BD   4E82               jsr    GSRSR     status  47C6 E7   45                 stb    wzstat,uFIO Simulation Structure             13:54:29  Jan 06, 2024   Page   59wz socket interface routines                          47C8 C1   22                 cmpb   #WSUDP    check  47CA 27   0D                 beq    03f  47CC 20   07                 bra    04f                       47CE BD   4E82     01        jsr    GSRSR     status  47D1 E7   45                 stb    wzstat,u  47D3 C1   13                 cmpb   #WSINIT   should be >47D5 1026 FFBB     04        lbne   skcner6                     * set the network connection data  47D9 BD   461A     03        jsr    sknewp  47DC ED   C8 12              std    wzdprt,u  set by bind()  47DF BD   4F2A               jsr    PSRDPOR  47E2 EC   C8 10              ldd    wzsprt,u  47E5 BD   4EA0               jsr    PSRPORT                     *  47E8 31   C8 14              leay   wzipad,u  47EB BD   4F04               jsr    PSRDIP    source IP                     *  47EE 4F                      clra  47EF C6   09                 ldb    #R_BIND  47F1 39                      rts                     *                                          ***************************************************************                     *                     * listen request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               47F2  sklist    equ    *  47F2 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  47F5 BD   462C               jsr    wzdevt  47F8 1026 00A2     02        lbne   rdrqer1  47FC BD   463F               jsr    skctcp  47FF 26   F7                 bne    02b                     *                     * go on                     *                     *  4801 BD   4E82               jsr    GSRSR     status  4804 E7   45                 stb    wzstat,u                     *  4806 C1   00                 cmpb   #WSCLSD   closed?  4808 27   0F                 beq    80f  480A C1   13                 cmpb   #WSINIT   opened  480C 26   0F                 bne    90f                     *  480E C6   02                 ldb    #WCLISTFIO Simulation Structure             13:54:29  Jan 06, 2024   Page   60wz socket interface routines                          4810 E7   44                 stb    wzcmnd,u  4812 BD   4E4E               jsr    PSRCR                     *  4815 4F                      clra  4816 C6   0A                 ldb    #R_LISTEN  4818 39                      rts                                          *  4819 4F            80        clra  481A C6   02                 ldb    #R_CLOSE  481C 39                      rts                     *  481D 108E 47F2     90        ldy    #sklist  4821 7E   4784               jmp    polext                                          ***************************************************************                     *                     * accept request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               4824  skacpt    equ    *  4824 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  4827 BD   462C               jsr    wzdevt >482A 1026 0070     02        lbne   rdrqer1  482E BD   463F               jsr    skctcp  4831 26   F7                 bne    02b       wrong mode                     *                     * go on                     *  4833 BD   4E82               jsr    GSRSR     status  4836 E7   45                 stb    wzstat,u  4838 C1   17                 cmpb   #WSESTB   connected  483A 26   10                 bne    01f  483C BD   4F1B               jsr    GSRDPOR   fill in peer port  483F ED   C8 12              std    wzdprt,u  4842 31   C8 14              leay   wzipad,u  4845 BD   4EED               jsr    GSRDIP                     *  4848 4F                      clra  4849 C6   0B                 ldb    #R_ACCEPT  484B 39                      rts                     *  484C C1   00       01        cmpb   #WSCLSD  484E 26   04                 bne    02f  4850 4F                      clra  4851 C6   02                 ldb    #R_CLOSE  4853 39                      rtsFIO Simulation Structure             13:54:30  Jan 06, 2024   Page   61wz socket interface routines                                             *  4854 108E 4824     02        ldy    #skacpt  4858 7E   4784               jmp    polext                                                               ***************************************************************                     *                     * read request  TCP only !!                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               485B  skreqrd   equ    *  485B BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  485E BD   462C               jsr    wzdevt >4861 1026 0039     02        lbne   rdrqer1  4865 BD   463F               jsr    skctcp    check TCP  4868 26   F7                 bne    02b                     *                     * go on                     *                     *  486A BD   4E82               jsr    GSRSR  486D E7   45                 stb    wzstat,u  update status  486F BD   501B               jsr    GSRRXRS   data available?  4872 ED   48                 std    wzxfer,u  4874 26   20                 bne    70f                     *  4876 A6   C8 24              lda    wztype,u  check flags  4879 85   01                 bita   #WFNBLK   non block  487B 26   15                 bne    75f                     *  487D E6   45                 ldb    wzstat,u  487F C1   17       17        cmpb   #WSESTB   still active  4881 27   08                 beq    20f                       4883 C1   1C                 cmpb   #WSCLWT  4885 27   13                 beq    60f  4887 C1   00                 cmpb   #WSCLSD  4889 27   0F                 beq    60f                     *  488B 108E 485B     20        ldy    #skreqrd  488F 7E   4784               jmp    polext                                          *************************  4892 4F            75        clra  4893 C6   15                 ldb    #R_RQRDNB tell no data  4895 39                      rts                     FIO Simulation Structure             13:54:30  Jan 06, 2024   Page   62wz socket interface routines                                             * data present  4896 4F            70        clra  4897 C6   05                 ldb    #R_RQRD  4899 39                      rts                                          * close socket and return  489A 4F            60        clra  489B C6   02                 ldb    #R_CLOSE  489D 39                      rts                                            489E 86   82       rdrqer1   lda    #130  48A0 C6   C0                 ldb    #E_SOCKET  48A2 39                      rts                                          ***************************************************************                     *                     * get the data  U=wzsock                     *               48A3  skrecv    equ    *  48A3 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  48A6 BD   462C               jsr    wzdevt >48A9 1026 FFF1               lbne   rdrqer1  48AD BD   463F     02        jsr    skctcp  48B0 26   FB                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  48B2 BD   501B               jsr    GSRRXRS   received size                     * D total aviable data  48B5 BD   50EB               jsr    RDSK2FB   transfer datat to fifo  48B8 ED   48                 std    wzxfer,u  save it  48BA C6   40                 ldb    #WCRECV  48BC E7   44                 stb    wzcmnd,u  48BE BD   4E4E               jsr    PSRCR     tell sender we took it                       48C1 C6   06                 ldb    #R_READ   tell data in fifo  48C3 4F                      clra  48C4 39                      rts                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *FIO Simulation Structure             13:54:30  Jan 06, 2024   Page   63wz socket interface routines                                       48C5  skreqwr   equ    *  48C5 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  48C8 BD   462C               jsr    wzdevt >48CB 1026 FFCF     02        lbne   rdrqer1  48CF BD   463F               jsr    skctcp  48D2 26   F7                 bne    02b                     *                     * go on                     *                     *  48D4 BD   4E82               jsr    GSRSR  48D7 E7   45                 stb    wzstat,u  update status  48D9 BD   4FCF               jsr    GSRTXFR   free size (remaining)  48DC 10A3 4A                 cmpd   wzrqln,u  would it fit  48DF 24   15                 bhs    70f                     *  48E1 E6   45       10        ldb    wzstat,u  48E3 C1   17                 cmpb   #WSESTB  48E5 27   18                 beq    20f  48E7 C1   1C                 cmpb   #WSCLWT  48E9 27   11                 beq    60f  48EB C1   00                 cmpb   #WSCLSD  48ED 26   10                 bne    20f  48EF CC   0000               ldd    #0  48F2 ED   48                 std    wzxfer,u  48F4 20   06                 bra    60f                     * data space  48F6 4F            70        clra  48F7 C6   03                 ldb    #R_RQWR  48F9 39                      rts                                          * data space exhausted, would block  48FA 4F            72        clra                     **        ldb     #R_RQWRWB  48FB 39                      rts                                          * close socket and return  48FC C6   02       60        ldb    #R_CLOSE  48FE 39                      rts                                          *  48FF 108E 48C5     20        ldy    #skreqwr  4903 7E   4784               jmp    polext                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock addressFIO Simulation Structure             13:54:31  Jan 06, 2024   Page   64wz socket interface routines                                             * connect() call fills in info in the sock structure                     *               4906  sksend    equ    *  4906 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  4909 BD   462C               jsr    wzdevt >490C 1026 FF8E     02        lbne   rdrqer1  4910 BD   463F               jsr    skctcp  4913 26   F7                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  4915 BD   4FCF               jsr    GSRTXFR   free size (remaining)                     * D = total available space  4918 BD   513A               jsr    WRFB2SK   transfer from fifo to socket  491B ED   48                 std    wzxfer,u  save it  491D C6   20                 ldb    #WCSEND  491F E7   44                 stb    wzcmnd,u  4921 BD   4E4E               jsr    PSRCR     tell sender it is coming                       4924 C6   04                 ldb    #R_WRITE  tell data in fifo  4926 4F                      clra  4927 39                      rts                                          ***************************************************************                     * skurrdf, request readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               4928  skurrdf   equ    *  4928 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  492B BD   462C               jsr    wzdevt  492E 1026 FF6C     02        lbne   rdrqer1  4932 BD   4648               jsr    skcudp  4935 26   F7                 bne    02b                     *                     * go on                     *                     *  4937 EC   C8 20              ldd    wzurms,u  check remaining size  493A 26   5F                 bne    84f                     *                     * no  packet data present, wait for itFIO Simulation Structure             13:54:31  Jan 06, 2024   Page   65wz socket interface routines                                             *  493C BD   4E82               jsr    GSRSR  493F E7   45                 stb    wzstat,u  update status  4941 BD   501B               jsr    GSRRXRS   data available?  4944 ED   7E                 std    -2,s      test D  4946 26   1B                 bne    22f       keep waiting                     * no data yet, check socket state  4948 E6   45                 ldb    wzstat,u  494A C1   22                 cmpb   #WSUDP    still active  494C 27   0E                 beq    20f                       494E C1   1C                 cmpb   #WSCLWT  4950 27   4D                 beq    60f  4952 C1   00                 cmpb   #WSCLSD  4954 27   49                 beq    60f  4956 EC   C8 10              ldd    wzsprt,u  4959 BD   4EA0               jsr    PSRPORT   set source port                     *  495C 108E 4928     20        ldy    #skurrdf  4960 7E   4784               jmp    polext                     *                     * first data present, set wzuipa, wzuprt, wzurms                     *  4963 31   C8 1A    22        leay   wzuipa,u  4966 CC   0008               ldd    #8        size of header  4969 BD   4BAD               jsr    bmread    copy data                     *                     * header copied , update wzsock                     *  496C EC   C8 1E              ldd    wzuprt,u  now we know who is sending  496F ED   C8 12              std    wzdprt,u  get dest port from packet  4972 BD   4EA0               jsr    PSRPORT   set device  4975 109E 1A                 ldy    fifo_us1  4978 EC   A4                 ldd    wzmyip,y  497A ED   C8 14              std    wzipad,u  497D EC   22                 ldd    wzmyip+2,y  497F ED   C8 16              std    wzipad+2,u                     * move pointer  4982 BD   5032               jsr    GSRRXRP  4985 C3   0008               addd   #8  4988 BD   5041               jsr    PSRRXRP   update pointer  498B C6   40                 ldb    #WCRECV  498D E7   44                 stb    wzcmnd,u  process move  498F BD   4E4E               jsr    PSRCR                     *  4992 EC   C8 20              ldd    wzurms,u  4995 1083 05C0               cmpd   #MAX_UDP  max size  4999 22   08                 bhi    78f                     *  499B 4F            84        clra  499C C6   21                 ldb    #R_RDFRM  499E 39                      rtsFIO Simulation Structure             13:54:31  Jan 06, 2024   Page   66wz socket interface routines                                                                  * close socket and return  499F 4F            60        clra  49A0 C6   02                 ldb    #R_CLOSE  49A2 39                      rts                                          *  49A3 BD   46E5     78        jsr    skclin    close  49A6 C6   C0                 ldb    #E_SOCKET  49A8 39                      rts                                          ***************************************************************                     * skurrd,  data readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               49A9  skurrd    equ    *  49A9 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  49AC BD   462C               jsr    wzdevt  49AF 1026 FEEB     02        lbne   rdrqer1  49B3 BD   4648               jsr    skcudp  49B6 26   F7                 bne    02b                     *                     * go on                     *                     *                     * transfer at most fio_fsz bytes  49B8 EC   C8 20              ldd    wzurms,u  this is leading count                     * D = total available data  49BB BD   50EB               jsr    RDSK2FB   transfer data  49BE 34   06                 pshs   d         xferred count  49C0 EC   C8 20              ldd    wzurms,u  update  49C3 A3   E1                 subd   0,s++  49C5 ED   C8 20              std    wzurms,u  new remaining                     *  49C8 C6   40       01        ldb    #WCRECV  49CA E7   44                 stb    wzcmnd,u  set processed  49CC BD   4E4E               jsr    PSRCR                     *  49CF 4F                      clra  49D0 C6   22                 ldb    #R_RRDFD  49D2 39                      rts                                                               ***************************************************************                     * skurwt,  request sendto                     *FIO Simulation Structure             13:54:32  Jan 06, 2024   Page   67wz socket interface routines                                             *                     * X hold the task table                     * U holds the sock address                     *               49D3  skurwt    equ    *  49D3 BD   4638               jsr    skfres                     *                     * is the DEVICE (still) active                     *  49D6 BD   462C               jsr    wzdevt  49D9 1026 FEC1     02        lbne   rdrqer1  49DD BD   4648               jsr    skcudp  49E0 26   F7                 bne    02b                     *                     * go on                     *                     *  49E2 EC   C8 12              ldd    wzdprt,u  check illegal port  49E5 27   7D                 beq    78f                     *  49E7 EC   C8 14              ldd    wzipad,u  49EA                         ordx   wzipad+2,IU  49EA 10AA                    fdb    $10aa  49EC                         doindx wzipad+2,IU  49EC C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm  49EE 27   74                 beq    78f                     * set network registers  49F0 EC   C8 12              ldd    wzdprt,u  49F3 BD   4F2A               jsr    PSRDPOR                       49F6 31   C8 14              leay   wzipad,u  49F9 BD   4F04               jsr    PSRDIP  49FC EC   C8 10              ldd    wzsprt,u  49FF 26   19                 bne    04f  4A01 BD   461A               jsr    sknewp    get new source port  4A04 ED   C8 10              std    wzsprt,u  4A07 ED   C8 1E              std    wzuprt,u  set also return port  4A0A BD   4EA0               jsr    PSRPORT                     * copy my own IP as the return address  4A0D 109E 1A                 ldy    fifo_us1  to my own IP setting  4A10 EC   A4                 ldd    wzmyip,y  copy IP for return to user  4A12 ED   C8 1A              std    wzuipa,u  4A15 EC   22                 ldd    wzmyip+2,y  4A17 ED   C8 1C              std    wzuipa+2,u                     *  4A1A 108E 4A21     04        ldy    #skuwr2   do remainder  4A1E 7E   4784               jmp    polext                                          *                     * after intial setup. loop hereFIO Simulation Structure             13:54:32  Jan 06, 2024   Page   68wz socket interface routines                                             *  4A21 BD   4638     skuwr2    jsr    skfres    set socket base  4A24 BD   462C               jsr    wzdevt    devie active >4A27 1026 FFAE               lbne   02b       no  4A2B BD   4648               jsr    skcudp    check open method  4A2E 26   A9                 bne    02b                     *  4A30 BD   4E82               jsr    GSRSR  4A33 E7   45                 stb    wzstat,u  update status  4A35 BD   4FCF               jsr    GSRTXFR   free size  4A38 10A3 C8 20              cmpd   wzurms,u  4A3C 24   15                 bhs    10f                     * no space yet  4A3E E6   45                 ldb    wzstat,u  4A40 C1   22                 cmpb   #WSUDP  4A42 27   08                 beq    20f                       4A44 C1   1C                 cmpb   #WSCLWT   is closing  4A46 27   18                 beq    60f  4A48 C1   00                 cmpb   #WSCLSD   closed  4A4A 27   14                 beq    60f                     *  4A4C 108E 49D3     20        ldy    #skurwt  4A50 7E   4784               jmp    polext    keep polling                     *  4A53 EC   C8 20    10        ldd    wzurms,u  4A56 1083 05C0               cmpd   #MAX_UDP  too big  4A5A 22   08                 bhi    78f                     *  4A5C 4F                      clra  4A5D C6   23                 ldb    #R_RSNDTO  4A5F 39                      rts                       4A60 4F            60        clra  4A61 C6   02                 ldb    #R_CLOSE  4A63 39                      rts                       4A64 BD   46E5     78        jsr    skclin    close  4A67 C6   C0                 ldb    #E_SOCKET  4A69 39                      rts                                                               ***************************************************************                     * skusnt,  data sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               4A6A  skusnt    equ    *  4A6A BD   4638               jsr    skfres                     *FIO Simulation Structure             13:54:32  Jan 06, 2024   Page   69wz socket interface routines                                             * is the DEVICE (still) active                     *  4A6D BD   462C               jsr    wzdevt  4A70 1026 FE2A     02        lbne   rdrqer1  4A74 BD   4648               jsr    skcudp  4A77 26   F7                 bne    02b                     *                     * go on                     *                     * transfer fifo to socket data register  4A79 EC   C8 20              ldd    wzurms,u  total data                     *  4A7C BD   513A               jsr    WRFB2SK   fifo to socket  4A7F 34   06                 pshs   d  4A81 EC   C8 20              ldd    wzurms,u  all loaded  4A84 A3   E1                 subd   0,s++  4A86 ED   C8 20              std    wzurms,u  4A89 26   07                 bne    01f                       4A8B C6   20                 ldb    #WCSEND  4A8D E7   44                 stb    wzcmnd,u  4A8F BD   4E4E               jsr    PSRCR                       4A92 4F            01        clra  4A93 C6   24                 ldb    #R_WSNDTO data taken  4A95 39                      rts                                                               ***************************************************************                     *                     * special function, tstval,x is indicator                     * X hold the task table                     * U holds the SPECIAL sock address (NO wz....  access!)                     *               4A96  skspcl    equ    *                     *  4A96 34   10                 pshs   x  4A98 E6   0C                 ldb    tstval,x  get index  4A9A C1   04                 cmpb   #MAXTBL  4A9C 22   18                 bhi    01f       illegal  4A9E 58                      aslb  4A9F 8E   4ABD               ldx    #functb  4AA2 10AE 85                 ldy    b,x       get special function  4AA5 27   0F                 beq    01f       not valid  4AA7 35   10                 puls   x                     *  4AA9 AD   A4                 jsr    0,y       do function  4AAB 26   05                 bne    90f                     *  4AAD 4F                      clra  4AAE C6   0F                 ldb    #R_SPCL  4AB0 20   0A                 bra    99fFIO Simulation Structure             13:54:33  Jan 06, 2024   Page   70wz socket interface routines                                             *  4AB2 86   A2       90        lda    #162  4AB4 20   04                 bra    02f                     *  4AB6 35   10       01        puls   x  4AB8 86   A1                 lda    #161  4ABA               02  4ABA C6   C0                 ldb    #E_SOCKET                     *  4ABC 39            99        rts                       4ABD 4AC5          functb    fdb    wzdev     set device settings  4ABF 4AC5                    fdb    wzdev  4AC1 4AEF                    fdb    showrg  4AC3 0000                    fdb    0               0004  MAXTBL    equ    (*-functb)/2                                                               *                     * X hold the task table                     * U holds the special sock address                     *  4AC5               wzdev  4AC5 C6   08                 ldb    #8  4AC7                         trfr   B,E  4AC7 1F                      fcb    $1f  4AC8 9E                      fcb    B<<4|E                               endm  4AC9 DE   1A                 ldu    fifo_us1  device info area  4ACB 31   C4                 leay   0,u       myip  4ACD BD   4CE5               jsr    PCRSIP    source IP  4AD0 31   44                 leay   4,u  4AD2 BD   4C79               jsr    PCRSNM    subnet mask  4AD5 31   48                 leay   8,u  4AD7 BD   4C4B               jsr    PCRGA     gateway IP  4ADA 31   4C                 leay   12,u  4ADC BD   4CAF               jsr    PCRSHA    hardware address  4ADF A6   C8 12              lda    18,u      ON/OFF  4AE2 27   04                 beq    01f  4AE4 C6   F8                 ldb    #%11111000 all on  4AE6 20   02                 bra    02f  4AE8 C6   78       01        ldb    #%01111000 all off  4AEA BD   4E03     02        jsr    PCRPHY  4AED 4F                      clra  4AEE 39                      rts                                          *                     *                     *  4AEF               showrg  4AEF C6   08                 ldb    #8  4AF1                         trfr   B,E       select first socketFIO Simulation Structure             13:54:33  Jan 06, 2024   Page   71wz socket interface routines                          4AF1 1F                      fcb    $1f  4AF2 9E                      fcb    B<<4|E                               endm  4AF3 DE   1A                 ldu    fifo_us1  4AF5 33   C8 20              leau   32,u      skip network data area  4AF8 BD   4E21               jsr    GSRMR  4AFB E7   C0                 stb    0,u+  4AFD BD   4E82               jsr    GSRSR  4B00 E7   C0                 stb    0,u+  4B02 BD   4F93               jsr    GSRRBFS  4B05 E7   C0                 stb    0,u+                       4B07 C6   3D                 ldb    #'=  4B09 E7   C0                 stb    0,u+                       4B0B BD   4E91               jsr    GSRPORT  4B0E ED   C1                 std    0,u++  4B10 BD   4F1B               jsr    GSRDPOR  4B13 ED   C1                 std    0,u++                       4B15 C6   23                 ldb    #'#  4B17 E7   C0                 stb    0,u+                       4B19 31   C4                 leay   0,u  4B1B BD   4EAF               jsr    GSRDHAR  4B1E 33   46                 leau   6,u                       4B20 C6   23                 ldb    #'#  4B22 E7   C0                 stb    0,u+                       4B24 31   C4                 leay   0,u  4B26 BD   4EED               jsr    GSRDIP  4B29 33   44                 leau   4,u                       4B2B C6   3D                 ldb    #'=  4B2D E7   C0                 stb    0,u+                       4B2F BD   4F39               jsr    GSRMSS  4B32 ED   C1                 std    0,u++  4B34 BD   501B               jsr    GSRRXRS  4B37 ED   C1                 std    0,u++  4B39 BD   5032               jsr    GSRRXRP  4B3C ED   C1                 std    0,u++  4B3E BD   5050               jsr    GSRRXWP  4B41 ED   C1                 std    0,u++  4B43 BD   5085               jsr    GSRFRAG  4B46 ED   C1                 std    0,u++                       4B48 C6   23                 ldb    #'#  4B4A E7   C4                 stb    0,u  4B4C 4F                      clra                     FIO Simulation Structure             13:54:33  Jan 06, 2024   Page   72wz socket interface routines                          4B4D 39                      rts                                                               * X hold the task table                     * U holds the sock address  4B4E               skintrp  4B4E               skdisc  4B4E               sksmac  4B4E               skskep  4B4E 86   FF                 lda    #255  4B50 A7   47                 sta    wzerr,u  4B52 C6   C0                 ldb    #E_SOCKET  4B54 39                      rts                                    4B55  oldorg    set    *                     *                     * hardware register orgaization                     *               8080  SPIBASE   equ    $8080     hardware base address                       0000                         org    0                     *  0000               spicmd    rmb    1         HW control register               0000  spista    equ    spicmd    HW status register  0001               spicon    rmb    1         [W]   HW aux control register  0002                         rmb    2         dummy not used                     * shift register access  0004               hibyta    rmb    1         [R/W] hibyte auto 8 clock pulses for SR  0005               lobyta    rmb    1         [R/W] lobyte auto 8 clock pulses for SR  0006               hibyts    rmb    1         [R/W] hibyte static (no clock)  0007               lobyts    rmb    1         [R/W] lobyte static (no clock)                     *               0080  QFF1      equ    %10000000 [R]                          X               0040  SPI_CS_   equ    %01000000 [R/W] spi chip CS_           1               0020  SPI_RST   equ    %00100000 [R/W] spi chip RST_          1               0010  SPI_IEN   equ    %00010000 [R/W] spi chip INT enabled   0               0008  SPI_AUT   equ    %00001000 [R/W] auto advance           0               0004  SPI_SR_   equ    %00000100 [R/W] shift register MR_     1               0002  SPI_HLD   equ    %00000010 [R/W] HOLD                   0               0001  SPI_CR_   equ    %00000001 [W]   HC163 MR_              1               0001  SPI_IRQ   equ    %00000001 [R]   /IRQ bit               1                     *               0003  RSVREG    equ    %00000011 reserved register address                       4B55                         org    oldorg                                          *                     * spinit, init the SPI hardware                     *               4B55  spinit    equ    *  4B55 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_ set idle  4B57 B7   8080               sta    SPIBASE+spicmdFIO Simulation Structure             13:54:34  Jan 06, 2024   Page   73wzspi, basic spi routines                             4B5A 39                      rts                                          *                     * setup inital port for SPI access                     *                     * A,B are lost A=rwflag, F=register, X=offset                     * F=corrected register bits [7...3]                     * A= R/W flag 1=write/ 0= read                     * X,Y untouched                     *               4B5B  spistr2   equ    *  4B5B CE   8080               ldu    #SPIBASE  SPI base TODO  4B5E                         trfr   F,B  4B5E 1F                      fcb    $1f  4B5F F9                      fcb    F<<4|B                               endm  4B60 5D                      tstb             register pointer  4B61 27   09                 beq    01f       OK, valid  4B63 34   04                 pshs   b  4B65 C4   03                 andb   #RSVREG   reserved loctation  4B67 5D                      tstb             xxx10xxx  is invalid!  4B68 35   04                 puls   b  4B6A 27   1A                 beq    09f       invalid access                     * adjust READ/WRITE bit  4B6C 4D            01        tsta             cmd flag  4B6D 27   04                 beq    04f  4B6F 1A   01                 sec              write   100  4B71 20   02                 bra    05f  4B73 1C   FE       04        clc              read    000                     *  4B75 59            05        rolb             set READ/WRITE bit  [2...0]  4B76 58                      lslb             set variable length data [00]  4B77 58                      lslb                     *                     * here the actual SPI action starts                     *  4B78                         seti   disable   interrupts  4B78 1A   50                 orcc   #FF|IF                               endm  4B7A 12                      nop                     *       lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT+SPI_IEN low  4B7B 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT low  4B7D A7   C4                 sta    spicmd,u  4B7F AF   44                 stx    hibyta,u  and shift out  4B81 E7   44                 stb    hibyta,u  and shift out  4B83 1A   04                 sez  4B85 39                      rts  4B86 1C   FB       09        clz  4B88 39                      rts                                          *                     * X = offset, unchangedFIO Simulation Structure             13:54:34  Jan 06, 2024   Page   74wzspi, basic spi routines                                                * F = register#                     * read BYTE from SPI                     * return B=value, D,X,Y,U preserved                     *               4B89  byterd    equ    *  4B89 34   47                 pshs   cc,d,u  4B8B 4F                      clra  4B8C 8D   CD                 bsr    spistr2 >4B8E 1026 007E               lbne   09f  4B92 E6   44                 ldb    hibyta,u  extra clocks for first data                     *  4B94 E6   45                 ldb    lobyta,u  read byte  4B96 4F                      clra  4B97 ED   61                 std    1,s  4B99 20   69                 bra    sprend                                          *                     * X = offset                     * F = register#                     * read WORD from SPI                     * return D=value,  D,X,Y,U preserved                     *               4B9B  wordrd    equ    *  4B9B 34   47                 pshs   cc,d,u  4B9D 4F                      clra >4B9E BD   4B5B               jsr    spistr2  4BA1 26   6D                 bne    09f  4BA3 E6   44                 ldb    hibyta,u  extra clocks for first data                     *  4BA5 A6   45                 lda    lobyta,u  read byte  4BA7 E6   45                 ldb    lobyta,u  read byte  4BA9 ED   61                 std    1,s  4BAB 20   57                 bra    sprend                                          *                     * Y=mem pointer, D=count (bytes)                     * F = register#                     * read bytes from SPI into memory location                     * return D,X,Y,U preserved                     *               4BAD  bmread    equ    *  4BAD 34   77                 pshs   cc,d,x,y,u  4BAF 4F                      clra  4BB0 BD   5032               jsr    GSRRXRP  4BB3 1F   01                 tfr    d,x  4BB5 CE   8080               ldu    #SPIBASE  4BB8 34   40                 pshs   u  4BBA 1A   50                 orcc   #$50  4BBC 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT  4BBE A7   C4                 sta    spicmd,u  4BC0 AF   44                 stx    hibyta,u  start address  4BC2 BD   50DC               jsr    tsk2rxFIO Simulation Structure             13:54:34  Jan 06, 2024   Page   75wzspi, basic spi routines                             4BC5 E7   44                 stb    hibyta,u  4BC7 EC   63                 ldd    3,s       old D  4BC9                         trfr   D,W       count  4BC9 1F                      fcb    $1f  4BCA 06                      fcb    D<<4|W                               endm  4BCB 1F   12                 tfr    x,y       mem pointer  4BCD 10AE 67                 ldy    7,s       old Y  4BD0 E7   44                 stb    hibyta,u  shift out  4BD2 33   45                 leau   lobyta,u  4BD4                         tfm4   U,Y  4BD4 113B                    fdb    $113b  4BD6 32                      fcb    U<<4|Y                               endm  4BD7 35   40                 puls   u         old U  4BD9 86   25                 lda    #SPI_RST+SPI_SR_+SPI_CR_  4BDB A7   C4                 sta    spicmd,u                     * X = old read pointer, 0,s byte wount  4BDD 1F   10                 tfr    x,d  4BDF E3   61                 addd   1,s       move pointer  4BE1 BD   5041               jsr    PSRRXRP   update pointer  4BE4 35   F7                 puls   cc,d,x,y,u,pc                                          *                     * X = offset                     * F = register#                     * write BYTE to SPI, D,X,Y,U preserved                     *               4BE6  bytewr    equ    *  4BE6 34   47                 pshs   cc,d,u  4BE8 86   01                 lda    #1  4BEA BD   4B5B               jsr    spistr2  4BED 26   21                 bne    09f                     *  4BEF A6   62                 lda    2,s  4BF1 A7   44                 sta    hibyta,u  4BF3 20   0F                 bra    sprend                                          *                     * X = offset                     * F = register#                     * write WORD to SPI, D,X,Y,U preserved                     *               4BF5  wordwr    equ    *  4BF5 34   47                 pshs   cc,d,u  4BF7 86   01                 lda    #1  4BF9 BD   4B5B               jsr    spistr2  4BFC 26   12                 bne    09f                     *  4BFE EC   61                 ldd    1,s  4C00 A7   44                 sta    hibyta,u  4C02 E7   44                 stb    hibyta,uFIO Simulation Structure             13:54:34  Jan 06, 2024   Page   76wzspi, basic spi routines                                                *                     * common exit from SPI action                     *  4C04 86   65       sprend    lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_                     *sprend  lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_+SPI_IEN  4C06 A7   C4                 sta    spicmd,u  4C08 A6   E4                 lda    0,s       sez  4C0A 8A   04                 ora    #4  4C0C A7   E4       02        sta    0,s  4C0E 35   C7                 puls   cc,d,u,pc                     *  4C10 A6   E4       09        lda    0,s       clz  4C12 84   FB                 anda   #255-4  4C14 20   F6                 bra    02b                     FIO Simulation Structure             13:54:35  Jan 06, 2024   Page   77wzspi, basic spi routines                                                                     * register names and offset               0000  WZMR      equ    0               0001  WZGAR0    equ    1               0002  WZGAR1    equ    2               0003  WZGAR2    equ    3               0004  WZGAR3    equ    4               0005  WZSUBR0   equ    5               0006  WZSUBR1   equ    6               0007  WZSUBR2   equ    7               0008  WZSUBR3   equ    8               0009  WZSHAR0   equ    9               000A  WZSHAR1   equ    10               000B  WZSHAR2   equ    11               000C  WZSHAR3   equ    12               000D  WZSHAR4   equ    13               000E  WZSHAR5   equ    14               000F  WZSIPR0   equ    15               0010  WZSIPR1   equ    16               0011  WZSIPR2   equ    17               0012  WZSIPR3   equ    18               0013  WZILLT0   equ    19               0014  WZILLT1   equ    20               0015  WZIR      equ    21               0016  WZIMR     equ    22               0017  WZSIR     equ    23               0018  WZSIMR    equ    24               0019  WZRTR0    equ    25               001A  WZRTR1    equ    26               001B  WZRCR     equ    27               0028  WZUIPR0   equ    40               0029  WZUIPR1   equ    41               002A  WZUIPR2   equ    42               002B  WZUIPR3   equ    43               002C  WZUPRT0   equ    44               002D  WZUPRT1   equ    45               002E  WZPHY     equ    46               0039  WZVERS    equ    57                                          *                     * all commands to access common register set                     *                                          *                     * GCRMR, get byte from common registers mode register                     * return byte in B                     *  4C16 34   56       GCRMR     pshs   d,x,u  4C18 5F                      clrb  4C19                         trfr   B,F  4C19 1F                      fcb    $1f  4C1A 9F                      fcb    B<<4|FFIO Simulation Structure             13:54:35  Jan 06, 2024   Page   78wzspi, basic spi routines                                                          endm  4C1B 8E   0000               ldx    #WZMR  4C1E BD   4B89               jsr    byterd  4C21 ED   E4                 std    0,s  4C23 35   D6                 puls   d,x,u,pc                                          *                     * PCRMR, put byte B into common registers mode register                     *  4C25 34   16       PCRMR     pshs   d,x  4C27 5F                      clrb  4C28                         trfr   B,F  4C28 1F                      fcb    $1f  4C29 9F                      fcb    B<<4|F                               endm  4C2A 8E   0000               ldx    #WZMR  4C2D EC   E4                 ldd    0,s >4C2F BD   4BE6               jsr    bytewr  4C32 35   96                 puls   d,x,pc                                          *                     * GCRGA, get gateway address from common regsiters                     * Y=destination address (4 bytes)                     *  4C34 34   16       GCRGA     pshs   d,x  4C36 5F                      clrb  4C37                         trfr   B,F  4C37 1F                      fcb    $1f  4C38 9F                      fcb    B<<4|F                               endm  4C39 8E   0001               ldx    #WZGAR0  4C3C BD   4B9B               jsr    wordrd  4C3F ED   A4                 std    0,y  4C41 8E   0003               ldx    #WZGAR2  4C44 BD   4B9B               jsr    wordrd  4C47 ED   22                 std    2,y  4C49 35   96                 puls   d,x,pc                                          *                     * PCRGW, put gateway address                     * Y=source address (4 bytes)                     *  4C4B 34   16       PCRGA     pshs   d,x  4C4D 5F                      clrb  4C4E                         trfr   B,F  4C4E 1F                      fcb    $1f  4C4F 9F                      fcb    B<<4|F                               endm  4C50 8E   0001               ldx    #WZGAR0  4C53 EC   A4                 ldd    0,y >4C55 BD   4BF5               jsr    wordwr  4C58 8E   0003               ldx    #WZGAR2FIO Simulation Structure             13:54:35  Jan 06, 2024   Page   79wzspi, basic spi routines                             4C5B EC   22                 ldd    2,y >4C5D BD   4BF5               jsr    wordwr  4C60 35   96                 puls   d,x,pc                                          *                     * GCRSNM, get subnet mask  from common regsiters                     * Y=destination address (4 bytes)                     *  4C62 34   16       GCRSNM    pshs   d,x  4C64 5F                      clrb  4C65                         trfr   B,F  4C65 1F                      fcb    $1f  4C66 9F                      fcb    B<<4|F                               endm  4C67 8E   0005               ldx    #WZSUBR0  4C6A BD   4B9B               jsr    wordrd  4C6D ED   A4                 std    0,y  4C6F 8E   0007               ldx    #WZSUBR2  4C72 BD   4B9B               jsr    wordrd  4C75 ED   22                 std    2,y  4C77 35   96                 puls   d,x,pc                                          *                     * PCRSNM, put subnet mask address                     * Y=source address (4 bytes)                     *  4C79 34   16       PCRSNM    pshs   d,x  4C7B 5F                      clrb  4C7C                         trfr   B,F  4C7C 1F                      fcb    $1f  4C7D 9F                      fcb    B<<4|F                               endm  4C7E 8E   0005               ldx    #WZSUBR0  4C81 EC   A4                 ldd    0,y  4C83 BD   4BF5               jsr    wordwr  4C86 8E   0007               ldx    #WZSUBR2  4C89 EC   22                 ldd    2,y  4C8B BD   4BF5               jsr    wordwr  4C8E 35   96                 puls   d,x,pc                                          *                     * GCRSHA, get gateway hardware address from common regsiters                     * Y=destination address (6 bytes)                     *  4C90 34   16       GCRSHA    pshs   d,x  4C92 5F                      clrb  4C93                         trfr   B,F  4C93 1F                      fcb    $1f  4C94 9F                      fcb    B<<4|F                               endm  4C95 8E   0009               ldx    #WZSHAR0  4C98 BD   4B9B               jsr    wordrdFIO Simulation Structure             13:54:36  Jan 06, 2024   Page   80wzspi, basic spi routines                             4C9B ED   A4                 std    0,y  4C9D 8E   000B               ldx    #WZSHAR2  4CA0 BD   4B9B               jsr    wordrd  4CA3 ED   22                 std    2,y  4CA5 8E   000D               ldx    #WZSHAR4  4CA8 BD   4B9B               jsr    wordrd  4CAB ED   24                 std    4,y  4CAD 35   96                 puls   d,x,pc                                          *                     * PCRSHA, put gateway hardware address                     * Y=source address (6 bytes)                     *  4CAF 34   16       PCRSHA    pshs   d,x  4CB1 5F                      clrb  4CB2                         trfr   B,F  4CB2 1F                      fcb    $1f  4CB3 9F                      fcb    B<<4|F                               endm  4CB4 8E   0009               ldx    #WZSHAR0  4CB7 EC   A4                 ldd    0,y  4CB9 BD   4BF5               jsr    wordwr  4CBC 8E   000B               ldx    #WZSHAR2  4CBF EC   22                 ldd    2,y  4CC1 BD   4BF5               jsr    wordwr  4CC4 8E   000D               ldx    #WZSHAR4  4CC7 EC   24                 ldd    4,y  4CC9 BD   4BF5               jsr    wordwr  4CCC 35   96                 puls   d,x,pc                                          *                     * GCRSIP, get source IP address from common regsiters                     * Y=destination address (4 bytes)                     *  4CCE 34   16       GCRSIP    pshs   d,x  4CD0 5F                      clrb  4CD1                         trfr   B,F  4CD1 1F                      fcb    $1f  4CD2 9F                      fcb    B<<4|F                               endm  4CD3 8E   000F               ldx    #WZSIPR0  4CD6 BD   4B9B               jsr    wordrd  4CD9 ED   A4                 std    0,y  4CDB 8E   0011               ldx    #WZSIPR2  4CDE BD   4B9B               jsr    wordrd  4CE1 ED   22                 std    2,y  4CE3 35   96                 puls   d,x,pc                                          *                     * PCRSIP, put gateway address                     * Y=source address (4 bytes)                     *FIO Simulation Structure             13:54:36  Jan 06, 2024   Page   81wzspi, basic spi routines                             4CE5 34   16       PCRSIP    pshs   d,x  4CE7 5F                      clrb  4CE8                         trfr   B,F  4CE8 1F                      fcb    $1f  4CE9 9F                      fcb    B<<4|F                               endm  4CEA 8E   000F               ldx    #WZSIPR0  4CED EC   A4                 ldd    0,y  4CEF BD   4BF5               jsr    wordwr  4CF2 8E   0011               ldx    #WZSIPR2  4CF5 EC   22                 ldd    2,y  4CF7 BD   4BF5               jsr    wordwr  4CFA 35   96                 puls   d,x,pc                                          *                     * GCRILLT, get byte from interrup low level timer register                     * return word in D                     *  4CFC 34   16       GCRILLT   pshs   d,x  4CFE 5F                      clrb  4CFF                         trfr   B,F  4CFF 1F                      fcb    $1f  4D00 9F                      fcb    B<<4|F                               endm  4D01 8E   0013               ldx    #WZILLT0  4D04 BD   4B9B               jsr    wordrd  4D07 ED   E4                 std    0,s  4D09 35   96                 puls   d,x,pc                                          *                     * PCRILLT, put word D into common registers mode register                     *  4D0B 34   16       PCRILLT   pshs   d,x  4D0D 5F                      clrb  4D0E                         trfr   B,F  4D0E 1F                      fcb    $1f  4D0F 9F                      fcb    B<<4|F                               endm  4D10 8E   0013               ldx    #WZILLT0  4D13 EC   E4                 ldd    0,s  4D15 BD   4BF5               jsr    wordwr  4D18 35   96                 puls   d,x,pc                                          *                     * GCRIR, get byte from common registers interrupt register                     * return byte in B                     *  4D1A 34   16       GCRIR     pshs   d,x  4D1C 5F                      clrb  4D1D                         trfr   B,F  4D1D 1F                      fcb    $1f  4D1E 9F                      fcb    B<<4|FFIO Simulation Structure             13:54:36  Jan 06, 2024   Page   82wzspi, basic spi routines                                                          endm  4D1F 8E   0015               ldx    #WZIR  4D22 BD   4B89               jsr    byterd  4D25 ED   E4                 std    0,s  4D27 35   96                 puls   d,x,pc                                          *                     * PCRIR, put byte B into common registers interrupt register                     *  4D29 34   16       PCRIR     pshs   d,x  4D2B 5F                      clrb  4D2C                         trfr   B,F  4D2C 1F                      fcb    $1f  4D2D 9F                      fcb    B<<4|F                               endm  4D2E 8E   0015               ldx    #WZIR  4D31 EC   E4                 ldd    0,s  4D33 BD   4BE6               jsr    bytewr  4D36 35   96                 puls   d,x,pc                                          *                     * GCRIMR, get byte from common registers interrupt mask register                     * return byte in B                     *  4D38 34   16       GCRIMR    pshs   d,x  4D3A 5F                      clrb  4D3B                         trfr   B,F  4D3B 1F                      fcb    $1f  4D3C 9F                      fcb    B<<4|F                               endm  4D3D 8E   0016               ldx    #WZIMR  4D40 BD   4B89               jsr    byterd  4D43 ED   E4                 std    0,s  4D45 35   96                 puls   d,x,pc                                          *                     * PCRIMR, put byte B into common registers interrupt mask register                     *  4D47 34   16       PCRIMR    pshs   d,x  4D49 5F                      clrb  4D4A                         trfr   B,F  4D4A 1F                      fcb    $1f  4D4B 9F                      fcb    B<<4|F                               endm  4D4C 8E   0016               ldx    #WZIMR  4D4F EC   E4                 ldd    0,s  4D51 BD   4BE6               jsr    bytewr  4D54 35   96                 puls   d,x,pc                                          *                     * GCRSIR, get byte from common registers socket interrupt register                     * return byte in BFIO Simulation Structure             13:54:36  Jan 06, 2024   Page   83wzspi, basic spi routines                                                *  4D56 34   16       GCRSIR    pshs   d,x  4D58 5F                      clrb  4D59                         trfr   B,F  4D59 1F                      fcb    $1f  4D5A 9F                      fcb    B<<4|F                               endm  4D5B 8E   0017               ldx    #WZSIR  4D5E BD   4B89               jsr    byterd  4D61 ED   E4                 std    0,s  4D63 35   96                 puls   d,x,pc                                          *                     * PCRSIR, put byte B into common registers socket interrupt register                     *  4D65 34   16       PCRSIR    pshs   d,x  4D67 5F                      clrb  4D68                         trfr   B,F  4D68 1F                      fcb    $1f  4D69 9F                      fcb    B<<4|F                               endm  4D6A 8E   0017               ldx    #WZSIR  4D6D EC   E4                 ldd    0,s  4D6F BD   4BE6               jsr    bytewr  4D72 35   96                 puls   d,x,pc                                          *                     * GCSIMR, get byte from common registers socket interrupt mask register                     * return byte in B                     *  4D74 34   16       GCRSIMR   pshs   d,x  4D76 5F                      clrb  4D77                         trfr   B,F  4D77 1F                      fcb    $1f  4D78 9F                      fcb    B<<4|F                               endm  4D79 8E   0018               ldx    #WZSIMR  4D7C BD   4B89               jsr    byterd  4D7F ED   E4                 std    0,s  4D81 35   96                 puls   d,x,pc                                          *                     * PCRSIMR, put byte B into common registers socket interrupt mask register                     *  4D83 34   16       PCRSIMR   pshs   d,x  4D85 5F                      clrb  4D86                         trfr   B,F  4D86 1F                      fcb    $1f  4D87 9F                      fcb    B<<4|F                               endm  4D88 8E   0018               ldx    #WZSIMR  4D8B EC   E4                 ldd    0,sFIO Simulation Structure             13:54:37  Jan 06, 2024   Page   84wzspi, basic spi routines                             4D8D BD   4BE6               jsr    bytewr  4D90 35   96                 puls   d,x,pc                                          *                     * GCRRTR, get word from common registers retry register                     * return word in D                     *  4D92 34   16       GCRRTR    pshs   d,x  4D94 5F                      clrb  4D95                         trfr   B,F  4D95 1F                      fcb    $1f  4D96 9F                      fcb    B<<4|F                               endm  4D97 8E   0019               ldx    #WZRTR0  4D9A BD   4B9B               jsr    wordrd  4D9D ED   E4                 std    0,s  4D9F 35   96                 puls   d,x,pc                                          *                     * PCRRTR, put word D into common registers retry register                     *  4DA1 34   16       PCRRTR    pshs   d,x  4DA3 5F                      clrb  4DA4                         trfr   B,F  4DA4 1F                      fcb    $1f  4DA5 9F                      fcb    B<<4|F                               endm  4DA6 8E   0019               ldx    #WZRTR0  4DA9 EC   E4                 ldd    0,s  4DAB BD   4BF5               jsr    wordwr  4DAE 35   96                 puls   d,x,pc                                          *                     * GCRRCR, get byte from common registers retry count register                     * return byte in B                     *  4DB0 34   16       GCRRCR    pshs   d,x  4DB2 5F                      clrb  4DB3                         trfr   B,F  4DB3 1F                      fcb    $1f  4DB4 9F                      fcb    B<<4|F                               endm  4DB5 8E   001B               ldx    #WZRCR  4DB8 BD   4B89               jsr    byterd  4DBB ED   E4                 std    0,s  4DBD 35   96                 puls   d,x,pc                                          *                     * PCRRCR, put byte B into common registers retry count register                     *  4DBF 34   16       PCRRCR    pshs   d,x  4DC1 5F                      clrbFIO Simulation Structure             13:54:37  Jan 06, 2024   Page   85wzspi, basic spi routines                             4DC2                         trfr   B,F  4DC2 1F                      fcb    $1f  4DC3 9F                      fcb    B<<4|F                               endm  4DC4 8E   001B               ldx    #WZRCR  4DC7 EC   E4                 ldd    0,s  4DC9 BD   4BE6               jsr    bytewr  4DCC 35   96                 puls   d,x,pc                                          *                     * GCRURP, get word from common registers unreachable port register                     * return word in D                     *  4DCE 34   16       GCRURP    pshs   d,x  4DD0 5F                      clrb  4DD1                         trfr   B,F  4DD1 1F                      fcb    $1f  4DD2 9F                      fcb    B<<4|F                               endm  4DD3 8E   002C               ldx    #WZUPRT0  4DD6 BD   4B9B               jsr    wordrd  4DD9 ED   E4                 std    0,s  4DDB 35   96                 puls   d,x,pc                                          *                     * GCRUIP, get unreachable IP address from common registers                     * Y=destination address (4 bytes)                     *  4DDD 34   16       GCRUIP    pshs   d,x  4DDF 5F                      clrb  4DE0                         trfr   B,F  4DE0 1F                      fcb    $1f  4DE1 9F                      fcb    B<<4|F                               endm  4DE2 8E   0028               ldx    #WZUIPR0  4DE5 BD   4B9B               jsr    wordrd  4DE8 ED   A4                 std    0,y  4DEA 8E   002A               ldx    #WZUIPR2  4DED BD   4B9B               jsr    wordrd  4DF0 ED   22                 std    2,y  4DF2 35   96                 puls   d,x,pc                                          *                     * GCRPHY, get byte from common registers PHY config register                     * return byte in B                     *  4DF4 34   56       GCRPHY    pshs   d,x,u  4DF6 8E   002E               ldx    #WZPHY  4DF9 5F                      clrb  4DFA                         trfr   B,F  4DFA 1F                      fcb    $1f  4DFB 9F                      fcb    B<<4|FFIO Simulation Structure             13:54:37  Jan 06, 2024   Page   86wzspi, basic spi routines                                                          endm  4DFC BD   4B89               jsr    byterd  4DFF ED   E4                 std    0,s  4E01 35   D6                 puls   d,x,u,pc                                          *                     * PCRPHY, put byte B into common registers PHY config register                     *  4E03 34   56       PCRPHY    pshs   d,x,u  4E05 8E   002E               ldx    #WZPHY  4E08 5F                      clrb  4E09                         trfr   B,F  4E09 1F                      fcb    $1f  4E0A 9F                      fcb    B<<4|F                               endm  4E0B EC   E4                 ldd    0,s  4E0D BD   4BE6               jsr    bytewr  4E10 35   D6                 puls   d,x,u,pc                                          *                     * GCRVERS, get byte from common registers socket version register                     * return byte in B                     *  4E12 34   56       GCRVERS   pshs   d,x,u  4E14 8E   0039               ldx    #WZVERS  4E17 5F                      clrb  4E18                         trfr   B,F  4E18 1F                      fcb    $1f  4E19 9F                      fcb    B<<4|F                               endm  4E1A BD   4B89               jsr    byterd  4E1D ED   E4                 std    0,s  4E1F 35   D6                 puls   d,x,u,pc                     *                     * all functions to access socket registers                     *                                          * socket register names and offsets               0000  SNMR      equ    0               0001  SNCR      equ    1               0002  SNIR      equ    2               0003  SNSR      equ    3               0004  SNPORT0   equ    4               0005  SNPORT1   equ    5               0006  SNDHAR0   equ    6               0007  SNDHAR1   equ    7               0008  SNDHAR2   equ    8               0009  SNDHAR3   equ    9               000A  SNDHAR4   equ    10               000B  SNDHAR5   equ    11               000C  SNDIPR0   equ    12               000D  SNDIPR1   equ    13FIO Simulation Structure             13:54:38  Jan 06, 2024   Page   87wzspi, basic spi routines                                          000E  SNDIPR2   equ    14               000F  SNDIPR3   equ    15               0010  SNDPOR0   equ    16               0011  SNDPOR1   equ    17               0012  SNMSSR0   equ    18               0013  SNMSSR1   equ    19               0015  SNTOS     equ    21               0016  SNTTL     equ    22               001E  SNRBFSZ   equ    30               001F  SNTBFSZ   equ    31               0020  SNTXFR0   equ    32               0021  SNTXFR1   equ    33               0022  SNTXRP0   equ    34               0023  SNTXRP1   equ    35               0024  SNTXWP0   equ    36               0025  SNTXWP1   equ    37               0026  SNRXRZ0   equ    38               0027  SNRXRZ1   equ    39               0028  SNRXRP0   equ    40               0029  SNRXRP1   equ    41               002A  SNRXWP0   equ    42               002B  SNRXWP1   equ    43               002C  SNIMR     equ    44               002D  SNFRAG0   equ    45               002E  SNFRAG1   equ    46               002F  SNKATIM   equ    47                                                               *                     * all commands to access socket register set                     *                                                               *                     * GSRMR, get byte from socket registers mode register                     * E=socket#                     * return byte in B                     *  4E21 34   16       GSRMR     psh    d,x  4E23 BD   50C1               jsr    tsk2rg  4E26 8E   0000               ldx    #SNMR  4E29 BD   4B89               jsr    byterd  4E2C ED   E4                 std    0,s  4E2E 35   96                 puls   d,x,pc                                          *                     * PSRMR, put byte B  to socket registers mode register                     * E=socket#                     *  4E30 34   16       PSRMR     pshs   d,x  4E32 BD   50C1               jsr    tsk2rg  4E35 8E   0000               ldx    #SNMRFIO Simulation Structure             13:54:38  Jan 06, 2024   Page   88wzspi, basic spi routines                             4E38 EC   E4                 ldd    0,s  4E3A BD   4BE6               jsr    bytewr  4E3D 35   96                 puls   d,x,pc                                          *                     * GSRCR, get bytefrom socket registers command register                     * E=socket#                     * return byte in B                     *  4E3F 34   16       GSRCR     pshs   d,x  4E41 BD   50C1               jsr    tsk2rg  4E44 8E   0001               ldx    #SNCR  4E47 BD   4B89               jsr    byterd  4E4A ED   E4                 std    0,s  4E4C 35   96                 puls   d,x,pc                                          *                     * PSRCR, put byte B in socket registers command register                     * E=socket#                     *  4E4E 34   16       PSRCR     pshs   d,x  4E50 BD   50C1               jsr    tsk2rg  4E53 8E   0001               ldx    #SNCR  4E56 EC   E4                 ldd    0,s  4E58 BD   4BE6               jsr    bytewr  4E5B 8D   E2       01        bsr    GSRCR  4E5D 5D                      tstb  4E5E 26   FB                 bne    01b       wait command to be consumed  4E60 E7   61                 stb    1,s       set return  4E62 35   96                 puls   d,x,pc                                          *                     * GSRIR, get bytefrom socket registers interrupt register                     * E=socket#                     * return byte in B                     *  4E64 34   16       GSRIR     pshs   d,x  4E66 BD   50C1               jsr    tsk2rg  4E69 8E   0002               ldx    #SNIR  4E6C BD   4B89               jsr    byterd  4E6F ED   E4                 std    0,s  4E71 35   96                 puls   d,x,pc                                          *                     * PSRIR, put byte B in socket registers interrupt register                     * E=socket#                     *  4E73 34   16       PSRIR     pshs   d,x  4E75 BD   50C1               jsr    tsk2rg  4E78 8E   0002               ldx    #SNIR  4E7B EC   E4                 ldd    0,s  4E7D BD   4BE6               jsr    bytewrFIO Simulation Structure             13:54:38  Jan 06, 2024   Page   89wzspi, basic spi routines                             4E80 35   96                 puls   d,x,pc                                          *                     * GSRSR, get bytefrom socket registers status register                     * E=socket#                     * return byte in B                     *  4E82 34   16       GSRSR     pshs   d,x  4E84 BD   50C1               jsr    tsk2rg  4E87 8E   0003               ldx    #SNSR  4E8A BD   4B89               jsr    byterd  4E8D ED   E4                 std    0,s  4E8F 35   96                 puls   d,x,pc                                          *                     * GSRPORT, get word from socket registers source port                     * E=socket#                     * return word in D                     *  4E91 34   16       GSRPORT   pshs   d,x  4E93 BD   50C1               jsr    tsk2rg  4E96 8E   0004               ldx    #SNPORT0  4E99 BD   4B9B               jsr    wordrd  4E9C ED   E4                 std    0,s  4E9E 35   96                 pul    d,x,pc                                          *                     * PSRPORT, put word D  into socket registers source port                     * E=socket#                     *  4EA0 34   16       PSRPORT   pshs   d,x  4EA2 BD   50C1               jsr    tsk2rg  4EA5 8E   0004               ldx    #SNPORT0  4EA8 EC   E4                 ldd    0,s  4EAA BD   4BF5               jsr    wordwr  4EAD 35   96                 puls   d,x,pc                                          *                     * GSRDHAR, get destination hardware address into [Y]                     * F=sockt#, Y=destination                     *  4EAF 34   16       GSRDHAR   pshs   d,x  4EB1 BD   50C1               jsr    tsk2rg  4EB4 8E   0006               ldx    #SNDHAR0  4EB7 BD   4B9B               jsr    wordrd  4EBA ED   A4                 std    0,y  4EBC 8E   0008               ldx    #SNDHAR2  4EBF BD   4B9B               jsr    wordrd  4EC2 ED   22                 std    2,y  4EC4 8E   000A               ldx    #SNDHAR4  4EC7 BD   4B9B               jsr    wordrd  4ECA ED   24                 std    4,yFIO Simulation Structure             13:54:39  Jan 06, 2024   Page   90wzspi, basic spi routines                             4ECC 35   96                 puls   d,x,pc                                          *                     * PSRDHAR, put [Y] into destination hardware address                     * F=sockt#, Y=destination                     *  4ECE 34   16       PSRDHAR   pshs   d,x  4ED0 BD   50C1               jsr    tsk2rg  4ED3 8E   0006               ldx    #SNDHAR0  4ED6 EC   A4                 ldd    0,y  4ED8 BD   4BF5               jsr    wordwr  4EDB 8E   0008               ldx    #SNDHAR2  4EDE EC   22                 ldd    2,y  4EE0 BD   4BF5               jsr    wordwr  4EE3 8E   000A               ldx    #SNDHAR4  4EE6 EC   24                 ldd    4,y  4EE8 BD   4BF5               jsr    wordwr  4EEB 35   96                 puls   d,x,pc                                          *                     * GSRDIP. get destination IP address into [Y]                     * E=socket#                     *  4EED 34   16       GSRDIP    pshs   d,x  4EEF BD   50C1               jsr    tsk2rg  4EF2 8E   000C               ldx    #SNDIPR0  4EF5 BD   4B9B               jsr    wordrd  4EF8 ED   A4                 std    0,y  4EFA 8E   000E               ldx    #SNDIPR2  4EFD BD   4B9B               jsr    wordrd  4F00 ED   22                 std    2,y  4F02 35   96                 puls   d,x,pc                                          *                     * PSRDIP. put destination IP address into [Y]                     * E=socket#                     *  4F04 34   16       PSRDIP    pshs   d,x  4F06 BD   50C1               jsr    tsk2rg  4F09 8E   000C               ldx    #SNDIPR0  4F0C EC   A4                 ldd    0,y  4F0E BD   4BF5               jsr    wordwr  4F11 8E   000E               ldx    #SNDIPR2  4F14 EC   22                 ldd    2,y  4F16 BD   4BF5               jsr    wordwr  4F19 35   96                 puls   d,x,pc                                          *                     * GSRDPOR, get word from socket registers destination port                     * E=socket#                     * return word in D                     *FIO Simulation Structure             13:54:39  Jan 06, 2024   Page   91wzspi, basic spi routines                             4F1B 34   16       GSRDPOR   pshs   d,x  4F1D BD   50C1               jsr    tsk2rg  4F20 8E   0010               ldx    #SNDPOR0  4F23 BD   4B9B               jsr    wordrd  4F26 ED   E4                 std    0,s  4F28 35   96                 pul    d,x,pc                                          *                     * PSRDPOR, put word D  into socket registers source port                     * E=socket#                     *  4F2A 34   16       PSRDPOR   pshs   d,x  4F2C BD   50C1               jsr    tsk2rg  4F2F 8E   0010               ldx    #SNDPOR0  4F32 EC   E4                 ldd    0,s  4F34 BD   4BF5               jsr    wordwr  4F37 35   96                 puls   d,x,pc                                          *                     * GSRMSS, get word from socket registers max segment size                     * E=socket#                     * return word in D                     *  4F39 34   16       GSRMSS    pshs   d,x  4F3B BD   50C1               jsr    tsk2rg  4F3E 8E   0012               ldx    #SNMSSR0  4F41 BD   4B9B               jsr    wordrd  4F44 ED   E4                 std    0,s  4F46 35   96                 pul    d,x,pc                                          *                     * PSRMSS, put word D  into socket registers maximum segment size                     * E=socket#                     *  4F48 34   16       PSRMSS    pshs   d,x  4F4A BD   50C1               jsr    tsk2rg  4F4D 8E   0012               ldx    #SNMSSR0  4F50 EC   E4                 ldd    0,s  4F52 BD   4BF5               jsr    wordwr  4F55 35   96                 puls   d,x,pc                                          *                     * GSRTOS, get byte from socket registers TOS                     * E=socket#                     * return byte in B                     *  4F57 34   16       GSRTOS    pshs   d,x  4F59 BD   50C1               jsr    tsk2rg  4F5C 8E   0015               ldx    #SNTOS  4F5F BD   4B89               jsr    byterd  4F62 ED   E4                 std    0,s  4F64 35   96                 pul    d,x,pcFIO Simulation Structure             13:54:39  Jan 06, 2024   Page   92wzspi, basic spi routines                                                                     *                     * PSRTOS, put byte B  into socket registers TOS                     * E=socket#                     *  4F66 34   16       PSRTOS    pshs   d,x  4F68 BD   50C1               jsr    tsk2rg  4F6B 8E   0015               ldx    #SNTOS  4F6E EC   E4                 ldd    0,s  4F70 BD   4BE6               jsr    bytewr  4F73 35   96                 puls   d,x,pc                                          *                     * GSRTTL, get byte from socket registers TTL                     * E=socket#                     * return byte in B                     *  4F75 34   16       GSRTTL    pshs   d,x  4F77 BD   50C1               jsr    tsk2rg  4F7A 8E   0016               ldx    #SNTTL  4F7D BD   4B89               jsr    byterd  4F80 ED   E4                 std    0,s  4F82 35   96                 pul    d,x,pc                                          *                     * PSRTTL, put byte B  into socket registers TTL                     * E=socket#                     *  4F84 34   16       PSRTTL    pshs   d,x  4F86 BD   50C1               jsr    tsk2rg  4F89 8E   0016               ldx    #SNTTL  4F8C EC   E4                 ldd    0,s  4F8E BD   4BE6               jsr    bytewr  4F91 35   96                 puls   d,x,pc                                          *                     * GSRRBFS, get byte from socket registers rec buf size                     * E=socket#                     * return byte in B                     *  4F93 34   16       GSRRBFS   pshs   d,x  4F95 BD   50C1               jsr    tsk2rg  4F98 8E   001E               ldx    #SNRBFSZ  4F9B BD   4B89               jsr    byterd  4F9E ED   E4                 std    0,s  4FA0 35   96                 pul    d,x,pc                                          *                     * PSRTBFS, put byte B  into socket registers rec buf siz                     * E=socket#                     *  4FA2 34   16       PSRRBFS   pshs   d,xFIO Simulation Structure             13:54:40  Jan 06, 2024   Page   93wzspi, basic spi routines                             4FA4 BD   50C1               jsr    tsk2rg  4FA7 8E   001E               ldx    #SNRBFSZ  4FAA EC   E4                 ldd    0,s  4FAC BD   4BE6               jsr    bytewr  4FAF 35   96                 puls   d,x,pc                                          *                     * GSRTBFS, get byte from socket registers tx buf size                     * E=socket#                     * return byte in B                     *  4FB1 34   16       GSRTBFS   pshs   d,x  4FB3 BD   50C1               jsr    tsk2rg  4FB6 8E   001F               ldx    #SNTBFSZ  4FB9 BD   4B89               jsr    byterd  4FBC ED   E4                 std    0,s  4FBE 35   96                 puls   d,x,pc                                          *                     * PSRTBFS, put byte B  into socket registers tx buf siz                     * E=socket#                     *  4FC0 34   16       PSRTBFS   pshs   d,x  4FC2 BD   50C1               jsr    tsk2rg  4FC5 8E   001F               ldx    #SNTBFSZ  4FC8 EC   E4                 ldd    0,s  4FCA BD   4BE6               jsr    bytewr  4FCD 35   96                 puls   d,x,pc                                          *                     * GSRTXFR, get word from socket registers TX free size                     * E=socket#                     * return word in D                     *  4FCF 34   16       GSRTXFR   pshs   d,x  4FD1 BD   50C1               jsr    tsk2rg  4FD4 8E   0020               ldx    #SNTXFR0  [R]  4FD7 BD   4B9B               jsr    wordrd  4FDA ED   E4       01        std    0,s  4FDC BD   4B9B               jsr    wordrd  4FDF 10A3 E4                 cmpd   0,s       read more times and exit  4FE2 26   F6                 bne    01b       when 2 reads are equal  4FE4 35   96                 puls   d,x,pc                                          *                     * GSRTXRP, get word from socket registers TX read pointer                     * E=socket#                     * return word in D                     *  4FE6 34   16       GSRTXRP   pshs   d,x  4FE8 BD   50C1               jsr    tsk2rg  4FEB 8E   0022               ldx    #SNTXRP0  [R]FIO Simulation Structure             13:54:40  Jan 06, 2024   Page   94wzspi, basic spi routines                             4FEE BD   4B9B               jsr    wordrd  4FF1 ED   E4       01        std    0,s  4FF3 BD   4B9B               jsr    wordrd  4FF6 10A3 E4                 cmpd   0,s       read more times and exit  4FF9 26   F6                 bne    01b       when 2 reads are equal  4FFB 35   96                 puls   d,x,pc                                          *                     * GSRTXWP, get word from socket registers TX write pointer                     * E=socket#                     * return word in D                     *  4FFD 34   16       GSRTXWP   pshs   d,x  4FFF BD   50C1               jsr    tsk2rg  5002 8E   0024               ldx    #SNTXWP0  [RW]  5005 BD   4B9B               jsr    wordrd  5008 ED   E4                 std    0,s  500A 35   96                 puls   d,x,pc                                          *                     * PSRTXWP, put word D into socket registers TX write pointer                     * E=socket#                     *  500C 34   16       PSRTXWP   pshs   d,x  500E BD   50C1               jsr    tsk2rg  5011 8E   0024               ldx    #SNTXWP0  5014 EC   E4                 ldd    0,s  5016 BD   4BF5               jsr    wordwr  5019 35   96                 puls   d,x,pc                                          *                     * GSRRXRS, get word from socket registers RX received size                     * E=socket#                     * return word in D                     *  501B 34   16       GSRRXRS   pshs   d,x  501D BD   50C1               jsr    tsk2rg  5020 8E   0026               ldx    #SNRXRZ0  [R]  5023 BD   4B9B               jsr    wordrd  5026 ED   E4       01        std    0,s  5028 BD   4B9B               jsr    wordrd  502B 10A3 E4                 cmpd   0,s       read more times and exit  502E 26   F6                 bne    01b       when 2 reads are equal  5030 35   96                 puls   d,x,pc                                          *                     * GSRRXRP, get word from socket registers RX read pointer                     * E=socket#                     * return word in D                     *  5032 34   16       GSRRXRP   pshs   d,x  5034 BD   50C1               jsr    tsk2rgFIO Simulation Structure             13:54:40  Jan 06, 2024   Page   95wzspi, basic spi routines                             5037 8E   0028               ldx    #SNRXRP0  [RW]  503A BD   4B9B               jsr    wordrd  503D ED   E4                 std    0,s  503F 35   96                 puls   d,x,pc                                          *                     * PSRRXRP, put word D into socket registers RX read pointer                     * E=socket#                     *  5041 34   16       PSRRXRP   pshs   d,x >5043 BD   50C1               jsr    tsk2rg  5046 8E   0028               ldx    #SNRXRP0  5049 EC   E4                 ldd    0,s  504B BD   4BF5               jsr    wordwr  504E 35   96                 puls   d,x,pc                                          *                     * GSRRXWP, get word from socket registers RX write pointer                     * E=socket#                     * return word in D                     *  5050 34   16       GSRRXWP   pshs   d,x >5052 BD   50C1               jsr    tsk2rg  5055 8E   002A               ldx    #SNRXWP0  [R]  5058 BD   4B9B               jsr    wordrd  505B ED   E4       01        std    0,s  505D BD   4B9B               jsr    wordrd  5060 10A3 E4                 cmpd   0,s       read more times and exit  5063 26   F6                 bne    01b       when 2 reads are equal  5065 35   96                 puls   d,x,pc                                          *                     * GSRIMR, get byte from socket registers interrupt mask                     * E=socket#                     * return byte in B                     *  5067 34   16       GSRIMR    pshs   d,x >5069 BD   50C1               jsr    tsk2rg  506C 8E   002C               ldx    #SNIMR  506F BD   4B89               jsr    byterd  5072 ED   E4                 std    0,s  5074 35   96                 puls   d,x,pc                                          *                     * PSRIMS, put byte B  into socket registers interrupt mask                     * E=socket#                     *  5076 34   16       PSRIMR    pshs   d,x >5078 BD   50C1               jsr    tsk2rg  507B 8E   002C               ldx    #SNIMR  507E EC   E4                 ldd    0,s  5080 BD   4BE6               jsr    bytewrFIO Simulation Structure             13:54:41  Jan 06, 2024   Page   96wzspi, basic spi routines                             5083 35   96                 puls   d,x,pc                                          *                     * GSRFRAG, get word from socket registers FRAG                     * E=socket#                     * return word in D                     *  5085 34   16       GSRFRAG   pshs   d,x >5087 BD   50C1               jsr    tsk2rg  508A 8E   002D               ldx    #SNFRAG0  508D BD   4B9B               jsr    wordrd  5090 ED   E4                 std    0,s  5092 35   96                 puls   d,x,pc                                          *                     * PSRGRAG, put word D into socket registers FRAG                     * E=socket#                     *  5094 34   16       PSRFRAG   pshs   d,x >5096 BD   50C1               jsr    tsk2rg  5099 8E   002D               ldx    #SNFRAG0  509C EC   E4                 ldd    0,s  509E BD   4BF5               jsr    wordwr  50A1 35   96                 puls   d,x,pc                                          *                     * GSRKATM, get byte from socket registers keep alive timer                     * E=socket#                     * return byte in B                     *  50A3 34   16       GSKATM    pshs   d,x >50A5 BD   50C1               jsr    tsk2rg  50A8 8E   002F               ldx    #SNKATIM  50AB BD   4B89               jsr    byterd  50AE ED   E4                 std    0,s  50B0 35   96                 puls   d,x,pc                                          *                     * PSRKATM, put byte B  into socket registers keep alive timer                     * E=socket#                     *  50B2 34   16       PSRKATM   pshs   d,x >50B4 BD   50C1               jsr    tsk2rg  50B7 8E   002F               ldx    #SNKATIM  50BA EC   E4                 ldd    0,s  50BC BD   4BE6               jsr    bytewr  50BF 35   96                 puls   d,x,pc                     *                     * data handling routines                     *                                          * translate socket register in partial addressFIO Simulation Structure             13:54:41  Jan 06, 2024   Page   97wzspi, basic spi routines                                                * prepares bits [7...5][4...3]                     * E=socket#, F=lost, B=lost               50C1  tsk2rg    equ    *  50C1                         trfr   E,B  50C1 1F                      fcb    $1f  50C2 E9                      fcb    E<<4|B                               endm  50C3 5A                      decb             wzenum= 1...8, sn= 0...7                     *  50C4 1C   FE                 clc              make reg bits + '01'  50C6 59                      rolb             socket register  50C7 1A   01                 sec  50C9 59                      rolb             xxx 01 ...                     *  50CA                         trfr   B,F  50CA 1F                      fcb    $1f  50CB 9F                      fcb    B<<4|F                               endm  50CC 39                      rts                                          *                     * translate socket register in final address (data xfer)                     * prepares bit [7...0]                     *               50CD  tsk2tx    equ    *  50CD                         trfr   E,B  50CD 1F                      fcb    $1f  50CE E9                      fcb    E<<4|B                               endm  50CF 5A                      decb             wzenum= 1...8, sn= 0...7                     *  50D0 1A   01                 sec              make reg bits + '10'  50D2 59                      rolb             sock TX buffer  50D3 1C   FE                 clc  50D5 59                      rolb                     *  50D6 1A   01                 sec  50D8 59                      rolb             write bit     '1'                     *  50D9 58                      lslb             variable size '00'  50DA 58                      lslb             xxx 10 100                     *  50DB 39                      rts                                          *                     * translate socket register in rx buffer address (data xfer)                     * prepares bit [7...0]                     *               50DC  tsk2rx    equ    *  50DC                         trfr   E,B  50DC 1F                      fcb    $1f  50DD E9                      fcb    E<<4|BFIO Simulation Structure             13:54:41  Jan 06, 2024   Page   98wzspi, basic spi routines                                                          endm  50DE 5A                      decb             wzenum= 1...8, sn= 0...7                     *  50DF 1A   01                 sec              make reg bits + '11'  50E1 59                      rolb             sock RX buffer  50E2 1A   01                 sec              make reg bits + '11'  50E4 59                      rolb                     *  50E5 1C   FE                 clc  50E7 59                      rolb             read bit     '0'                     *  50E8 58                      lslb             variable size '00'  50E9 58                      lslb             xxx 11 000  50EA 39                      rts                                          *                     * rdsk2fb, read socket data in fifo buffer                     * Y=sock, U=sock info                     * E=socket#                     * entry D= available count                     * return, D=xferred count                     *  50EB 34   76       RDSK2FB   pshs   d,x,y,u                     *  50ED 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  50F0 23   02                 bls    01f  50F2 EC   4A                 ldd    wzrqln,u  mandatory size  50F4 1F   01       01        tfr    D,X       size  50F6 ED   E4                 std    0,s       save xfrerred old  D  50F8 ED   48                 std    wzxfer,u  50FA 27   3C                 beq    15f       no data                     *  50FC BD   5032               jsr    GSRRXRP  50FF 34   06                 pshs   d         save socket read pointer  5101 1F   02                 tfr    D,Y                     *  5103 CE   8080               ldu    #SPIBASE  5106 34   01                 pshs   cc  5108                         pshsw  5108 1038                    fdb    $1038                               endm  510A 34   40                 pshs   u  510C 1A   50                 orcc   #$50      disable interrupts  510E 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  5110 A7   C4                 sta    spicmd,u  5112 10AF 44                 sty    hibyta,u  start address                      >5115 BD   50DC               jsr    tsk2rx    SOCK# to buffer address                       5118 E7   44                 stb    hibyta,u  511A 108E 0020               ldy    #fifo  511E E7   44                 stb    hibyta,u  shift out first data byteFIO Simulation Structure             13:54:41  Jan 06, 2024   Page   99wzspi, basic spi routines                             5120 33   45                 leau   lobyta,u  lobyte is the first byte shifted in  5122                         trfr   X,W  5122 1F                      fcb    $1f  5123 16                      fcb    X<<4|W                               endm  5124                         tfm4   U,Y  5124 113B                    fdb    $113b  5126 32                      fcb    U<<4|Y                               endm  5127 35   40                 puls   u  5129 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  512B A7   C4                 sta    spicmd,u  512D                         pulsw  restore   E:F  512D 1039                    fdb    $1039                               endm  512F 35   01                 puls   cc                     *  5131 35   06                 puls   d         old read pointer  5133 E3   E4                 addd   0,s       adjust transferred  5135 BD   5041               jsr    PSRRXRP   update pointer                     *  5138 35   F6       15        puls   d,x,y,u,pc                                                               *                     * wrfb2sk,write fifo buffer to socket buffer                     * Y=sock                     * E=socket#                     * on entry D= total amount to xfer                     * on return D= xferred count                     *  513A 34   76       WRFB2SK   pshs   d,x,y,u  513C 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  513F 23   02                 bls    01f  5141 EC   4A                 ldd    wzrqln,u  5143 1F   01       01        tfr    d,x  5145 ED   E4                 std    0,s  5147 ED   48                 std    wzxfer,u  report size  5149 27   3A                 beq    15f                     *  514B BD   4FFD               jsr    GSRTXWP   write pointer  514E 34   06                 pshs   d  5150 1F   02                 tfr    D,Y                     *  5152 CE   8080               ldu    #SPIBASE  5155 34   01                 pshs   cc  5157                         pshsw  save      E:F  5157 1038                    fdb    $1038                               endm  5159 34   40                 pshs   u  515B 1A   50                 orcc   #$50  515D 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS lowFIO Simulation Structure             13:54:42  Jan 06, 2024   Page  100wzspi, basic spi routines                             515F A7   C4                 sta    spicmd,u  5161 10AF 44                 sty    hibyta,u  start address                       5164 BD   50CD               jsr    tsk2tx                       5167 E7   44                 stb    hibyta,u  5169 108E 0020               ldy    #fifo  516D 33   44                 leau   hibyta,u  the first to shift out  516F                         trfr   X,W  516F 1F                      fcb    $1f  5170 16                      fcb    X<<4|W                               endm  5171                         tfm3   Y,U  5171 113A                    fdb    $113a  5173 23                      fcb    Y<<4|U                               endm  5174 35   40                 puls   u  5176 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  5178 A7   C4                 sta    spicmd,u  517A                         pulsw  restore   E:F  517A 1039                    fdb    $1039                               endm  517C 35   01                 puls   cc                     *  517E 35   06                 puls   d         old write pointer  5180 E3   E4                 addd   0,s  5182 BD   500C               jsr    PSRTXWP   update pointer                     *                     *  5185 35   F6       15        puls   d,x,y,u,pcFIO Simulation Structure             13:54:42  Jan 06, 2024   Page  101Debug Interface Routines                                                   5187               DB_main  5187 8D   4F                 bsr    DB_test   see if debug routines present  5189 6E   9F 6002            jmp    [DEBUGROM+2]  518D               DB_pdata  518D 8D   49                 bsr    DB_test   see if debug routines present  518F 6E   9F 6004            jmp    [DEBUGROM+4]  5193               DB_phex  5193 8D   43                 bsr    DB_test   see if debug routines present  5195 6E   9F 6006            jmp    [DEBUGROM+6]  5199               DB_phex2  5199 8D   3D                 bsr    DB_test   see if debug routines present  519B 6E   9F 6008            jmp    [DEBUGROM+8]  519F               DB_pcrlf  519F 8D   37                 bsr    DB_test   see if debug routines present  51A1 6E   9F 600A            jmp    [DEBUGROM+10]  51A5               DB_check  51A5 8D   31                 bsr    DB_test   see if debug routines present  51A7 6E   9F 600C            jmp    [DEBUGROM+12]  51AB               DB_config  51AB 8D   2B                 bsr    DB_test   see if debug routines present  51AD 6E   9F 600E            jmp    [DEBUGROM+14]  51B1 34   17       DB_msg    pshs   cc,d,x  51B3 AE   65                 ldx    1+2+2,s   get return address  51B5 EC   81                 ldd    ,x++      get mask word  51B7 B4   0401               anda   DB_cntrl  51BA F4   0402               andb   DB_cntrl+1  51BD 34   04                 pshs   b  51BF AA   E0                 ora    ,s+  51C1 27   04                 beq    10f       jump if flag not set  51C3 30   02                 leax   2,x       skip over false address & fall through  51C5 20   02                 bra    20f  51C7 AE   84       10        ldx    ,x        get false branch label  51C9 AF   65       20        stx    1+2+2,s   fix up return address  51CB 35   97                 puls   cc,d,x,pc return                     *  51CD               DB_pspace  51CD               DB_outsp  51CD 34   16                 pshs   d,x  51CF 8E   51D6               ldx    #00f  51D2 8D   B9                 bsr    DB_pdata  51D4 35   96                 puls   d,x,pc  51D6 20 00         00        fcc    ' ',0                       51D8 34   07       DB_test   pshs   cc,d  51DA FC   6000               ldd    DEBUGROM  Debug rom present?  51DD 1083 1234               cmpd   #$1234    special marker  51E1 27   05                 beq    99f       yes - exit  51E3 35   07                 puls   cc,d      no - abort DB_xx function  51E5 32   62                 leas   2,s  51E7 39                      rts  51E8 35   87       99        puls   cc,d,pc   returnFIO Simulation Structure             13:54:42  Jan 06, 2024   Page  102Debug Interface Routines                                                                                                     end    rom_initFIO Simulation Structure             13:54:42  Jan 06, 2024   Page  103Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AF_INET  0002   AF_UNIX  0001   AF_UNSP  0000   B        0009   CC       000A   CI_CFL   0080   CI_MP    0010   CI_POC   0020   CI_UNR   0040   CPU2DEV  0022   CPU_down 403D   CPUtraps FFF0   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check 51A5   DB_cntrl 0401   DB_confi 51AB   DB_iflg  0400   DB_main  5187   DB_msg   51B1   DB_outsp 51CD   DB_pcrlf 519F   DB_pdata 518D   DB_phex  5193   DB_phex2 5199   DB_pspac 51CD   DB_test  51D8   DBmsg00  4000   DBmsg01  4009   DBmsg02  4029   DEBUG    0D04   DEBUGROM 6000   DEBUG_CO 0000   DEV2CPU  0021   DEV_SIZE 0006   DEV_SOCK 45CD   DO_HISTO 0001   DP       000B   DPR_BASE 0000   D_END    002E   D_func0  0000   D_func1  0002   D_func10 0020   D_func11 0022   D_func12 0024   D_func13 0026   D_func2  0004   D_func3  0006   D_func4  0008   D_func5  000A   D_func6  000C   D_func7  000E   D_func8  0010   D_func9  0012   D_funcA  0014   D_funcB  0016   D_funcC  0018   D_funcD  001A   D_funcE  001C   D_funcF  001E   D_init   002A   D_inthan 0028   D_test   002C   E        000E   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SOCKET 00C0   E_SYSBSY 0082   F        000F   FF       0040   FIFO_get 42D9   FIFO_put 42FE   FIFOgeta 42D0   FIFOputa 42F6   FIOPRI   FFCE   FIO_get  42AE   FIO_lock 0446   FIO_rel  42C3   GCRGA    4C34   GCRILLT  4CFC   GCRIMR   4D38   GCRIR    4D1A   GCRMR    4C16   GCRPHY   4DF4   GCRRCR   4DB0   GCRRTR   4D92   GCRSHA   4C90   GCRSIMR  4D74   GCRSIP   4CCE   GCRSIR   4D56   GCRSNM   4C62   GCRUIP   4DDD   GCRURP   4DCE   GCRVERS  4E12   GSKATM   50A3   GSRCR    4E3F   GSRDHAR  4EAF   GSRDIP   4EED   GSRDPOR  4F1B   GSRFRAG  5085   GSRIMR   5067   GSRIR    4E64   GSRMR    4E21   GSRMSS   4F39   GSRPORT  4E91   GSRRBFS  4F93   GSRRXRP  5032   GSRRXRS  501B   GSRRXWP  5050   GSRSR    4E82   GSRTBFS  4FB1   GSRTOS   4F57   GSRTTL   4F75   GSRTXFR  4FCF   GSRTXRP  4FE6   GSRTXWP  4FFD   HANGS    0001   HRECSIZ  0004   H_cpu    444C   H_fio    4470   IF       0010   INTS     0002   IO_end   4377   IO_han   4319   IRQ_han  4395   IRQmsg10 43A2   IS       0003   IU       0002   IX       0000   IY       0001   MAXHIST  0010   MAXTBL   0004   MAX_DEV  0001   MAX_S_NU 0014   MAX_TI   0009   MAX_UDP  05C0   MAX_WZ   0008   MOD_SIZE 0004   NET      0001   NUM_TSK  0459   O_INTRPT 0038   PACK_COM 0000   PACK_FIR 0080   PACK_REM 0001   PC       0005   PCRGA    4C4B   PCRILLT  4D0B   PCRIMR   4D47   PCRIR    4D29   PCRMR    4C25   PCRPHY   4E03   PCRRCR   4DBF   PCRRTR   4DA1   PCRSHA   4CAF   PCRSIMR  4D83   PCRSIP   4CE5   PCRSIR   4D65   PCRSNM   4C79   PF_INET  0002   PF_UNIX  0001   POLPRI   FFBA   PSRCR    4E4E   PSRDHAR  4ECE   PSRDIP   4F04   PSRDPOR  4F2A   PSRFRAG  5094   PSRIMR   5076   PSRIR    4E73   PSRKATM  50B2   PSRMR    4E30   PSRMSS   4F48   PSRPORT  4EA0   PSRRBFS  4FA2   PSRRXRP  5041   PSRTBFS  4FC0   PSRTOS   4F66   PSRTTL   4F84   PSRTXWP  500C   QFF1     0080   QUITS    0003   RAMend   3EFF   RAMorg   0400   RAMscrat 7000   RAMscren 7E00   RDSK2FB  50EB   REJECT   0080   ROMLOorg 4000   ROM_ERR  40B5   ROM_VERS 0030   ROMstack 7FE0   RSVREG   0003   RUNPRI   0046   R_ACCEPT 000B   R_BIND   0009   R_CLOSE  0002   R_CONNEC 0008   R_DISCON 000C   R_INTRPT 0007   R_LISTEN 000A   R_OPEN   0001   R_RDFRM  0021   R_READ   0006   R_RQRD   0005   R_RQRDNB 0015   R_RQWR   0003   R_RQWRNB 0013   R_RRDFD  0022   R_RSNDTO 0023   FIO Simulation Structure             13:54:43  Jan 06, 2024   Page  104Debug Interface Routines                            R_SNDKEP 000E   R_SNDMAC 000D   R_SPCL   000F   R_WRITE  0004   R_WSNDTO 0024   S        0004   SIQPRI   FFD8   SI_CON   0001   SI_DIS   0002   SI_HAN   43E9   SI_Q     040E   SI_Q_ptr 0444   SI_RCV   0004   SI_SOK   0010   SI_TIM   0008   SKADLN   0010   SKPRI    FFC4   SK_DGRM  0002   SK_RAW   0003   SK_STRM  0001   SNCR     0001   SNDHAR0  0006   SNDHAR1  0007   SNDHAR2  0008   SNDHAR3  0009   SNDHAR4  000A   SNDHAR5  000B   SNDIPR0  000C   SNDIPR1  000D   SNDIPR2  000E   SNDIPR3  000F   SNDPOR0  0010   SNDPOR1  0011   SNFRAG0  002D   SNFRAG1  002E   SNIMR    002C   SNIR     0002   SNKATIM  002F   SNMR     0000   SNMSSR0  0012   SNMSSR1  0013   SNPORT0  0004   SNPORT1  0005   SNRBFSZ  001E   SNRXRP0  0028   SNRXRP1  0029   SNRXRZ0  0026   SNRXRZ1  0027   SNRXWP0  002A   SNRXWP1  002B   SNSR     0003   SNTBFSZ  001F   SNTOS    0015   SNTTL    0016   SNTXFR0  0020   SNTXFR1  0021   SNTXRP0  0022   SNTXRP1  0023   SNTXWP0  0024   SNTXWP1  0025   SPIBASE  8080   SPI_AUT  0008   SPI_CR_  0001   SPI_CS_  0040   SPI_HLD  0002   SPI_IEN  0010   SPI_IRQ  0001   SPI_RST  0020   SPI_SR_  0004   SYS_TABS 04C6   S_ACCEPT 0058   S_BIND   0048   S_CLOSE  0010   S_CONNEC 0040   S_DISCON 0060   S_INTRPT 0038   S_LISTEN 0050   S_OPEN   0008   S_READ   0030   S_RQRD   0028   S_RQWR   0018   S_RRDFRM 0080   S_RREAD  0088   S_SNDKEP 0070   S_SNDMAC 0068   S_SPCL   0078   S_WRITE  0020   S_WRQSTO 0090   S_WSNDTO 0098   TFREE    0004   TRUN     0001   TSKSIZ   00D7   TSLEEP   0002   TSYS     0005   TWAIT    0003   U        0003   USTSIZ   00C0   V        0007   W        0006   WCACCP   0086   WCBIND   0085   WCCLOS   0010   WCCONN   0004   WCDISC   0008   WCLIST   0002   WCOPEN   0001   WCRECV   0040   WCRRQD   0081   WCSEND   0020   WCSKEP   0022   WCSNAC   0021   WCSPEC   0080   WCXMDR   0082   WFNBLK   0001   WRFB2SK  513A   WSCLSD   0000   WSCLSG   001A   WSCLWT   001C   WSESTB   0017   WSFWAI   0018   WSINIT   0013   WSLACK   001D   WSLIST   0014   WSMCRW   0042   WSRNBL   001E   WSRRQF   0081   WSSPEC   0080   WSSYNR   0016   WSSYNS   0015   WSTIMW   001B   WSUDP    0022   WSWNBL   001F   WSXMDD   0082   WZ5_name 41C1   WZBUSY   0080   WZGAR0   0001   WZGAR1   0002   WZGAR2   0003   WZGAR3   0004   WZILLT0  0013   WZILLT1  0014   WZIMR    0016   WZIR     0015   WZLCSZ   0016   WZMR     0000   WZNETOF  0360   WZPHY    002E   WZRCR    001B   WZRTR0   0019   WZRTR1   001A   WZSHAR0  0009   WZSHAR1  000A   WZSHAR2  000B   WZSHAR3  000C   WZSHAR4  000D   WZSHAR5  000E   WZSIMR   0018   WZSIPR0  000F   WZSIPR1  0010   WZSIPR2  0011   WZSIPR3  0012   WZSIR    0017   WZSIZE   0028   WZSKIO   0002   WZSKIP   0040   WZSKIS   0004   WZSKOFF  0220   WZSLCK   0001   WZSUBR0  0005   WZSUBR1  0006   WZSUBR2  0007   WZSUBR3  0008   WZUIPR0  0028   WZUIPR1  0029   WZUIPR2  002A   WZUIPR3  002B   WZUPRT0  002C   WZUPRT1  002D   WZVERS   0039   WZWLCK   0010   X        0001   Y        0002   bad_cmd  4392   bittab   46C1   bmread   4BAD   bt2num   46B0   byterd   4B89   bytewr   4BE6   change   4494   chproc   040C   clock_ti 0455   conlb1   476A   cpu_fio  0000   cpu_fio1 0001   cpu_fio2 0003   cpu_fio3 0004   cpu_fio4 0006   cpu_fio5 0008   cpu_fioF 0024   dev_addr 0000   dev_brbu 0004   dev_tab  04A0   dev_type 0002   end_vars 3EFF   fifo     0020   fifo_cnt 0012   fifo_get 0014   fifo_put 0016   fifo_us0 0018   fifo_us1 001A   fifo_us2 001C   fifo_us3 001E   fio_cpu  0009   fio_cpu1 000A   fio_cpu2 000C   fio_cpu3 000D   fio_cpu4 000F   fio_cpu5 0011   fio_cpuF 0023   fio_dsz  405C   fio_fsz  405A   fio_irq  420C   fio_msg  4276   fio_rese 41CC   fio_resp 4292   fio_star 407D   fio_wait 41EF   fiointe  4275   functb   4ABD   getjo1   44DC   getjo2   44EB   getjo4   44F2   getjo6   44FB   getjo8   44FD   getjob   44D6   hibyta   0004   hibyts   0006   hst_cmd  0000   hst_seq  0001   hst_tty  0002   hst_val  0003   hstbuf   045A   hstptr   049A   idle     040D   int_all  43BA   int_buf  0447   int_ptr  0453   jobpri   040B   lobyta   0005   lobyts   0007   lstram   04C6   makrd6   4555   makrdy   4540   max_trn  405E   mod_name 0002   mod_tbl  41BB   mod_type 0000   no_dev   413C   num2bt   46A6   nwp_strt 0000   FIO Simulation Structure             13:54:43  Jan 06, 2024   Page  105Debug Interface Routines                            oldorg   4B55   polext   4784   putru1   4514   putru2   451B   putru4   4529   putru5   4538   putru6   453C   putrun   4507   rdrqer1  489E   rom_bad  40B3   rom_firq 4086   rom_init 405F   rom_int  40A8   rom_nmi  4080   rom_swi  408D   rom_swi2 4093   rom_swi3 409A   rom_trap 40A1   rsche2   44AB   rsche3   44BF   rsched   449A   runlst   0403   sa_dat   0002   sa_fam   0000   sdev_sig 4619   send_SI  442B   set_tabl 40F4   showrg   4AEF   sin_addr 0014   sin_fam  0010   sin_port 0012   skacpt   4824   skbind   47AD   skclin   46E5   skclos   46CA   skcner1  47A3   skcner2  4790   skcner3  47A7   skcner4  479F   skcner5  479B   skcner6  4794   skconn   4717   skctcp   463F   skcudp   4648   skdisc   4B4E   skfres   4638   skinit   45FB   skinthan 4618   skintrp  4B4E   sklist   47F2   sknewp   461A   skopen   4651   skoper1  469C   skoper2  46A0   skrecv   48A3   skreqrd  485B   skreqwr  48C5   sksend   4906   skskep   4B4E   sksmac   4B4E   skspcl   4A96   sktest   4615   skurrd   49A9   skurrdf  4928   skurwt   49D3   skusnt   4A6A   skuwr2   4A21   sleep    457A   sleep7   45A2   slplst   0405   spicmd   0000   spicon   0001   spiint   0456   spinit   4B55   spista   0000   spistr2  4B5B   sprend   4C04   stbinit  40C2   sto_chk  4143   swtchu   44CB   sys_vars 0400   tim_base 8400   tim_rest 8401   timerack 41AF   timerchk 41B5   timerin  41A9   tsagin   000F   tscmd    0009   tsdev    000D   tsevnt   0006   tsk2rg   50C1   tsk2rx   50DC   tsk2tx   50CD   tskend   049E   tskinit  4151   tsktab   049C   tslink   0000   tsprir   0005   tsseq    000A   tssgnl   0008   tsslnk   0002   tsstat   0004   tstval   000C   umark0   0013   umark1   0015   usp      0011   utask    0409   wakeu2   4561   wakeu3   4568   wakeu4   456C   wakeu5   456E   wakeup   4556   wlocip   0360   wordrd   4B9B   wordwr   4BF5   wzanyp   0457   wzcmnd   0004   wzdev    4AC5   wzdevt   462C   wzdma1   000C   wzdma2   000E   wzdprt   0012   wzdsta   0012   wzenum   0000   wzerr    0007   wzfaml   0022   wzflg    0003   wzfsta   0002   wzgwad   0008   wzhwad   000C   wzipad   0014   wzmyip   0000   wzprot   0026   wzrqln   000A   wzsbnm   0004   wzsflg   0018   wzsk1    0338   wzsk2    0310   wzsk3    02E8   wzsk4    02C0   wzsk5    0298   wzsk6    0270   wzsk7    0248   wzsk8    0220   wzsprt   0010   wzstat   0005   wztype   0024   wzuipa   001A   wzupkt   0006   wzuprt   001E   wzurms   0020   wzxfer   0008   xmtint   45AF   