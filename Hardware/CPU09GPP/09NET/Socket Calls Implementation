
UniFLEX 6X09 now can have TCP/IP networking! In the past years, but more specifically
in the last months I have implemented the networking in the UniFLEX kernel and wrote
the firmware code for the CPU09GPP that drives the 09NET board.

As the UniFLEX kernel only supports 4 system call arguments some things had to change,
but I tried to make the changes such that porting Unix code should not be too difficult.

1.0  Implemented calls 

    socket(), connect(), bind(), listen(), accept(), read() and write(), recvfrom(), sendto(), close()

    sfdn = socket(family, type, proto)

    sfdn is an int that references the socket, identical to the value that is returned by open(file,mode)
    family is one of AF_INT. (AF_UNIX is not implemented)
    type   is one of SOCK_STREAM, SOCK_DGRM
    proto  is not used and discarded

    int connect(sfdn, *addr, addrlen)

    int is returned status
    *addr is Pointer to a sockaddr_in formatted data item
       sockaddr_in {
            int16_t       family;
            uint16_t      port;
            uint32_t      ipaddress;
       }
       in assmbler that translates to:

                org     0
        addr    fdb     AF_INET
                fdb     <port to connect to>
                fcb     <ip3>,<ip2>,<ip1>,<ip0>
        addrlen equ     *-addr

        The call can be setup statically as

                sys     skconn,<value_of_sfdn>,taddr,taddrl
        
        taddr   fdb     AF_INET
                fdb     10000           i.e. port 10000
                fcb     192,168,1,10    i.e. target IP
        taddrl  fdb     *-taddr         (8bytes / 4 words)

        It will be clear that static calls are not handy in this example
        A dynamic system call would be

                ldd     taddrl
                pshs    d
                ldd     taddr
                pshs    d
                ldd     sfdn    
                pshs    d
                lda     #skconn
                pshs    a
                tfr     s,x
                sys     indx
                leas    7,s
                bec     .....
            
     
    int bind(sfdn, *addr, addrlen)

    Same remarks as for connect() are valid.

    int listen(sfdn, backlog)

    the backlog is at this moemnt fixed at 1.

    int accept(sfdn)

    at this moment it does not do very much, but advances the state of the socket only

    int read(sfdn, *buff, len)

    this call works IDENTICAL as for a file read.

    int write(sfdn, *buf, len)

    this call works IDENTICAL as for a file write.

    close() does handle files and sockets the same way

    The above are all TCP type calls, except for socket() and close()

    The following 2 calls are UDP only

    int recvfrom(sfdn, *buf, len, *faddr)

    The Unix call has recvfrom(sfd, *buf, len, flags, *faddr, *flen)

    I had to ommit the flags and the *len arguments, which can be done with some care.
    ** addrlen is ALWAYS assumed to be 8 bytes **

    In the same way the other call has been modified

    int sendto(sfdn, *buf, len, *taddr)

    The C library also handles the calls the same way as the assembler implementation.
 

